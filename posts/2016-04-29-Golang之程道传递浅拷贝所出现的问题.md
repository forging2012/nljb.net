---
title: Golang之程道传递浅拷贝所出现的问题
date: '2016-04-29'
description:
categories:

tags:golang

---

>

##### 程道传递浅拷贝

>

****下面这个例子看来没有什么问题，但是当发送数据时问题就出现了****

>

	// 解释一下：
	当发送的[]byte通过buf[0:n]方式获取的浅拷贝只是个原buf的指针
    当发送到程道内后被接收到的也是个指针，而且该指针指向的数据已经被
    下一次读取的数据所覆盖，所以问题就出现了

>

	简单的来说就是，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存
    而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存

>

	// 创建一个程道
	c = make(chan []byte)

    buf := make([]byte, 100)
    for {

        // 读取数据
        n, _ := socket.Read(buf)

        // 发送到程道
        c <- buf[0:n]

    }

    // 接收程道数据
    x := <- c
    fmt.Printf(x)

>

	如何解决：
    该如何解决这个问题呢，有人会这样做string(buf[0:n])转换后再发送，这样其实跟深层拷贝类似，转换成一个新的对象

>

	// 或者可以这样来:(深拷贝数据后发送)
    x := make([]byte, nr)
	copy(x, buf[0:nr])
    c <- x

>