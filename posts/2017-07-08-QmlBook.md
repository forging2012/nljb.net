---
title: QmlBook
date: '2017-07-08'
description:
categories:

tags:qt

---

>

> https://cwc1987.gitbooks.io/qmlbook-in-chinese/

>

### 语法（QML Syntax）

>

    // 让我们开始用一个简单的QML文件例子来解释这个语法。
    import QtQuick 2.6
    import QtQuick.Window 2.2

    // 窗口
    Window {

        visible: true // 显示/隐藏
        id: root // 根元素ID推荐使用root
        width: 640
        height: 480
        title: qsTr("Hello World")

        // 元素可以嵌套，这意味着一个父元素可以拥有多个子元素。
        // 子元素可以通过访问parent关键字来访问它们的父元素。

        // 矩形
        Rectangle {
            // name this element a
            id: a

            // properties: <name>: <value>
            width: parent.width; height: parent.height

            // color property
            color: "#D8D8D8"

            // Declare a nested element (child of root)
            Image {
                id: rocket

                // reference the parent
                x: (parent.width - width)/2; y: 40

                source: 'rocket.png'
            }

            // Another child of root
            Text {
                // un-named element

                // reference element by id
                y: rocket.y + rocket.height + 20

                // reference root element
                width: root.width

                horizontalAlignment: Text.AlignHCenter
                text: 'Rocket'
            }
        }
    }

>

#### 属性（Properties）

>

    Text {
        // 一个id在一个QML文档中是唯一的，并且不能被设置为其它值，也无法被查询
        // (1) identifier
        id: thisLabel

        // 一个属性能够设置一个值，这个值依赖于它的类型。
        // 如果没有对一个属性赋值，那么它将会被初始化为一个默认值。
        // (2) set x- and y-position
        x: 24; y: 16

        // 一个属性能够依赖一个或多个其它的属性，这种操作称作属性绑定。
        // (3) bind height to 2 * width
        height: 2 * width

        // 添加自己定义的属性需要使用property修饰符，然后跟上类型，名字和可选择的初始化值
        /*
        注意如果属性名与已定义的默认属性名不重复，使用default关键字你可以将一个属性定义为默认属性。
        这在你添加子元素时用得着，如果他们是可视化的元素，子元素会自动的添加默认属性的子类型链表
        （children property list）
        */
        // (4) custom property
        property int times: 24

        // alias关键字允许我们转发一个属性或者转发一个属性对象自身到另一个作用域
        // 我们将在后面定义组件导出内部属性或者引用根级元素id会使用到这个技术。
        // 一个属性别名不需要类型，它使用引用的属性类型或者对象类型。
        // (5) property alias
        property alias anotherTimes: thisLabel.times

        // int整型数据会自动的转换为string字符串类型数据
        // (6) set text appended by value
        text: "Greetings " + times

        // 一些属性是按组分配的属性。
        // 当一个属性需要结构化并且相关的属性需要联系在一起时，我们可以这样使用它。
        // 另一个组属性的编码方式是 font{family: "UBuntu"; pixelSize: 24 }。
        // (7) font is a grouped property
        font.family: "Ubuntu"
        font.pixelSize: 24

        // 一些属性是元素自身的附加属性。
        // 这样做是为了全局的相关元素在应用程序中只出现一次
        // (8) KeyNavigation is an attached property
        KeyNavigation.tab: otherLabel

        // 对于每个元素你都可以提供一个信号操作。
        // 这个操作在属性值改变时被调用。
        // (9) signal handler for property changes
        onHeightChanged: console.log('height:', height)

        // focus is neeed to receive key events
        focus: true

        // change color based on focus value
        color: focus?"red":"black"
    }

>

#### 脚本（Scripting）

>

    Text {
        id: label

        x: 24; y: 24

        // custom counter property for space presses
        property int spacePresses: 0

        text: "Space pressed: " + spacePresses + " times"

        // (1) handler for text changes
        onTextChanged: console.log("text changed to:", text)

        // need focus to receive key events
        focus: true

        // (2) handler with some JS
        Keys.onSpacePressed: {
            increment()
        }

        // clear the text on escape
        Keys.onEscapePressed: {
            label.text = ''
        }

        // (3) a JS function
        function increment() {
            spacePresses = spacePresses + 1
        }
    }

>

---

>

### 基本元素（Basic Elements）

>

- 元素可以被分为可视化元素与非可视化元素。
    - 一个可视化元素（例如矩形框Rectangle）有着几何形状并且可以在屏幕上显示。
    - 一个非可视化元素（例如计时器Timer）提供了常用的功能，通常用于操作可视化元素。

>

#### 基础元素对象（Item Element）

-

> Item（基本元素对象）通常被用来作为其它元素的容器使用，类似HTML语言中的div元素。

> Item（基础元素对象）是所有可视化元素的基础对象，所有其它的可视化元素都继承自Item。

- 它自身不会有任何绘制操作，但是定义了所有可视化元素共有的属性：
    - Geometry（几何属性）
        - x,y（坐标）定义了元素左上角的位置，width，height（长和宽）定义元素的显示范围
        - z（堆叠次序）定义元素之间的重叠顺序。
    - Layout handling（布局操作）
        - anchors（锚定），包括左（left），右（right），上（top），下（bottom）
        - 水平与垂直居中（vertical center，horizontal center）
        - 与margins（间距）一起定义了元素与其它元素之间的位置关系。
    - Key handlikng（按键操作）
        - 附加属性key（按键）和keyNavigation（按键定位）属性来控制按键操作
        - 处理输入焦点（focus）可用操作。
    - Transformation（转换）
        - 缩放（scale）和rotate（旋转）转换，通用的x,y,z属性列表转换（transform）
        - 旋转基点设置（transformOrigin）。
    - Visual（可视化）
        - 不透明度（opacity）控制透明度，visible（是否可见）控制元素是否显示
        - clip（裁剪）用来限制元素边界的绘制，smooth（平滑）用来提高渲染质量。
    - State definition（状态定义）
        - states（状态列表属性）提供了元素当前所支持的状态列表
        - 当前属性的改变也可以使用transitions（转变）属性列表来定义状态转变动画。

>

#### 矩形框元素（Rectangle Element）

>

    Rectangle {
        id: rect1
        x: 12; y: 12
        width: 76; height: 96
        color: "lightsteelblue"
    }
    Rectangle {
        id: rect2
        x: 112; y: 12
        width: 76; height: 96
        border.color: "lightsteelblue" // 边界颜色
        border.width: 4 // 边界宽度
        radius: 8 // 半径
    }

    // 此外，填充的颜色与矩形的边框也支持自定义的渐变色。
    // 一个渐变色是由一系列的梯度值定义的。每一个值定义了一个位置与颜色。
    // 位置标记了y轴上的位置（0 = 顶，1 = 底）。
    // GradientStop（倾斜点）的颜色标记了颜色的位置。
    Rectangle {
        id: rect1
        x: 12; y: 12
        width: 176; height: 96
        gradient: Gradient {
            GradientStop { position: 0.0; color: "lightsteelblue" }
            GradientStop { position: 1.0; color: "slategray" }
        }
        border.color: "slategray"
    }

>

#### 文本元素（Text Element）

>

- 文本可以使用horizontalAlignment与verticalAlignment属性来设置它的对齐效果
- 你可以使用style和styleColor属性来配置文字的外框效果，浮雕效果或者凹陷效果
- 对于过长的文本，你可能需要使用省略号来表示，你可以使用elide属性来完成这个操作
    - elide属性允许你设置文本左边，右边或者中间的省略位置
	- 如果你不想'....'省略号出现，并且希望使用文字换行的方式显示所有的文本
    - 你可以使用wrapMode属性（这个属性只在明确设置了宽度后才生效）

>

    Text {
        text: "The quick brown fox" // 文本
        color: "#303030"
        font.family: "Ubuntu" // 字体
        font.pixelSize: 28
    }

    Text {
        width: 40; height: 120
        text: 'A very long text'
        // '...' shall appear in the middle
        elide: Text.ElideMiddle
        // red sunken text styling
        style: Text.Sunken
        styleColor: '#FF4444'
        // align text to the top
        verticalAlignment: Text.AlignTop
        // only sensible when no elide mode
        // wrapMode: Text.WordWrap
    }

>

#### 图像元素（Image Element）

-

> 一个图像元素（Image Element）能够显示不同格式的图像（例如PNG,JPG,GIF,BMP）

>

- source属性（source property）提供了图像文件的链接信息
- fillMode（文件模式）属性能够控制元素对象的大小调整行为。

>

- 一个URL可以是使用'/'语法的本地路径（"./images/home.png"）或者一个网络链接
- 使用PreserveAspectCrop可以避免裁剪图像数据被渲染到图像边界外 ...
- 默认情况下裁剪是被禁用的（clip:false），你需要打开裁剪（clip:true）来约束边界矩形的绘制

>

    Image {
        x: 12; y: 12
        // width: 48
        // height: 118
        source: "assets/rocket.png"
    }

    Image {
        x: 112; y: 12
        width: 48
        height: 118/2
        source: "assets/rocket.png"
        fillMode: Image.PreserveAspectCrop
        clip: true
    }

>

#### 鼠标区域元素（MouseArea Element）

-

> 为了与不同的元素交互，你通常需要使用MouseArea（鼠标区域）元素
> 当用户与可视化端口交互时，mouseArea通常被用来与可视化元素对象一起执行命令

> 这是非常重要的概念，输入处理与可视化显示分开。这样你的交互区域可以比你显示的区域大很多。

>

    Rectangle {
        id: rect1
        x: 12; y: 12
        width: 76; height: 96
        color: "lightsteelblue"
        MouseArea {
            id: area
            width: parent.width
            height: parent.height
            onClicked: rect2.visible = !rect2.visible
        }
    }

    Rectangle {
        id: rect2
        x: 112; y: 12
        width: 76; height: 96
        border.color: "lightsteelblue"
        border.width: 4
        radius: 8
    }

>

---

>

### 组件（Compontents）

-

> 一个组件是一个可以重复使用的元素，QML提供几种不同的方法来创建组件
> 但是目前我们只对其中一种方法进行讲解：一个文件就是一个基础组件

>

    // Button.qml

    // 一个矩形
    Rectangle {
        // ID为root
        id: root

        // 将内部嵌套的QML元素的属性导出到外面使用
        property alias text: label.text // 绑定 label.text
        signal clicked // 声明信号（实现在mail.qml中）

        width: 116; height: 26
        color: "lightsteelblue"
        border.color: "slategrey"

        // Button 文本 ...
        Text {
            id: labels
            anchors.centerIn: parent
            text: "Start"
        }

        // 鼠标区域
        MouseArea {
            anchors.fill: parent
            // 点击时调用 root.clicked()
            onClicked: {
                root.clicked()
            }
        }
    }


    // 我们使用了QML的alias（别名）的功能，它可以将内部嵌套的QML元素的属性导出到外面使用。
    // 有一点很重要，只有根级目录的属性才能够被其它文件的组件访问。

>

    // 使用我们新的Button元素只需要在我们的文件中简单的声明一下就可以了:

    Window {
        visible: true
        width: 640
        height: 480
        title: qsTr("Hello World")

        Button { // our Button component
            id: button
            x: 12; y: 12
            text: "Start"
            onClicked: {
                status.text = "Button clicked!"
            }
        }

        Text { // text changes when button was clicked
            id: status
            x: 12; y: 76
            width: 116; height: 26
            text: "waiting ..."
            horizontalAlignment: Text.AlignHCenter
        }
    }

>

    // 就个人而言，可以更进一步的使用基础元素对象（Item）作为根元素。
    // 这样可以防止用户改变我们设计的按钮的颜色，并且可以提供出更多相关控制的API（应用程序接口）

    Item {
        id: root
        Rectangle {
            anchors.fill parent
            color: "lightsteelblue"
            border.color: "slategrey"
        }
        ...
    }

>

---

>

### 简单的转换（Simple Transformations）

-

> 转换操作改变了一个对象的几何状态。QML元素对象通常能够被平移，旋转，缩放。下面我们将讲解这些简单的操作和一些更高级的用法

>

- 简单的位移是通过改变x,y坐标来完成的。
- 旋转是改变rotation（旋转）属性来完成的，这个值使用角度作为单位（0~360）。
- 缩放是通过改变scale（比例）的属性来完成的，小于1意味着缩小，大于1意味着放大。
- 旋转与缩放不会改变对象的几何形状，对象的x,y（坐标）与width/height（宽/高）也类似。
- 请记住：文档中元素的顺序很重要 ...

>

    import QtQuick 2.0

    Item {
        // set width based on given background
        width: bg.width
        height: bg.height

        Image { // nice background image
            id: bg
            source: "assets/background.png"
        }

        MouseArea {
            id: backgroundClicker
            // needs to be before the images as order matters
            // otherwise this mousearea would be before the other elements
            // and consume the mouse events
            anchors.fill: parent
            onClicked: {
                // reset our little scene
                rocket1.x = 20 // 坐标
                rocket2.rotation = 0 // 旋转
                rocket3.rotation = 0
                rocket3.scale = 1.0 // 比例
            }
        }

        ClickableImage {
            id: rocket1
            x: 20; y: 100
            source: "assets/rocket.png"
            onClicked: {
                // increase the x-position on click
                x += 5
            }
        }

        ClickableImage {
            id: rocket2
            x: 140; y: 100
            source: "assets/rocket.png"
            smooth: true // need antialising // 打开平滑
            onClicked: {
                // increase the rotation on click
                rotation += 5
            }
        }

        ClickableImage {
            id: rocket3
            x: 240; y: 100
            source: "assets/rocket.png"
            smooth: true // need antialising // 打开平滑
            onClicked: {
                // several transformations
                rotation += 5
                scale -= 0.05
            }
        }
    }

>

---

>

### 定位元素（Positioning Element）

-

> 有一些QML元素被用于放置元素对象，它们被称作定位器，QtQuick模块提供了Row，Column，Grid，Flow用来作为定位器

>

    // 定义一个红色的矩形
    // RedSquare.qml

    import QtQuick 2.0

    Rectangle {
        width: 48
        height: 48
        color: "#ea7025"
        border.color: Qt.lighter(color)
    }

>

    // Column（列）元素将它的子对象通过顶部对齐的列方式进行排列
    Window {
        visible: true
        width: 640
        height: 480
        title: qsTr("Hello World")

        Rectangle {
            width: 640
            height: 480

            Column {
                id: column
                anchors.centerIn: parent
                spacing: 8
                RedSquare { }
                RedSquare { width: 96 }
                RedSquare { }
            }
        }

    }

>

    // Row（行）元素将它的子对象从左到右，或者从右到左依次排列，排列方式取决于layoutDirection属性
    Window {
        visible: true
        width: 640
        height: 480
        title: qsTr("Hello World")

        Rectangle {
            width: 640
            height: 480

            Row {
                id: row
                anchors.centerIn: parent
                spacing: 20
                RedSquare { }
                RedSquare { height:96 }
                RedSquare { }
            }
        }

    }

>

    // Grid（栅格）元素通过设置rows（行数）和columns（列数）将子对象排列在一个栅格中
    Window {
        visible: true
        width: 640
        height: 480
        title: qsTr("Hello World")

        Rectangle {
            width: 640
            height: 480

            Grid {
                id: grid
                rows: 2
                columns: 2
                anchors.centerIn: parent
                spacing: 8
                RedSquare { }
                RedSquare { }
                RedSquare { }
                RedSquare { }
            }
        }

    }

>

    // 最后一个定位器是Flow（流）。通过flow（流）属性和layoutDirection（布局方向）属性来控制流的方向
    Window {
        visible: true
        width: 640
        height: 480
        title: qsTr("Hello World")

        Rectangle {
            width: 160
            height: 160

            Flow { // Rectangle 宽度不够时自动换行 ...
                anchors.fill: parent
                anchors.margins: 20
                spacing: 20
                RedSquare { }
                RedSquare { }
                RedSquare { }
            }
        }

    }

>

	// 循环 ...
	// 通常Repeater（重复元素）与定位器一起使用。
	// 它的工作方式就像for循环与迭代器的模式一样。
	// 在这个最简单的例子中，仅仅提供了一个循环的例子。

	Window {
			visible: true
			width: 640
			height: 480
			title: qsTr("Hello World")

			Rectangle {
					id: root
					width: 640
					height: 480
					// 声明变量 ...
					property variant colorArray: ["#00bde3", "#67c111", "#ea7025"]

					Grid{
							anchors.fill: parent
							anchors.margins: 8
							spacing: 4
							Repeater { // Repeater 重复器
									model: 16
									Rectangle {
											width: 56; height: 56
											property int colorIndex: Math.floor(Math.random()*3)
											color: root.colorArray[colorIndex]
											border.color: Qt.lighter(color)
											Text {
													anchors.centerIn: parent
													color: "#f0f0f0"
													text: "Cell " + index
											}
									}
							}
					}
			}

	}

>

---

>

### 布局元素（Layout Items）

-

> QML使用anchors（锚）对元素进行布局。

> anchoring（锚定）是基础元素对象的基本属性，可以被所有的可视化QML元素使用

>

- 一个元素有6条锚定线
        -（top顶，bottom底，left左，right右，horizontalCenter水平中，verticalCenter垂直中）。
* 在文本元素（Text Element）中有一条文本的锚定基线（baseline）。
* 每一条锚定线都有一个偏移（offset）值
        - 在top（顶），bottom（底），left（左），right（右）的锚定线中它们也被称作边距。
* 对于horizontalCenter（水平中）与verticalCenter（垂直中）与baseline（文本基线）中被称作偏移值。

>

	// 元素填充它的父元素。
    Rectangle {
        Text {
            width: 12
            anchors.fill: parent // 锚定: 充满(fill),父(parent)
            anchors.margins: 8 // （间距）定义了元素与其它元素之间的位置关系。
            text: '(1)'
        }
    }

	// 元素左对齐它的父元素。
    Rectangle {
         Text {
             width: 48
             y: 8
             anchors.left: parent.left 锚定: 左，对齐父左
             anchors.leftMargin: 8
             text: '(2)'
         }
     }

	// 元素的左边与它父元素的右边对齐。
    Rectangle {
         Text {
             width: 48
             anchors.left: parent.right // 元素左，对齐父右
             text: '(3)'
         }
     }

	// 元素中间对齐
	Rectangle {
         Rectangle {
             id: blue1
             width: 48; height: 24
             y: 8
                         // Blue1与它的父元素水平中间对齐
             anchors.horizontalCenter: parent.horizontalCenter
         }
         Rectangle {
                         // Blue2与Blue1中间对齐，并且它的顶部对齐Blue1的
             id: blue2
             width: 72; height: 24
             anchors.top: blue1.bottom
             anchors.topMargin: 4
             anchors.horizontalCenter: blue1.horizontalCenter
             text: '(4)'
         }
     }

	// 元素在它的父元素中居中。
    Rectangle {
         Rectangle {
             width: 48
             anchors.centerIn: parent
             text: '(5)'
         }
     }

	// 元素水平方向居中对齐父元素并向后偏移12像素，垂直方向居中对齐。
    Rectangle {
         Rectangle {
             width: 48
             anchors.horizontalCenter: parent.horizontalCenter
             anchors.horizontalCenterOffset: -12
             anchors.verticalCenter: parent.verticalCenter
             text: '(6)'
         }
     }

>

---

>

### 输入元素（Input Element）

-

> 我们已经使用过MouseArea（鼠标区域）作为鼠标输入元素。

> 我们开始介绍文本编辑的元素：TextInput（文本输入）和TextEdit（文本编辑）。

>

#### 文本输入（TextInput）

>

	// 文本输入允许用户输入一行文本。
	// 这个元素支持使用正则表达式验证器来限制输入和输入掩码的模式设置。
	Rectangle {
			width: 200
			height: 80
			color: "linen"

			TextInput {
					id: input1
					x: 8; y: 8
					width: 96; height: 20
					focus: true
					text: "Text Input 1"
			}

			TextInput {
					id: input2
					x: 8; y: 36
					width: 96; height: 20
					text: "Text Input 2"
			}
	}

>

	// 用户可以通过点击TextInput来改变焦点。
	// 为了支持键盘改变焦点，我们可以使用KeyNavigation（按键向导）这个附加属性。
	// KeyNavigation（按键向导）附加属性可以预先设置一个元素id绑定切换焦点的按键。
	Rectangle {
			width: 200
			height: 80
			color: "linen"

			TextInput {
					id: input1
					x: 8; y: 8
					width: 96; height: 20
					focus: true
					text: "Text Input 1"
					KeyNavigation.tab: input2
			}

			TextInput {
					id: input2
					x: 8; y: 36
					width: 96; height: 20
					text: "Text Input 2"
					KeyNavigation.tab: input1
			}
	}

>

	// 一个文本输入元素（text input element）只显示一个闪烁符和已经输入的文本
	// TLineEditV1.qml
    Rectangle {
        width: 96; height: input.height + 8
        color: "lightsteelblue"
        border.color: "gray"

        property alias text: input.text
        // 如果你想要完整的导出TextInput元素
        // 你可以使用property alias input: input来导出这个元素
        // 第一个input是属性名字，第二个input是元素id。
        property alias input: input

        TextInput {
            id: input
            anchors.fill: parent
            anchors.margins: 4
            focus: true
        }
    }

        TLineEditV1 {
        height: 30
        text: "aa" // 导出 text
        input.text: "bbb" // 完整的导出 input
    }

>

    // 我们使用TLineEditV1组件重写了我们的KeyNavigation（按键向导）的例子。
    Rectangle {
        ...
        TLineEditV1 {
            id: input1
            ...
        }
        TLineEditV1 {
            id: input2
            ...
        }
    }

	// 尝试使用Tab按键来导航，你会发现焦点无法切换到input2上。
	// 这个例子中使用focus:true的方法不正确，这个问题是因为焦点被转移到input2元素时
	// 包含TlineEditV1的顶部元素接收了这个焦点并且没有将焦点转发给TextInput（文本输入）
	// 为了防止这个问题，QML提供了FocusScope（焦点区域）。

>

#### 焦点区域（FocusScope）

>

	一个焦点区域（focus scope）定义了如果焦点区域接收到焦点
	它的最后一个使用focus:true的子元素接收焦点
	它将会把焦点传递给最后申请焦点的子元素。
	我们创建了第二个版本的TLineEdit组件，称作TLineEditV2，使用焦点区域（focus scope）作为根元素。

	// FocusScope(焦点区域)
	FocusScope {
			width: 96; height: input.height + 8
			Rectangle {
					anchors.fill: parent
					color: "lightsteelblue"
					border.color: "gray"

			}

			property alias text: input.text
			property alias input: input

			TextInput {
					id: input
					anchors.fill: parent
					anchors.margins: 4
					focus: true
			}
	}

>

#### 文本编辑（TextEdit）

-

> 文本编辑（TextEdit）元素与文本输入（TextInput）非常类似，它支持多行文本编辑。

>

	// TTextEdit.qml

	import QtQuick 2.0

	FocusScope {
			width: 96; height: 96
			Rectangle {
					anchors.fill: parent
					color: "lightsteelblue"
					border.color: "gray"

			}

			property alias text: input.text
			property alias input: input

			TextEdit {
					id: input
					anchors.fill: parent
					anchors.margins: 4
					focus: true
			}
	}

	import QtQuick 2.0

	Rectangle {
			width: 136
			height: 120
			color: "linen"

			TTextEdit {
					id: input
					x: 8; y: 8
					width: 120; height: 104
					focus: true
					text: "Text Edit"
			}
	}

>

#### 按键元素（Key Element）

-

> 附加属性key允许你基于某个按键的点击来执行代码。

>

* 使用up，down按键来移动一个方块
* 使用left，right按键来旋转一个元素
* 使用plus，minus按键来缩放一个元素

>

	Window {
			visible: true
			width: 640
			height: 480
			title: qsTr("Hello World")

			Rectangle {

					width: 400; height: 200

					Rectangle {
							width: 38; height: 38
							color: "#ea7025"
							id: square
							x: 20; y: 20
					}
					focus: true
					Keys.onLeftPressed: square.x -= 8
					Keys.onRightPressed: square.x += 8
					Keys.onUpPressed: square.y -= 8
					Keys.onDownPressed: square.y += 8
					Keys.onPressed: {
							switch(event.key) {
							case Qt.Key_Plus:
									square.scale += 0.2
									break;
							case Qt.Key_Minus:
									square.scale -= 0.2
									break;
							}

					}
			}
	}

---

>

### 动画（Animations）

-

> 动画被用于属性的改变。一个动画定义了属性值改变的曲线，将一个属性值变化从一个值过渡到另一个值

> 所有在QtQuick中的动画都由同一个计时器来控制，因此它们始终都保持同步，这也提高了动画的性能和显示效果。

>

#### 动画元素（Animation Elements）

>

* PropertyAnimation（属性动画）- 使用属性值改变播放的动画
* NumberAnimation（数字动画）- 使用数字改变播放的动画
* ColorAnimation（颜色动画）- 使用颜色改变播放的动画
* RotationAnimation（旋转动画）- 使用旋转改变播放的动画

**QtQuick还提供了一切特殊场景下使用的动画**

* PauseAnimation（停止动画）- 运行暂停一个动画
* SequentialAnimation（顺序动画）- 允许动画有序播放
* ParallelAnimation（并行动画）- 允许动画同时播放
* AnchorAnimation（锚定动画）- 使用锚定改变播放的动画
* ParentAnimation（父元素动画）- 使用父对象改变播放的动画
* SmotthedAnimation（平滑动画）- 跟踪一个平滑值播放的动画
* SpringAnimation（弹簧动画）- 跟踪一个弹簧变换的值播放的动画
* PathAnimation（路径动画）- 跟踪一个元素对象的路径的动画
* Vector3dAnimation（3D容器动画）- 使用QVector3d值改变播放的动画

**当使用更加复杂的动画时，我们可能需要在播放一个动画时中改变一个属性或者运行一个脚本**

* PropertyAction（属性动作）- 在播放动画时改变属性
* ScriptAction（脚本动作）- 在播放动画时运行脚本

>

#### 应用动画（Applying Animations）

>

*动画可以通过以下几种方式来应用：*

* 属性动画 - 在元素完整加载后自动运行
* 属性动作 - 当属性值改变时自动运行
* 独立运行动画 - 使用start()函数明确指定运行或者running属性被设置为true（比如通过属性绑定）

>

    // ClickableImageV2.qml
    // 扩展可点击图像元素版本2（ClickableImage Version2）
    Item {
        id: root
        // 父几何对象依赖于子几何对象
        // 我们使用了Column（列）定位器
        // 并且使用基于列的子矩形（childRect）
        // 属性来计算它的宽度和高度（width and height）
        width: container.childrenRect.width
        height: container.childrenRect.height
        property alias text: label.text
        property alias source: image.source
        signal clicked

        Column {
            id: container
            Image {
                id: image
            }
            Text {
                id: label
                width: image.width
                horizontalAlignment: Text.AlignHCenter
                // 我们使用文本元素的wrapMode属性来设置文本与图像一样宽并且可以自动换行
                wrapMode: Text.WordWrap
                color: "#111111"
            }
        }

        MouseArea {
            anchors.fill: parent
            onClicked: root.clicked()
        }
    }

>

    // 同时向上移动 ...

    ClickableImageV2 {
         id: rocket1
         x: 40; y: 200
         source: "rocket.png"
         text: "animation on property"
         NumberAnimation on y {
             to: 40; duration: 4000
         }
     }

    ClickableImageV2 {
         id: rocket2
         x: 40 + 170; y: 200
         source: "rocket.png"
         text: "animation on property"
         NumberAnimation on y {
             to: 40; duration: 4000
         }
     }

    ClickableImageV2 {
         id: rocket3
         x: 40 + 170 + 170; y: 200
         source: "rocket.png"
         text: "animation on property"
         NumberAnimation on y {
             to: 40; duration: 4000
         }
     }
     
>
    
    // Behavior
    ClickableImageV2 {
        id: rocket2
        x: 152; y: 200
        source: "rocket.png"
        text: "behavior on property"
        // Behavior 定义了特定的属性变化时的默认动画。
        // 此处：当 y 发生变化时触发 ... 动画
        Behavior on y {
            NumberAnimation { duration: 4000 }
        }
        // 点击则 y = 40 ... 触发动画
        onClicked: y = 40
        // 随机 y 值 ...
        // onClicked: y = 40+Math.random()*(205-40)
    }   

>

    // standalone animation
    ClickableImageV2 {
        id: rocket3
        x: 264; y: 200
        source: "rocket.png"
        onClicked: anim.start()
        // onClicked: anim.restart()

        text: "standalone animation"

        // 每一个动画都有start()，stop()，resume()，restart()函数
        // 这个动画由一个私有的元素定义
        // 并且可以写在文档的任何地方
        NumberAnimation {
            id: anim
            target: rocket3
            properties: "y"
            from: 205 // 定义了一个from属性的值允许动画可以重复运行
            to: 40
            duration: 4000
        }
    }

>

    Image {
        id: rocket3
        x: 264; y: 200
        source: "rocket.png"

        // 每一个动画都有start()，stop()，resume()，restart()函数
        // 这个动画由一个私有的元素定义
        // 并且可以写在文档的任何地方
        NumberAnimation {
            id: anim
            target: rocket3
            properties: "y"
            from: 205 // 定义了一个from属性的值允许动画可以重复运行
            to: 40
            duration: 4000
            running: area.pressed // 鼠标长按 ...
        }

        /*
            canceled()
            clicked(MouseEvent  mouse)
            doubleClicked(MouseEvent  mouse)
            entered()
            exited()
            positionChanged(MouseEvent  mouse)
            pressAndHold(MouseEvent  mouse)
            pressed(MouseEvent  mouse)
            released(MouseEvent  mouse)
            wheel(MouseEvent  mouse)
        */
        MouseArea {
            anchors.fill: parent
            id: area
        }

    }
    
>

#### 缓冲曲线（Easing Curves）

>

    // 扩展可点击图像V3（ClickableImage V3）
    // ClickableImageV3.qml
    // Simple image which can be clicked

    import QtQuick 2.0

    Item {
        id: root
        width: container.childrenRect.width + 16
        height: container.childrenRect.height + 16
        property alias text: label.text
        property alias source: image.source
        signal clicked

        // M1>>
        // ... add a framed rectangle as container
        property bool framed : false

        Rectangle {
            anchors.fill: parent
            color: "white"
            visible: root.framed
        }
    }

    /*
        这个例子的代码非常简洁。
        我们使用了一连串的缓冲曲线的名称（property variant easings）
        并且在一个Repeater（重复元素）中将它们分配给一个ClickableImage。
        图片的源路径通过一个命名方案来定义，一个叫做“InQuad”的缓冲曲线在“curves/InQuad.png”中有一个对应的图片。
        如果你点击一个曲线图，这个点击将会分配一个缓冲类型给动画然后重新启动动画。
        动画自身是用来设置方块的x坐标属性在2秒内变化的独立动画。
    */
    
    // easingtypes.qml

    import QtQuick 2.0

    DarkSquare {
        id: root
        width: 600
        height: 340

        // A list of easing types
        property variant easings : [
            "Linear", "InQuad", "OutQuad", "InOutQuad",
            "InCubic", "InSine", "InCirc", "InElastic",
            "InBack", "InBounce" ]


        Grid {
            id: container
            anchors.top: parent.top
            anchors.horizontalCenter: parent.horizontalCenter
            anchors.margins: 16
            height: 200
            columns: 5
            spacing: 16
            // iterates over the 'easings' list
            Repeater {
                model: easings
                ClickableImageV3 {
                    framed: true
                    // the current data entry from 'easings' list
                    text: modelData
                    source: "curves/" + modelData + ".png"
                    onClicked: {
                        // set the easing type on the animation
                        anim.easing.type = modelData
                        // restart the animation
                        anim.restart()
                    }
                }
            }
        }

        // The square to be animated
        GreenSquare {
            id: square
            x: 40; y: 260
        }

        // The animation to test the easing types
        NumberAnimation {
            id: anim
            target: square
            from: 40; to: root.width - 40 - square.width
            properties: "x"
            duration: 2000
        }
    }
    
    /*
        除了duration属性与easing.type属性，你也可以对动画进行微调。
        例如PropertyAnimation属性，大多数动画都支持附加的
            easing.amplitude（缓冲振幅），easing.overshoot（缓冲溢出），easing.period（缓冲周期）
            这些属性允许你对个别的缓冲曲线进行微调。不是所有的缓冲曲线都支持这些参数。
        可以查看Qt PropertyAnimation文档中的缓冲列表（easing table）来查看一个缓冲曲线的相关参数。
    */
    
>

#### 动画分组（Grouped Animations）

>

    /*
        通常使用的动画比一个属性的动画更加复杂。
        例如你想同时运行几个动画并把他们连接起来，或者在一个一个的运行，或者在两个动画之间执行一个脚本。
        动画分组提供了很好的帮助，作为命名建议可以叫做一组动画。
        有两种方法来分组：平行与连续。
        你可以使用SequentialAnimation（连续动画）和ParallelAnimation（平行动画）来实现它们
        它们作为动画的容器来包含其它的动画元素。
    */

    // ClickableImageV3.qml 
    Item {
        id: root
        width: container.childrenRect.width
        height: container.childrenRect.height

        property alias text: label.text
        property alias source: image.source
        signal clicked

        Column {
            id: container
            Image {
                id: image
            }
            Text {
                id: label
                width: image.width
                horizontalAlignment: Text.AlignHCenter
                // 我们使用文本元素的wrapMode属性来设置文本与图像一样宽并且可以自动换行
                wrapMode: Text.WordWrap
                color: "#111111"
            }
        }

        property bool framed : false

        Rectangle {
            anchors.fill: parent
            color: "white"
            visible: root.framed
        }

        MouseArea {
            anchors.fill: parent
            onClicked: root.clicked()
        }
    }
    
>

    // 动画组合 ...
	// 分组动画也可以被嵌套，例如一个连续动画可以拥有两个平行动画作为子动画
    // ParallelAnimation 平行动画
    Rectangle {
        id: root
        width: 300
        height: 200
        property int duration: 3000

        ClickableImageV3 {
            id: rocket
            x: 20; y: 120
            source: "rocket.png"
            onClicked: anim.restart()
        }

        // ParallelAnimation 平行动画
        ParallelAnimation {
            id: anim
            // 这个动画改变的是y值
            NumberAnimation {
                target: rocket
                properties: "y"
                to: 20
                duration: root.duration
            }
            // 这个动画改变的是x值
            NumberAnimation {
                target: rocket
                properties: "x"
                to: 160
                duration: root.duration
            }
        }
    }
    
>

    // 动画组合 ..
	// 分组动画也可以被嵌套，例如一个连续动画可以拥有两个平行动画作为子动画
    // SequentialAnimation（连续动画）
    Rectangle {
        id: root
        width: 300
        height: 200
        property int duration: 3000

        ClickableImageV3 {
            id: rocket
            x: 20; y: 120
            source: "rocket.png"
            onClicked: anim.restart()
        }

        // 先执行Y移动，后执行X移动
        SequentialAnimation {
            id: anim
            NumberAnimation {
                target: rocket
                properties: "y"
                to: 20
                // 60% of time to travel up
                duration: root.duration*0.6
            }
            NumberAnimation {
                target: rocket
                properties: "x"
                to: 160
                // 40% of time to travel sideways
                duration: root.duration*0.4
            }
        }
    }

>

	// 最终组合动画
    Item {
        id: root
        width: 480
        height: 300
        property int duration: 3000

        Image {
              id: ball
              x: 20; y: 240
              source: "rocket.png"

              MouseArea {
                  anchors.fill: parent
                  onClicked: {
                      ball.x = 20; ball.y = 240
                      anim.restart()
                  }
              }
          }

        ParallelAnimation {
            id: anim
            SequentialAnimation {
                NumberAnimation {
                    target: ball
                    properties: "y"
                    to: 20
                    duration: root.duration * 0.4
                    easing.type: Easing.OutCirc
                }
                NumberAnimation {
                    target: ball
                    properties: "y"
                    to: 240
                    duration: root.duration * 0.6
                    easing.type: Easing.OutBounce
                }
            }
            NumberAnimation {
                target: ball
                properties: "x"
                to: 400
                duration: root.duration
            }
            RotationAnimation {
                target: ball
                properties: "rotation"
                to: 720
                duration: root.duration * 1.1
            }
        }
    }
	
>

	// 组合动画学习 ...
    /*
          ListElement { name: "Easing.Linear"; type: Easing.Linear; ballColor: "DarkRed" }
          ListElement { name: "Easing.InQuad"; type: Easing.InQuad; ballColor: "IndianRed" }
          ListElement { name: "Easing.OutQuad"; type: Easing.OutQuad; ballColor: "Salmon" }
          ListElement { name: "Easing.InOutQuad"; type: Easing.InOutQuad; ballColor: "Tomato" }
          ListElement { name: "Easing.OutInQuad"; type: Easing.OutInQuad; ballColor: "DarkOrange" }
          ListElement { name: "Easing.InCubic"; type: Easing.InCubic; ballColor: "Gold" }
          ListElement { name: "Easing.OutCubic"; type: Easing.OutCubic; ballColor: "Yellow" }
          ListElement { name: "Easing.InOutCubic"; type: Easing.InOutCubic; ballColor: "PeachPuff" }
          ListElement { name: "Easing.OutInCubic"; type: Easing.OutInCubic; ballColor: "Thistle" }
          ListElement { name: "Easing.InQuart"; type: Easing.InQuart; ballColor: "Orchid" }
          ListElement { name: "Easing.OutQuart"; type: Easing.OutQuart; ballColor: "Purple" }
          ListElement { name: "Easing.InOutQuart"; type: Easing.InOutQuart; ballColor: "SlateBlue" }
          ListElement { name: "Easing.OutInQuart"; type: Easing.OutInQuart; ballColor: "Chartreuse" }
          ListElement { name: "Easing.InQuint"; type: Easing.InQuint; ballColor: "LimeGreen" }
          ListElement { name: "Easing.OutQuint"; type: Easing.OutQuint; ballColor: "SeaGreen" }
          ListElement { name: "Easing.InOutQuint"; type: Easing.InOutQuint; ballColor: "DarkGreen" }
          ListElement { name: "Easing.OutInQuint"; type: Easing.OutInQuint; ballColor: "Olive" }
          ListElement { name: "Easing.InSine"; type: Easing.InSine; ballColor: "DarkSeaGreen" }
          ListElement { name: "Easing.OutSine"; type: Easing.OutSine; ballColor: "Teal" }
          ListElement { name: "Easing.InOutSine"; type: Easing.InOutSine; ballColor: "Turquoise" }
          ListElement { name: "Easing.OutInSine"; type: Easing.OutInSine; ballColor: "SteelBlue" }
          ListElement { name: "Easing.InExpo"; type: Easing.InExpo; ballColor: "SkyBlue" }
          ListElement { name: "Easing.OutExpo"; type: Easing.OutExpo; ballColor: "RoyalBlue" }
          ListElement { name: "Easing.InOutExpo"; type: Easing.InOutExpo; ballColor: "MediumBlue" }
          ListElement { name: "Easing.OutInExpo"; type: Easing.OutInExpo; ballColor: "MidnightBlue" }
          ListElement { name: "Easing.InCirc"; type: Easing.InCirc; ballColor: "CornSilk" }
          ListElement { name: "Easing.OutCirc"; type: Easing.OutCirc; ballColor: "Bisque" }
          ListElement { name: "Easing.InOutCirc"; type: Easing.InOutCirc; ballColor: "RosyBrown" }
          ListElement { name: "Easing.OutInCirc"; type: Easing.OutInCirc; ballColor: "SandyBrown" }
          ListElement { name: "Easing.InElastic"; type: Easing.InElastic; ballColor: "DarkGoldenRod" }
          ListElement { name: "Easing.OutElastic"; type: Easing.OutElastic; ballColor: "Chocolate" }
          ListElement { name: "Easing.InOutElastic"; type: Easing.InOutElastic; ballColor: "SaddleBrown" }
          ListElement { name: "Easing.OutInElastic"; type: Easing.OutInElastic; ballColor: "Brown" }
          ListElement { name: "Easing.InBack"; type: Easing.InBack; ballColor: "Maroon" }
          ListElement { name: "Easing.OutBack"; type: Easing.OutBack; ballColor: "LavenderBlush" }
          ListElement { name: "Easing.InOutBack"; type: Easing.InOutBack; ballColor: "MistyRose" }
          ListElement { name: "Easing.OutInBack"; type: Easing.OutInBack; ballColor: "Gainsboro" }
          ListElement { name: "Easing.OutBounce"; type: Easing.OutBounce; ballColor: "Silver" }
          ListElement { name: "Easing.InBounce"; type: Easing.InBounce; ballColor: "DimGray" }
          ListElement { name: "Easing.InOutBounce"; type: Easing.InOutBounce; ballColor: "SlateGray" }
          ListElement { name: "Easing.OutInBounce"; type: Easing.OutInBounce; ballColor: "DarkSlateGray" }
          ListElement { name: "Easing.Bezier"; type: Easing.Bezier; ballColor: "Chartreuse"; }
      */
    Item {
        id: root
        width: 480
        height: 300
        property int duration: 3000

        Image {
              id: ball
              x: 20; y: 240
              source: "rocket.png"

              MouseArea {
                  anchors.fill: parent
                  // 点击开始动画 ...
                  onClicked: {
                      ball.x = 20; ball.y = 240
                      anim.restart()
                  }
              }
          }

        // 平行动画
        // 平行元素的所有子动画都会平行运行，它允许你在同一时间使用不同的属性来播放动画。
        ParallelAnimation {
            id: anim
            // 同时：1, 连续动画(允许动画有序播放)
            SequentialAnimation {
                // 先改动 y 值
                NumberAnimation {
                    target: ball // target 目标
                    properties: "y"
                    to: 20
                    duration: root.duration * 0.4
                    // Easing曲线定义动画如何在起始值和终止值见产生插值.
                    // 不同的easing曲线定义了一系列的插值.
                    // easing曲线简化了创建动画的效果--如弹跳效果, 加速, 减速, 和周期动画.
                    // Easing.OutCirc缓冲曲线，它看起来更像是一个圆周运动
                    easing.type: Easing.OutCirc
                }
                // 后改动 y 值
                NumberAnimation {
                    target: ball // target 目标
                    properties: "y"
                    to: 240
                    duration: root.duration * 0.6
                    // Easing曲线定义动画如何在起始值和终止值见产生插值.
                    // 不同的easing曲线定义了一系列的插值.
                    // easing曲线简化了创建动画的效果--如弹跳效果, 加速, 减速, 和周期动画.
                    // Easing.OutBounce缓冲曲线，因为在最后球会发生反弹
                    easing.type: Easing.OutBounce
                }
            }
            // 同时：2, 改动 x 值
            NumberAnimation {
                target: ball
                properties: "x"
                to: 400 // x 移动到 400
                duration: root.duration // 移动时间/速度
            }
            // 同时：3, 旋转动画- 使用旋转改变播放的动画
            RotationAnimation {
                target: ball
                properties: "rotation"
                to: 720 // 旋转角度
                from: 0 // 循环 ...
                duration: root.duration * 1.1 // 旋转时间/速度
            }
        }
    }

>


---

> Qt 发布了 Qt Quick 的一个全新模块：Qt Quick Controls 这个模块提供了大量类似 Qt Widgets 模块那样可重用的组件

