<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>NLJB</title>
    <link>http://www.nljb.net</link>
    <pubDate>18 Jul 14 16:29 CST</pubDate>
    <item>
      <title>Libev-初识</title>
      <link>http://www.nljb.net/default/Libev-%E5%88%9D%E8%AF%86/</link>
      <pubDate>2014-07-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Libev是一个event loop：事件驱动的库。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;通过向libev注册感兴趣的events，比如socket可读事件&#xA;libev会对所注册的事件的源进行管理并在事件发生时触发相应的回调函数。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;通过event watcher来注册事件。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;libev通过分配和注册watcher对不同类型的事件进行监听。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;不同事件类型的watcher又对应不同的数据类型&#xA;watcher的定义模式是struct ev_TYPE或者ev_TYPE，其中TYPE为具体的类型。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;当前libev定义了如下类型的watcher：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ev_io&#xA;ev_timer&#xA;ev_periodic&#xA;ev_signal&#xA;ev_child&#xA;ev_stat&#xA;ev_idle&#xA;ev_prepare and ev_check&#xA;ev_embed&#xA;ev_fork&#xA;ev_cleanup&#xA;ev_async&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;ev_init对一个watcher的与具体类型无关的部分进行初始化。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ev_io_set对watcher的与io类型相关的部分进行初始化，如果是TYPE类型那么相应的函数就是ev_TYPE_set。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以采用ev_TYPE_init函数来替代ev_init和ev_TYPE_set。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ev_io_start激活相应的watcher&lt;/p&gt;&#xA;&#xA;&lt;p&gt;watcher只有被激活的时候才能接收事件。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ev_io_stop停止已经激活的watcher。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ev_run、ev_break以及ev_loop_default都是event loop控制函数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;event loop定义为struct ev_loop。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有两种类型的event loop，分别是default类型和dynamically created类型，区别是前者支持子进程事件。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ev_default_loop和ev_loop_new函数分别用于创建default类型或者dynamically created类型的event loop。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;event_run函数告诉系统应用程序开始对事件进行处理，有事件发生时就调用watcher callbacks。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;除非调用了ev_break或者不再有active的watcher，否则会一直重复这个过程。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;struct　ev_loop　*ev_default_loop　(unsigned　int　flags)　&#xA;struct　ev_loop　*ev_loop_new　(unsigned　int　flags)　&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;默认初始化一个loop，区别是第一个不是线程安全的，第二个不能捕捉信号和子进程的watcher。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;参数flags可以为下面几种类型：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#define EVFLAG_AUTO　　　　0x00000000U /* not quite a mask */ &#xA;/* flag bits */ &#xA;#define EVFLAG_NOENV　　　 0x01000000U /* do NOT consult environment */ &#xA;#define EVFLAG_FORKCHECK　 0x02000000U /* check for a fork in each iteration */ &#xA;/* method bits to be ored together */ &#xA;#define EVBACKEND_SELECT　 0x00000001U /* about anywhere */ &#xA;#define EVBACKEND_POLL　　　 0x00000002U /* !win */ &#xA;#define EVBACKEND_EPOLL　　  0x00000004U /* linux */ &#xA;#define EVBACKEND_KQUEUE　   0x00000008U /* bsd */ &#xA;#define EVBACKEND_DEVPOLL    0x00000010U /* solaris 8 */ /* NYI */ &#xA;#define EVBACKEND_PORT　　　 0x00000020U /* solaris 10 */&#xA;&#xA;ev_default_fork　()　&#xA;ev_loop_fork　(loop)&#xA;// 当你在子进程里需要使用libev的函数的之前必须要调用。&#xA;// 区别是第二个函数是当使用ev_loop_new创建的loop时，才用第二个函数,也就是说重用父进程创建的loop。&#xA;&#xA;ev_loop　(loop,　int　flags)&#xA;// 开始事件循环。&#xA;&#xA;ev_TYPE_init　(ev_TYPE　*watcher,　callback,　[args])&#xA;// 初始化一个watcher。TYPE也就是libev支持的事件类型，比如io，比如time。&#xA;&#xA;// 第一个参数为一个watcher,第二个回调函数，第三个句柄，第四个事件类型。包含下面几种：&#xA;#define EV_UNDEF　　　　　　　　　　　 -1 /* guaranteed to be invalid */ &#xA;#define EV_NONE　　　　　　　　　　 0x00 /* no events */ &#xA;#define EV_READ　　　　　　　　　　 0x01 /* ev_io detected read will not block */ &#xA;#define EV_WRITE　　　　　　　　　 0x02 /* ev_io detected write will not block */ &#xA;#define EV_IOFDSET　　　　　　　 0x80 /* internal use only */ &#xA;#define EV_TIMEOUT　     0x00000100 /* timer timed out */ &#xA;#define EV_PERIODIC     0x00000200 /* periodic timer timed out */ &#xA;#define EV_SIGNAL　　     0x00000400 /* signal was received */ &#xA;#define EV_CHILD　　　     0x00000800 /* child/pid had status change */ &#xA;#define EV_STAT　　　　 0x00001000 /* stat data changed */ &#xA;#define EV_IDLE　　　　 0x00002000 /* event loop is idling */ &#xA;#define EV_PREPARE　 0x00004000 /* event loop about to poll */ &#xA;#define EV_CHECK　　　     0x00008000 /* event loop finished poll */ &#xA;#define EV_EMBED　　　     0x00010000 /* embedded event loop needs sweep */ &#xA;#define EV_FORK　　　　 0x00020000 /* event loop resumed in child */ &#xA;#define EV_ASYNC　　　     0x00040000 /* async intra-loop signal */ &#xA;#define EV_ERROR　　　     0x80000000 /* sent when an error occurs */&#xA;&#xA;ev_TYPE_start (loop *, ev_TYPE *watcher)&#xA;// 启动一个watcher。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include　&amp;lt;ev.h&amp;gt;　&#xA;#include　&amp;lt;stdio.h&amp;gt;　&#xA;　　&#xA;　　//不同的watcher　&#xA;　　ev_io　stdin_watcher;　&#xA;　　ev_timer　timeout_watcher;　&#xA;　　ev_timer　timeout_watcher_child;　&#xA;　　　&#xA;　　//标准输入的回调函数　&#xA;　　static　void　&#xA;　　stdin_cb　(EV_P_　ev_io　*w,　int　revents)　&#xA;　　{　&#xA;　　　puts　(&amp;quot;stdin　ready&amp;quot;);　&#xA;　　　ev_io_stop　(EV_A_　w);　&#xA;　　　ev_unloop　(EV_A_　EVUNLOOP_ALL);　&#xA;　　}　&#xA;　　&#xA;　　//父进程的定时器回调函数　&#xA;　　static　void　&#xA;　　timeout_cb　(EV_P_　ev_timer　*w,　int　revents)　&#xA;　　{　&#xA;　　　puts　(&amp;quot;timeout&amp;quot;);　&#xA;　　　ev_unloop　(EV_A_　EVUNLOOP_ONE);　&#xA;　　}　&#xA;　　//子进程的定时器回调函数　&#xA;　　static　void　&#xA;　　timeout_cb_child　(EV_P_　ev_timer　*w,　int　revents)　&#xA;　　{　&#xA;　　　puts　(&amp;quot;child　timeout&amp;quot;);　&#xA;　　　ev_unloop　(EV_A_　EVUNLOOP_ONE);　&#xA;　　}　&#xA;&#xA;int　main　(void)　&#xA;{　&#xA;　　//创建一个backend为select的loop　&#xA;　　struct　ev_loop　*loop　=　ev_loop_new(EVBACKEND_SELECT);　&#xA;　　　&#xA;　　　//初始化并启动父进程的watcher　&#xA;　　ev_timer_init(&amp;amp;timeout_watcher,　timeout_cb,　10,　0.);　&#xA;　　ev_timer_start(loop,　&amp;amp;timeout_watcher);　&#xA;　　switch　(fork())　{　&#xA;　　　　　　　　case　-1:　&#xA;　　　　　　　　　　return　-1;　&#xA;　　　　　　　　case　0:　&#xA;　　　　　　　　　//使用父进程loop。　&#xA;　　　　　　　　　　ev_loop_fork(loop);　&#xA;　　　　　　　　　　//子进程的loop　&#xA;　　　　　　　　　　struct　ev_loop　*loop_child　=　ev_loop_new　(EVBACKEND_SELECT);　&#xA;　　　　　　　　　　ev_io_init　(&amp;amp;stdin_watcher,　stdin_cb,　/*STDIN_FILENO*/　0,　EV_READ);　&#xA;　　　　　　　　　　ev_io_start　(loop,　&amp;amp;stdin_watcher);　&#xA;　　　　　　　　　　ev_timer_init(&amp;amp;timeout_watcher_child,　timeout_cb_child,　5.5,　0.);　&#xA;　　　　　　　　　　ev_timer_start(loop_child,　&amp;amp;timeout_watcher_child);　&#xA;　　　　　　　　　　ev_loop(loop_child,0);　&#xA;　　　}　&#xA;　　　&#xA;　　　//等待事件　&#xA;　　　ev_loop　(loop,　0);　&#xA;　　　return　0;　&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>udev-mount-umount</title>
      <link>http://www.nljb.net/default/udev-mount-umount/</link>
      <pubDate>2014-07-15 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;ACTION==&amp;quot;add|change&amp;quot;, SUBSYSTEM==&amp;quot;block&amp;quot;, BUS==&amp;quot;usb&amp;quot;, KERNEL==&amp;quot;sd[a-z][0-9]&amp;quot;, RUN+=&amp;quot;/danoo/bin/addusb.sh %k&amp;quot;&#xA;ACTION==&amp;quot;remove&amp;quot;, SUBSYSTEM==&amp;quot;block&amp;quot;, BUS==&amp;quot;usb&amp;quot;, RUN+=&amp;quot;/danoo/bin/removeusb.sh&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Xorg</title>
      <link>http://www.nljb.net/default/Xorg/</link>
      <pubDate>2014-07-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Xorg 配置备份 针对 Nvidia 显卡  &amp;hellip;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# nvidia-xconfig: X configuration file generated by nvidia-xconfig&#xA;# nvidia-xconfig:  version 260.19.44  (buildmeister@swio-display-x86-rhel47-04.nvidia.com)  Sun Feb 27 21:50:39 PST 2011&#xA;&#xA;Section &amp;quot;ServerLayout&amp;quot;&#xA;    InputDevice &amp;quot;irtouch&amp;quot; &amp;quot;SendCoreEvents&amp;quot;&#xA;    Identifier     &amp;quot;Layout0&amp;quot;&#xA;    Screen      0  &amp;quot;Screen0&amp;quot;&#xA;    InputDevice    &amp;quot;Keyboard0&amp;quot; &amp;quot;CoreKeyboard&amp;quot;&#xA;    InputDevice    &amp;quot;Mouse0&amp;quot; &amp;quot;CorePointer&amp;quot;&#xA;EndSection&#xA;&#xA;Section &amp;quot;Files&amp;quot;&#xA;EndSection&#xA;&#xA;Section &amp;quot;InputDevice&amp;quot;&#xA;    # generated from default&#xA;    Identifier     &amp;quot;Mouse0&amp;quot;&#xA;    Driver         &amp;quot;mouse&amp;quot;&#xA;    Option         &amp;quot;Protocol&amp;quot; &amp;quot;auto&amp;quot;&#xA;    Option         &amp;quot;Device&amp;quot; &amp;quot;/dev/psaux&amp;quot;&#xA;    Option         &amp;quot;Emulate3Buttons&amp;quot; &amp;quot;no&amp;quot;&#xA;    Option         &amp;quot;ZAxisMapping&amp;quot; &amp;quot;4 5&amp;quot;&#xA;EndSection&#xA;&#xA;Section &amp;quot;InputDevice&amp;quot;&#xA;    # generated from default&#xA;    Identifier     &amp;quot;Keyboard0&amp;quot;&#xA;    Driver         &amp;quot;kbd&amp;quot;&#xA;EndSection&#xA;&#xA;Section &amp;quot;Monitor&amp;quot;&#xA;    Identifier     &amp;quot;Monitor0&amp;quot;&#xA;    VendorName     &amp;quot;Unknown&amp;quot;&#xA;    ModelName      &amp;quot;Unknown&amp;quot;&#xA;#   HorizSync       28.0 - 33.0&#xA;#   VertRefresh     43.0 - 72.0&#xA;    Option         &amp;quot;DPMS&amp;quot;&#xA;    Modeline &amp;quot;2560x1080_40.00&amp;quot; 147.10  2560 2680 2944 3328  1080 1081 1084 1105 -HSync +Vsync&#xA;    Modeline &amp;quot;2560x1080_50.00&amp;quot;  188.75  2560 2712 2976 3392  1080 1083 1093 1114 -hsync +vsync&#xA;    Modeline &amp;quot;2560x1080_60.00&amp;quot;  230.00  2560 2720 2992 3424  1080 1083 1093 1120 -hsync +vsync&#xA;    Modeline &amp;quot;2560x1080_45.00&amp;quot;  167.75  2560 2696 2960 3360  1080 1083 1093 1111 -hsync +vsync&#xA;&#xA;EndSection&#xA;&#xA;Section &amp;quot;Device&amp;quot;&#xA;#-&amp;gt; rotate label start -&amp;gt; Do not move&#xA;#    Option         &amp;quot;Rotate&amp;quot; &amp;quot;CW&amp;quot;&#xA;#-&amp;gt; rotate label end -&amp;gt; Do not move&#xA;    Identifier     &amp;quot;Device0&amp;quot;&#xA;    Driver         &amp;quot;nvidia&amp;quot;&#xA;    VendorName     &amp;quot;NVIDIA Corporation&amp;quot;&#xA;    Option         &amp;quot;UseEDIDFreqs&amp;quot; &amp;quot;False&amp;quot;&#xA;    Option         &amp;quot;ExactModeTimingsDVI&amp;quot; &amp;quot;True&amp;quot;&#xA;    Option         &amp;quot;ModeValidation&amp;quot; &amp;quot;NoDFPNativeResolutionCheck&amp;quot;&#xA;    Option         &amp;quot;FlatPanelProperties&amp;quot; &amp;quot;Scaling=Native&amp;quot;&#xA;EndSection&#xA;&#xA;Section &amp;quot;Screen&amp;quot;&#xA;      Identifier     &amp;quot;Screen0&amp;quot;&#xA;      Device         &amp;quot;Device0&amp;quot;&#xA;      Monitor        &amp;quot;Monitor0&amp;quot;&#xA;      Option         &amp;quot;TwinView&amp;quot; &amp;quot;1&amp;quot;&#xA;      Option         &amp;quot;TwinViewXineramaInfoOrder&amp;quot; &amp;quot;DFP-1,DFP-2&amp;quot;&#xA;      Option         &amp;quot;metamodes&amp;quot; &amp;quot;DFP-1: 2560x1080_40.00 +0+1080, DFP-2: 2560X1080_40.00 +0+0&amp;quot;&#xA;      SubSection     &amp;quot;Display&amp;quot;&#xA;      Depth     24&#xA;      EndSubSection&#xA;EndSection&#xA;&#xA;### Touch Configuration Beginning ###&#xA;Section &amp;quot;InputDevice&amp;quot;&#xA;    Identifier &amp;quot;irtouch&amp;quot;&#xA;    Driver &amp;quot;irtouch&amp;quot;&#xA;    Option &amp;quot;ScrenNumber&amp;quot; &amp;quot;0&amp;quot;&#xA;    Option &amp;quot;SendCoreEvents&amp;quot;&#xA;    Option &amp;quot;MinX&amp;quot; &amp;quot;0&amp;quot;&#xA;    Option &amp;quot;MinY&amp;quot; &amp;quot;0&amp;quot;&#xA;    Option &amp;quot;MaxX&amp;quot; &amp;quot;4095&amp;quot;&#xA;    Option &amp;quot;MaxY&amp;quot; &amp;quot;4095&amp;quot;&#xA;    Option &amp;quot;SwapXY&amp;quot; &amp;quot;0&amp;quot;&#xA;EndSection&#xA;### Touch Configuration End ##&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-文件操作</title>
      <link>http://www.nljb.net/default/Golang-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>2014-07-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Go语言，在Package io中，定义了io.Reader和io.Writer两个interface&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Go以组合、委派等面向对象的方式，让其它的对象定义具体的实现&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果对一个文件每次读取一行(Readline)的话，就可以使用bufio.ReadString来实现，下边是一个简单的例子：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;////////////////////////////////源代码////////////////////////////////&#xA;package main&#xA;&#xA;import (&#xA;   &amp;quot;os&amp;quot;&#xA;   &amp;quot;bufio&amp;quot;&#xA;   &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;func main(){   &#xA;    //打开文件，并进行相关处理&#xA;   f , err := os.Open(&amp;quot;test.txt&amp;quot;,os.O_RDONLY,0)&#xA;   if err != nil{&#xA;       fmt.Printf(&amp;quot;%v\n&amp;quot;,err)&#xA;       os.Exit(1)&#xA;   }&#xA;   //文件关闭&#xA;   defer f.Close() &#xA;&#xA;    //将文件作为一个io.Reader对象进行buffered I/O操作&#xA;   br := bufio.NewReader(f)&#xA;   for{&#xA;       //每次读取一行&#xA;       line , err := br.ReadString(&#39;\n&#39;)&#xA;       if err == os.EOF {&#xA;       break&#xA;       }else{&#xA;       fmt.Printf(&amp;quot;%v&amp;quot;,line)&#xA;       }&#xA;   }&#xA;}&#xA;////////////////////////////////源代码////////////////////////////////&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;两个包具有文件操作的相关方法，一个是os,一个是syscall,其中os中的相关方法是对syscall相关方法的封装，推荐使用os中的相关方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;文件的打开文件的第一步操作实际上是创建，但是由于文件的打开方法也可以创建，实际中使用创建方法的地方不多。文件打开有两个方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//以只读方式打开一个存在的文件，打开就可以读取了。&#xA;func Open(name string) (file *File, err error)&#xA;&#xA;//以各种方式打开各种存在不存在的文件，具体怎么样看flag和perm。&#xA;func OpenFile(name string, flag int, perm FileMode) (file *File, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;flag可选值（掩码）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;const (&#xA;    O_RDONLY int = syscall.O_RDONLY // open the file read-only.&#xA;    O_WRONLY int = syscall.O_WRONLY // open the file write-only.&#xA;    O_RDWR   int = syscall.O_RDWR   // open the file read-write.&#xA;    O_APPEND int = syscall.O_APPEND // 在文件末尾追加，打开后cursor在文件结尾位置&#xA;    O_CREATE int = syscall.O_CREAT  // 如果不存在则创建&#xA;    O_EXCL   int = syscall.O_EXCL   //与O_CREATE一起用，构成一个新建文件的功能，它要求文件必须不存在&#xA;    O_SYNC   int = syscall.O_SYNC   // 同步方式打开，没有缓存，这样写入内容直接写入硬盘，系统掉电文件内容有一定保证&#xA;    O_TRUNC  int = syscall.O_TRUNC  // 打开并清空文件&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;perm是文件的unix权限位，可以直接用数字写，如0644。可选值有：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;const (&#xA;    // The single letters are the abbreviations&#xA;    // used by the String method&#39;s formatting.&#xA;    ModeDir        FileMode = 1 &amp;lt;&amp;lt; (32 - 1 - iota) // d: is a directory&#xA;    ModeAppend                                     // a: append-only&#xA;    ModeExclusive                                  // l: exclusive use&#xA;    ModeTemporary                                  // T: temporary file (not backed up)&#xA;    ModeSymlink                                    // L: symbolic link&#xA;    ModeDevice                                     // D: device file&#xA;    ModeNamedPipe                                  // p: named pipe (FIFO)&#xA;    ModeSocket                                     // S: Unix domain socket&#xA;    ModeSetuid                                     // u: setuid&#xA;    ModeSetgid                                     // g: setgid&#xA;    ModeCharDevice                                 // c: Unix character device, when ModeDevice is set&#xA;    ModeSticky&#xA;&#xA;    // Mask for the type bits. For regular files, none will be set.&#xA;    ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice&#xA;&#xA;    ModePerm FileMode = 0777 // permission bits&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上述可选值是权限位的高有效位，低有效位的值还是要用户自己写数字。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;文件的写入&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (f *File) Write(b []byte) (n int, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;// 该函数写入len(b)个字节。如果返回值值n!=len(b)，则表明没写进去，err将!=nil。&#xA;// 可能有人会疑惑，write函数为什么不指定写入的个数呢？C语言的对应函数就是指定的。&#xA;// 其实go不一样啦，因为go有slice，如果你想写入8个字节，你可以Write(b)。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (f *File) WriteAt(b []byte, off int64) (n int, err error) //WriteAt实际上是省略了seek的步骤。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;示例代码（该代码只写入http)：package main&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import (&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    fd,_:=os.OpenFile(&amp;quot;a.txt&amp;quot;,os.O_RDWR|os.O_CREATE,0644)&#xA;    buf:=[]byte(&amp;quot;http://www.usr.cc&amp;quot;)&#xA;    fd.Write(buf)&#xA;    fd.Close()&#xA;}&#xA;&#xA;// 从光标的当前位置开始读len(b)个字节，返回值n是实际上读到的字节数。&#xA;// 读取操作可能遇到EOF而停止，此时计数n为０，err为io.EOF.&#xA;文件的读取func (f *File) Read(b []byte) (n int, err error)&#xA;&#xA;// 这个不多说了。&#xA;func (f *File) ReadAt(b []byte, off int64) (n int, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;下面的示例代码写入http://www.usr.cc，读到的是http：package main&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import (&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    fd,_:=os.OpenFile(&amp;quot;a.txt&amp;quot;,os.O_RDWR|os.O_CREATE,0644)&#xA;    buf:=[]byte(&amp;quot;http://www.usr.cc&amp;quot;)&#xA;    fd.Write(buf)&#xA;    rx_buf:=make([]byte,4)&#xA;    fd.ReadAt(rx_buf,0)&#xA;    fmt.Println(string(rx_buf))&#xA;    fd.Close()&#xA;}&#xA;&#xA;// 文件的关闭fb.Close()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;写程序离不了文件操作，这里总结下go语言文件操作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一、建立与打开&lt;/p&gt;&#xA;&#xA;&lt;p&gt;建立文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Create(name string) (file *File, err Error)&#xA;func NewFile(fd int, name string) *File&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：http://golang.org/pkg/os/#Create&lt;/p&gt;&#xA;&#xA;&lt;p&gt;打开文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Open(name string) (file *File, err Error)&#xA;func OpenFile(name string, flag int, perm uint32) (file *File, err Error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：http://golang.org/pkg/os/#Open&lt;/p&gt;&#xA;&#xA;&lt;p&gt;二、写文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;写文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (file *File) Write(b []byte) (n int, err Error)&#xA;func (file *File) WriteAt(b []byte, off int64) (n int, err Error)&#xA;func (file *File) WriteString(s string) (ret int, err Error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：http://golang.org/pkg/os/#File.Write&lt;/p&gt;&#xA;&#xA;&lt;p&gt;写文件示例代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main &#xA;import(&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    )&#xA;&#xA;func main() {&#xA;    userFile := &amp;quot;test.txt&amp;quot;&#xA;    fout,err := os.Create(userFile)&#xA;    deferfout.Close()&#xA;    if err != nil{&#xA;        fmt.Println(userFile,err)&#xA;        return&#xA;    }&#xA;    for i:= 0;i&amp;lt;10;i++ {&#xA;        fout.WriteString(&amp;quot;Just a test!\r\n&amp;quot;)&#xA;        fout.Write([]byte(&amp;quot;Just a test!\r\n&amp;quot;))&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;三、读文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;读文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (file *File) Read(b []byte) (n int, err Error)&#xA;func (file *File) ReadAt(b []byte, off int64) (n int, err Error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：http://golang.org/pkg/os/#File.Read&lt;/p&gt;&#xA;&#xA;&lt;p&gt;读文件示例代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import(&amp;quot;os&amp;quot;&#xA;&amp;quot;fmt&amp;quot;&#xA;)&#xA;func main() {&#xA;    userFile := &amp;quot;test.txt&amp;quot;&#xA;    fin,err := os.Open(userFile)&#xA;    deferfin.Close()&#xA;    if err != nil{&#xA;    fmt.Println(userFile,err)&#xA;    return&#xA;    }&#xA;    buf := make([]byte, 1024)&#xA;    for{&#xA;      n, _ := fin.Read(buf)&#xA;     if0== n { break}os.Stdout.Write(buf[:n])&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;四、删除文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;函数：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func Remove(name string) Error&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-使用命令行参数</title>
      <link>http://www.nljb.net/default/Golang-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</link>
      <pubDate>2014-07-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Golang有两个标准包中都有获得命令行参数的方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[*]os/Args可以简单地获得一个类似Ｃ语言中的argv结构&#xA;[*]flag则提供了一个更为复杂的标志与值的方法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;os.Argsos.Args返回一个字符串数组[] string.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用方法很简单：package main&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    fmt.Println(os.Args)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用命令：go run test.go arg1 arg2&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可见返回了一个三个元素的数组，第０个元素是程序的名字包括路径，os.Args就第一个参数，os.Args就是第二个参数。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;flag包flag包提供的功能非常复杂。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它将命令行参数分为非标志类参数(nonflag arguments)和Flags，标志参数是这样的-flagname=x，比如说-baudrate=1200。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;非标志类参数为arg1 arg2。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;flag参数处理流程由于标志类参数是参数的一部分，但又特殊，为了将标志类参数区别处理&lt;/p&gt;&#xA;&#xA;&lt;p&gt;flag包有两类方法，一类是flag处理方法，另一类是正常的参数处理方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正常的参数处理方法正常参数处理方法与os.Args差不多，这里是一个方法，flag.Args()，返回也是[]string.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;/*    &amp;quot;os/exec&amp;quot;&#xA;    &amp;quot;bytes&amp;quot;*/&#xA;    &amp;quot;flag&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    flag.Parse()&#xA;    fmt.Println(flag.Args())&#xA;} &#xA;&#xA;go run test.go arg1 arg2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果有标志类参数呢？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go run test.go arg1 arg2　-baudrate=1200&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这里充分证明了标志类参数也是参数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;标志类参数Parse前定义如果使用标志类参数，要提前定义,定义之后再调用Parse才能解析出来：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;flag&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    baudrate:=flag.Int(&amp;quot;baudrate&amp;quot;,1200, &amp;quot;help message for flagname&amp;quot;)&#xA;    databits:=flag.Int(&amp;quot;databits&amp;quot;,10,&amp;quot;number of data bits&amp;quot;)&#xA;    flag.Parse()&#xA;    fmt.Println(*baudrate)&#xA;    fmt.Println(*databits)&#xA;    fmt.Println(flag.Args())&#xA;}&#xA;&#xA;go run test.go -baudrate=9600 -databits=8 arg1 arg2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;标志类参数必须在Parse之定义，否则会出错：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;flag&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    flag.Parse()&#xA;    baudrate:=flag.Int(&amp;quot;baudrate&amp;quot;,1200, &amp;quot;help message for flagname&amp;quot;)&#xA;    databits:=flag.Int(&amp;quot;databits&amp;quot;,10,&amp;quot;number of data bits&amp;quot;)&#xA;    fmt.Println(*baudrate)&#xA;    fmt.Println(*databits)&#xA;    fmt.Println(flag.Args())&#xA;}&#xA;&#xA;go run test.go -baudrate=9600 -databits=8 arg1 arg2&#xA;&#xA;flag provided but not defined: -baudrate&#xA;&#xA;Usage of /tmp/go-build944578075/command-line-arguments/_obj/a.out:&#xA;exit status 2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;flag.Int返回的是地址&lt;/p&gt;&#xA;&#xA;&lt;p&gt;需要注意的是这里flag.Int返回的值为一个地址，你可以随时到这个地址里去取值&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但在Parse之前取值，取到的是默认值，Parse之后去随值，取到的才是真正的值：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;flag&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    baudrate:=flag.Int(&amp;quot;baudrate&amp;quot;,1200, &amp;quot;help message for flagname&amp;quot;)&#xA;    databits:=flag.Int(&amp;quot;databits&amp;quot;,10,&amp;quot;number of data bits&amp;quot;)&#xA;&#xA;    fmt.Println(*baudrate)&#xA;    fmt.Println(*databits)&#xA;    flag.Parse()&#xA;    fmt.Println(flag.Args())&#xA;}&#xA;&#xA;go run test.go -baudrate=9600 -databits=8 arg1 arg2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;标志类参数顺序&lt;/p&gt;&#xA;&#xA;&lt;p&gt;标志类参数之间的前后顺序可以改变，但是似乎标志类参数非要放到非标志类参数之前才能正确解析。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;flag&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    databits:=flag.Int(&amp;quot;databits&amp;quot;,10,&amp;quot;number of data bits&amp;quot;)&#xA;    baudrate:=flag.Int(&amp;quot;baudrate&amp;quot;,1200, &amp;quot;help message for flagname&amp;quot;)&#xA;    flag.Parse()&#xA;    fmt.Println(*baudrate)&#xA;    fmt.Println(*databits)&#xA;    fmt.Println(flag.Args())&#xA;}&#xA;&#xA;go run test.go -baudrate=9600 -databits=8 arg1 arg2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面的命令正确解析了，调换了baudrate和databits的顺序&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go run test.go arg1 -baudrate=9600 -databits=8  arg2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上前这里没能正确解析，可以baudrate和databits得到的还是默认值，而非标志类参数获取到了所有的参数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;ndash;help&lt;/p&gt;&#xA;&#xA;&lt;p&gt;flag.Int的最后一个参数是help信息：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go run test.go --help&#xA;&#xA;Usage of /tmp/go-build327358548/command-line-arguments/_obj/a.out:&#xA;  -baudrate=1200: help message for flagname&#xA;  -databits=10: number of data bits&#xA;exit status 2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;flag.String传入的参数显然不能都是数字，实际go语言提供的类型都支持，与flag.Int类似，所有其他函数都有：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;flag.String flag.Uint flag.Float64....&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;flag.IntVarflag.Int返回的是指针，用起来可以有点不太好，flag.IntVar可能用起来更好的些：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var baudrate int&#xA;flag.IntVar(&amp;amp;baudrate,&amp;quot;baudrate&amp;quot;,1200,&amp;quot;baudrate of serial port&amp;quot;)&#xA;flag.Parse()&#xA;fmt.Println(baudrate)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当前你一样可以用flag.UintVar flag.Float64Var  flag.StringVar&lt;/p&gt;&#xA;&#xA;&lt;p&gt;参数个数参数个数也分为标志类参数的非标志类参数，两个方法为NArg和NFlag,&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;flag&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    databits:=flag.Int(&amp;quot;databits&amp;quot;,10,&amp;quot;number of data bits&amp;quot;)&#xA;    baudrate:=flag.Int(&amp;quot;baudrate&amp;quot;,1200, &amp;quot;help message for flagname&amp;quot;)&#xA;    flag.Parse()&#xA;    fmt.Println(*baudrate)&#xA;    fmt.Println(*databits)&#xA;    fmt.Println(flag.Args())&#xA;    fmt.Println(flag.NArg())&#xA;    fmt.Println(flag.NFlag())&#xA;}&#xA;&#xA;go run test.go -baudrate=9600 -databits=8 arg1 arg2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-Time</title>
      <link>http://www.nljb.net/default/Golang-Time/</link>
      <pubDate>2014-07-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Go的time包是标准库中的包之一&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不用说，几乎是开发必须用到的包之一。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;time包的说明文档在：http://golang.org/pkg/time/&lt;/p&gt;&#xA;&#xA;&lt;p&gt;看看godoc文档，最大的数据类型就是Time了，这个Time类型最微小可以表示到nanosecond（微毫秒，十亿份之一秒）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-Time/1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Time的比较是使用Before,After和Equal方法。看一眼After：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (t Time) After(u Time) bool&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;很好，返回的是bool类型，是我们所需要的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Sub方法返回的是两个时间点之间的时间距离，看上图看到它返回的是Duration结构，这个结构的具体类型和操作也在godoc中&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Add方法和Sub方法是相反的，获取t0和t1的时间距离d是使用Sub，将t0加d获取t1就是使用Add方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;IsZero方法：Time的zero时间点是January 1, year 1, 00:00:00 UTC，这个函数判断一个时间是否是zero时间点&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Local，UTC，Ln是用来显示和计算地区时间的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面从几个需求直接看time的使用1 请打出当前时间的时间戳，然后将时间戳格式为年月日时分秒的形式&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    //时间戳&#xA;    t := time.Now().Unix()&#xA;    fmt.Println(t)&#xA;&#xA;    //时间戳到具体显示的转化&#xA;    fmt.Println(time.Unix(t, 0).String())&#xA;&#xA;    //带纳秒的时间戳&#xA;    t = time.Now().UnixNano()&#xA;    fmt.Println(t)&#xA;    fmt.Println(&amp;quot;------------------&amp;quot;)&#xA;&#xA;    //基本格式化的时间表示&#xA;    fmt.Println(time.Now().String())&#xA;&#xA;    fmt.Println(time.Now().Format(&amp;quot;2006year 01month 02day&amp;quot;))&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;显示：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-Time/2.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;特别是Format这个函数，可以好好使用&lt;/p&gt;&#xA;&#xA;&lt;p&gt;输出当前星期几？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    //时间戳&#xA;    t := time.Now()&#xA;    fmt.Println(t.Weekday().String())&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-Time/3.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;文档中对这个Weekday类型就没有说明!!没法，直接看代码可以看到：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-Time/4.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Weekday有一个String()方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;好了，看到这里外带我们有一个推测：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当一个结构中有定义String()函数的时候，fmt.Println()是会调用String的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;例子如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;type MyStruct struct{&#xA;}&#xA;&#xA;func (d MyStruct)String() string {return &amp;quot;mystruct&amp;quot;}&#xA;&#xA;func main() {&#xA;    me := new(MyStruct)&#xA;    fmt.Println(me)&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-Time/5.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Go的Time之旅结束！！&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>old_passwords</title>
      <link>http://www.nljb.net/default/old_passwords/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/old_passwords/1.jpg&#34; alt=&#34;&#34; width=&#34;800&#34;&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Tinycore-Linux</title>
      <link>http://www.nljb.net/default/Tinycore-Linux/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;a href=&#34;http://wiki.tinycorelinux.net/wiki:remastering&#34;&gt;http://wiki.tinycorelinux.net/wiki:remastering&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Tinycore-Linux/1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Tinycore-Linux/2_0.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Tinycore-Linux/3_0.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Shell-删除文件中某一行方法</title>
      <link>http://www.nljb.net/default/Shell-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9F%90%E4%B8%80%E8%A1%8C%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;如果有一个abc.txt文件，内容是:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;aaa&#xA;bbb&#xA;ccc&#xA;ddd&#xA;eee&#xA;fff&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果要删除aaa，那么脚本可以这样写：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sed -i &#39;/aaa/d&#39; abc.txt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果删除的是一个变量的值，假如变量是var，应该写成：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sed -i &#39;/&#39;&amp;quot;$var&amp;quot;&#39;/d&#39; abc.txt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>MBR-引导区文件</title>
      <link>http://www.nljb.net/default/MBR-%E5%BC%95%E5%AF%BC%E5%8C%BA%E6%96%87%E4%BB%B6/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;查看硬盘分区信息&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;parted /dev/sda print&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;备份MBR，linux下使用如下命令：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;dd if=/dev/hda of=/root/linux.bin bs=512 count=1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这里注意使用if=/dev/hda备份MBR中数据，如果grub安装具体某个分区，则要自己选择了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;写入mbr:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;dd if=/mnt/windows/linux.lnx of=/dev/hda bs=512 count=1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果以上有什么不懂的可以在终端下输入 dd &amp;ndash;help查看帮助。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-正则-regexp</title>
      <link>http://www.nljb.net/default/Golang-%E6%AD%A3%E5%88%99-regexp/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;io/ioutil&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;regexp&amp;quot;&#xA;    &amp;quot;strings&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    resp, err := http.Get(&amp;quot;http://www.baidu.com&amp;quot;)&#xA;&#xA;    // resp, err := http.Get(&amp;quot;http://www.163.com&amp;quot;)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;http get error.&amp;quot;)&#xA;    }&#xA;&#xA;    defer resp.Body.Close()&#xA;    body, err := ioutil.ReadAll(resp.Body)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;http read error&amp;quot;)&#xA;    }&#xA;&#xA;    src := string(body)&#xA;&#xA;    //将HTML标签全转换成小写&#xA;    re, _ := regexp.Compile(&amp;quot;\\&amp;lt;[\\S\\s]+?\\&amp;gt;&amp;quot;)&#xA;    src = re.ReplaceAllStringFunc(src, strings.ToLower)&#xA;&#xA;    //去除STYLE&#xA;    re, _ = regexp.Compile(&amp;quot;\\&amp;lt;style[\\S\\s]+?\\&amp;lt;/style\\&amp;gt;&amp;quot;)&#xA;    src = re.ReplaceAllString(src, &amp;quot;&amp;quot;)&#xA;&#xA;    //去除SCRIPT&#xA;    re, _ = regexp.Compile(&amp;quot;\\&amp;lt;script[\\S\\s]+?\\&amp;lt;/script\\&amp;gt;&amp;quot;)&#xA;    src = re.ReplaceAllString(src, &amp;quot;&amp;quot;)&#xA;&#xA;    //去除所有尖括号内的HTML代码，并换成换行符&#xA;    re, _ = regexp.Compile(&amp;quot;\\&amp;lt;[\\S\\s]+?\\&amp;gt;&amp;quot;)&#xA;    src = re.ReplaceAllString(src, &amp;quot;\n&amp;quot;)&#xA;&#xA;    //去除连续的换行符&#xA;    re, _ = regexp.Compile(&amp;quot;\\s{2,}&amp;quot;)&#xA;    src = re.ReplaceAllString(src, &amp;quot;\n&amp;quot;)&#xA;&#xA;    fmt.Println(strings.TrimSpace(src))&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-标准库解读-基本的IO接口</title>
      <link>http://www.nljb.net/default/Golang-%E6%A0%87%E5%87%86%E5%BA%93%E8%A7%A3%E8%AF%BB-%E5%9F%BA%E6%9C%AC%E7%9A%84IO%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;io 包为I/O原语提供了基本的接口。它主要包装了这些原语的已有实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于这些接口和原语以不同的实现包装了低级操作，因此除非另行通知，否则客户端不应假定它们对于并行执行是安全的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在io包中最重要的是两个接口：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Reader和Writer接口。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;本章所提到的各种IO包，都跟这两个接口有关，也就是说，只要实现了这两个接口，它就有了IO的功能。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Reader接口Reader接口的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Reader interface {    Read(p []byte) (n int, err error)}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方文档中关于该接口方法的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Read 将 len(p) 个字节读取到 p 中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回读取的字节数 n（0 &amp;lt;= n &amp;lt;= len(p)） 以及任何遇到的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;即使 Read 返回的 n &amp;lt; len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若一些数据可用但不到 len(p) 个字节，Read 会照例返回可用的数据，而不是等待更多数据。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当 Read 在成功读取 n &amp;gt; 0 个字节后遇到一个错误或EOF（end-of-file），它就会返回读取的字节数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它会从相同的调用中返回（非nil的）错误或从随后的调用中返回错误（同时 n == 0）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一般情况的一个例子就是 Reader 在输入流结束时会返回一个非零的字节数，同时返回的err不是EOF就是nil。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;无论如何，下一个 Read 都应当返回 0, EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;调用者应当总在考虑到错误 err 前处理 n &amp;gt; 0 的字节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样做可以在读取一些字节，以及允许的 EOF 行为后正确地处理I/O错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，当Read方法返回错误时，不代表没有读取到任何数据。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;调用者应该处理返回的任何数据，之后才处理可能的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据Go语言中关于接口和实现了接口的类型的定义（Interface_types），&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们知道Reader接口的方法集（Method_sets）只包含一个Read方法，因此，所有实现了Read方法的类型都实现了io.Reader接口，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，在所有需要io.Reader的地方，可以传递实现了Read()方法的类型的实例。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面，我们通过具体例子来谈谈该接口的用法。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ReadFrom(reader io.Reader, num int) ([]byte, error) {&#xA;    p := make([]byte, num)&#xA;    n, err := reader.Read(p)&#xA;    if n &amp;gt; 0 {&#xA;    return p[:n], nil&#xA;    }&#xA;    return p, err&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;ReadFrom函数将io.Reader作为参数，也就是说，ReadFrom可以从任意的地方读取数据，只要来源实现了io.Reader接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如，我们可以从标准输入、文件、字符串等读取数据，示例代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 从标准输入读取&#xA;data, err = ReadFrom(os.Stdin, 11)&#xA;// 从普通文件读取，其中file是os.File的实例&#xA;data, err = ReadFrom(file, 9)&#xA;// 从字符串读取&#xA;type Writer interface {&#xA;    Write(p []byte) (n int, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;完整的演示例子源码见&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/polaris1119/The-Golang-Standard-Library-by-Example/blob/master/code/src/chapter01/io/reader.go&#34;&gt;https://github.com/polaris1119/The-Golang-Standard-Library-by-Example/blob/master/code/src/chapter01/io/reader.go&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;小贴士&lt;/p&gt;&#xA;&#xA;&lt;p&gt;io.EOF 变量的定义：var EOF = errors.New(&amp;ldquo;EOF&amp;rdquo;)，是error类型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据reader接口的说明，在 n &amp;gt; 0 且数据被读完了的情况下，返回的error有可能是EOF也有可能是nil。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Writer接口Writer接口的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Writer interface {&#xA;    Write(p []byte) (n int, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方文档中关于该接口方法的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Write 将 len(p) 个字节从 p 中写入到基本数据流中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回从 p 中被写入的字节数 n（0 &amp;lt;= n &amp;lt;= len(p)）以及任何遇到的引起写入提前停止的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 Write 返回的 n &amp;lt; len(p)，它就必须返回一个非nil的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同样的，所有实现了Write方法的类型都实现了io.Writer接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在上个例子中，我们是自己实现一个函数接收一个io.Reader类型的参数。这里，我们通过标准库的例子来学习。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在fmt标准库中，有一组函数：Fprint/Fprintf/Fprintln，它们接收一个io.Wrtier类型参数（第一个参数），&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说它们将数据格式化输出到io.Writer中。那么，调用这组函数时，该如何传递这个参数呢？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们以fmt.Fprintln为例，同时看一下fmt.Println函数的源码。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Println(a ...interface{}) (n int, err error) {&#xA;    return Fprintln(os.Stdout, a...)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;实现了io.Reader接口或io.Writer接口的类型初学者看到函数参数是一个接口类型，很多时候有些束手无策，不知道该怎么传递参数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;还有人问：标准库中有哪些类型实现了io.Reader或io.Writer接口？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var (&#xA;    Stdin  = NewFile(uintptr(syscall.Stdin), &amp;quot;/dev/stdin&amp;quot;)&#xA;    Stdout = NewFile(uintptr(syscall.Stdout), &amp;quot;/dev/stdout&amp;quot;)&#xA;    Stderr = NewFile(uintptr(syscall.Stderr), &amp;quot;/dev/stderr&amp;quot;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过本节上面的例子，我们可以知道，os.File同时实现了这两个接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们还看到 os.Stdin/Stdout这样的代码，它们似乎分别实现了 io.Reader/io.Writer接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;没错，实际上在os包中有这样的代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var (&#xA;    Stdin  = NewFile(uintptr(syscall.Stdin), &amp;quot;/dev/stdin&amp;quot;)&#xA;    Stdout = NewFile(uintptr(syscall.Stdout), &amp;quot;/dev/stdout&amp;quot;)&#xA;    Stderr = NewFile(uintptr(syscall.Stderr), &amp;quot;/dev/stderr&amp;quot;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;也就是说，Stdin/Stdout/Stderr 只是三个特殊的文件（即都是os.File的实例），自然也实现了io.Reader和io.Writer。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;目前，Go文档中还没发直接列出实现了某个接口的所有类型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过，我们可以通过查看标准库文档，列出实现了io.Reader或io.Writer接口的类型（导出的类型）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;os.File 同时实现了io.Reader和io.Writer&#xA;strings.Reader 实现了io.Reader&#xA;bufio.Reader/Writer 分别实现了io.Reader和io.Writer&#xA;bytes.Buffer 同时实现了io.Reader和io.Writer&#xA;bytes.Reader 实现了io.Reader&#xA;compress/gzip.Reader/Writer 分别实现了io.Reader和io.Writer&#xA;crypto/cipher.StreamReader/StreamWriter 分别实现了io.Reader和io.Writer&#xA;crypto/tls.Conn 同时实现了io.Reader和io.Writer&#xA;encoding/csv.Reader/Writer 分别实现了io.Reader和io.Writer&#xA;mime/multipart.Part 实现了io.Reader&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;除此之外，io包本身也有这两个接口的实现类型。如：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;实现了Reader的类型：LimitedReader、PipeReader、SectionReader&lt;/p&gt;&#xA;&#xA;&lt;p&gt;实现了Writer的类型：PipeWriter以上类型中，常用的类型有：os.File、strings.Reader、bufio.Reader/Writer、bytes.Buffer、bytes.Reader&lt;/p&gt;&#xA;&#xA;&lt;p&gt;小贴士&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从接口名称很容易猜到，一般地，Go中接口的命名约定：接口名以er结尾。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意，这里并非强行要求，你完全可以不以 er 结尾。标准库中有些接口也不是以 er 结尾的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReaderAt和WriterAt接口ReaderAt接口的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type ReaderAt interface {&#xA;    ReadAt(p []byte, off int64) (n int, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方文档中关于该接口方法的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReadAt 从基本输入源的偏移量 off 处开始，将 len(p) 个字节读取到 p 中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回读取的字节数 n（0 &amp;lt;= n &amp;lt;= len(p)）以及任何遇到的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当 ReadAt 返回的 n &amp;lt; len(p) 时，它就会返回一个非nil的错误来解释 为什么没有返回更多的字节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在这一点上，ReadAt 比 Read 更严格。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;即使 ReadAt 返回的 n &amp;lt; len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若一些数据可用但不到 len(p) 字节，ReadAt 就会阻塞直到所有数据都可用或产生一个错误。 在这一点上 ReadAt 不同于 Read。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 n = len(p) 个字节在输入源的的结尾处由 ReadAt 返回，那么这时 err == EOF 或者 err == nil。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 ReadAt 按查找偏移量从输入源读取，ReadAt 应当既不影响基本查找偏移量也不被它所影响。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReadAt 的客户端可对相同的输入源并行执行 ReadAt 调用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可见，ReaderAt接口使得可以从指定偏移量处开始读取数据。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;简单示例代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;reader := strings.NewReader(&amp;quot;Go语言学习园地&amp;quot;)&#xA;p := make([]byte, 6)&#xA;n, err := reader.ReadAt(p, 2)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;fmt.Printf(&amp;quot;%s, %d\n&amp;quot;, p, n)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;WriterAt接口的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type WriterAt interface {&#xA;    WriteAt(p []byte, off int64) (n int, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方文档中关于该接口方法的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;WriteAt 从 p 中将 len(p) 个字节写入到偏移量 off 处的基本数据流中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回从 p 中被写入的字节数 n（0 &amp;lt;= n &amp;lt;= len(p)）以及任何遇到的引起写入提前停止的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 WriteAt 返回的 n &amp;lt; len(p)，它就必须返回一个非nil的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 WriteAt 按查找偏移量写入到目标中，WriteAt 应当既不影响基本查找偏移量也不被它所影响。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若区域没有重叠，WriteAt 的客户端可对相同的目标并行执行 WriteAt 调用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们可以通过该接口将数据写入数据流的特定偏移量之后。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过简单示例来演示WriteAt方法的使用（os.File实现了WriterAt接口）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;file, err := os.Create(&amp;quot;writeAt.txt&amp;quot;)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;defer file.Close()&#xA;file.WriteString(&amp;quot;Golang中文社区——这里是多余的&amp;quot;)&#xA;n, err := file.WriteAt([]byte(&amp;quot;Go语言学习园地&amp;quot;), 24)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;fmt.Println(n)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打开文件WriteAt.txt，内容是：Golang中文社区——Go语言学习园地。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;分析：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;file.WriteString(&amp;ldquo;Golang中文社区——这里是多余的&amp;rdquo;) 往文件中写入Golang中文社区——这里是多余的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;之后file.WriteAt([]byte(&amp;ldquo;Go语言学习园地&amp;rdquo;), 24) 在文件流的offset=24处写入Go语言学习园地（会覆盖该位置的内容）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReaderFrom 和 WriterTo 接口ReaderFrom的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type ReaderFrom interface {&#xA;    ReadFrom(r Reader) (n int64, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方文档中关于该接口方法的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReadFrom 从 r 中读取数据，直到 EOF 或发生错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其返回值 n 为读取的字节数。除 io.EOF 之外，在读取过程中遇到的任何错误也将被返回。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果 ReaderFrom 可用，Copy 函数就会使用它。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意：ReadFrom方法不会返回err == EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面的例子简单的实现将文件中的数据全部读取（显示在标准输出）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;file, err := os.Open(&amp;quot;writeAt.txt&amp;quot;)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;defer file.Close()&#xA;writer := bufio.NewWriter(os.Stdout)&#xA;writer.ReadFrom(file)&#xA;writer.Flush()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当然，我们可以通过ioutil包的ReadFile函数获取文件全部内容。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其实，跟踪一下ioutil.ReadFile的源码，会发现其实也是通过ReadFrom方法实现（用的是bytes.Buffer，它实现了ReaderFrom接口）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果不通过ReadFrom接口来做这件事，而是使用io.Reader接口，我们有两种思路：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;先获取文件的大小（File的Stat方法），之后定义一个该大小的[]byte，通过Read一次性读取&lt;/p&gt;&#xA;&#xA;&lt;p&gt;定义一个小的[]byte，不断的调用Read方法直到遇到EOF，将所有读取到的[]byte连接到一起&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里不给出实现代码了，有兴趣的可以实现以下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;提示&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过查看 bufio.Writer或strings.Buffer 类型的ReadFrom方法实现，会发现，其实它们的实现和上面说的第2种思路类似。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;WriterTo的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type WriterTo interface {&#xA;    WriteTo(w Writer) (n int64, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方文档中关于该接口方法的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;WriteTo 将数据写入 w 中，直到没有数据可写或发生错误。其返回值 n 为写入的字节数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在写入过程中遇到的任何错误也将被返回。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果 WriterTo 可用，Copy 函数就会使用它。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;读者是否发现，其实ReaderFrom和WriterTo接口的方法接收的参数是io.Reader和io.Writer类型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据io.Reader和io.Writer接口的讲解，对该接口的使用应该可以很好的掌握。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里只提供简单的一个示例代码：将一段文本输出到标准输出&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;reader := bytes.NewReader([]byte(&amp;quot;Go语言学习园地&amp;quot;))&#xA;reader.WriteTo(os.Stdout)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过io.ReaderFrom和io.WriterTo的学习，我们知道，如果这样的需求，可以考虑使用这两个接口：“一次性从某个地方读或写到某个地方去。”&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Seeker接口接口定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Seeker interface {&#xA;    Seek(offset int64, whence int) (ret int64, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方文档中关于该接口方法的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Seek 设置下一次 Read 或 Write 的偏移量为 offset&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它的解释取决于 whence： 0 表示相对于文件的起始处，1 表示相对于当前的偏移，而 2 表示相对于其结尾处。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Seek 返回新的偏移量和一个错误，如果有的话。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，Seek方法用于设置偏移量的，这样可以从某个特定位置开始操作数据流。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;听起来和ReaderAt/WriteAt接口有些类似，不过Seeker接口更灵活，可以更好的控制读写数据流的位置。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;简单的示例代码：获取倒数第二个字符（需要考虑UTF-8编码，这里的代码只是一个示例）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;reader := strings.NewReader(&amp;quot;Go语言学习园地&amp;quot;)&#xA;reader.Seek(-6, os.SEEK_END)&#xA;r, _, _ := reader.ReadRune()&#xA;fmt.Printf(&amp;quot;%c\n&amp;quot;, r)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;小贴士&lt;/p&gt;&#xA;&#xA;&lt;p&gt;whence的值，在os包中定义了相应的常量，应该使用这些常量&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;const (&#xA;    SEEK_SET int = 0 // seek relative to the origin of the file&#xA;    SEEK_CUR int = 1 // seek relative to the current offset&#xA;    SEEK_END int = 2 // seek relative to the end&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;Closer接口接口定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Closer interface {&#xA;    Close() error&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;该接口比较简单，只有一个Close()方法，用于关闭数据流。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;文件(os.File)、归档（压缩包）、数据库连接、Socket等需要手动关闭的资源都实现了Closer接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;实际编程中，经常将Close方法的调用放在defer语句中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;小提示&lt;/p&gt;&#xA;&#xA;&lt;p&gt;初学者容易写出这样的代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;file, err := os.Open(&amp;quot;studygolang.txt&amp;quot;)&#xA;defer file.Close()&#xA;if err != nil {&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当文件 studygolang.txt 不存在或找不到时，file.Close()会panic，因为file是nil。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此，应该将defer file.Close()放在错误检查之后。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其他接口ByteReader和ByteWriter通过名称大概也能猜出这组接口的用途：读或写一个字节。接口定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type ByteReader interface {&#xA;    ReadByte() (c byte, err error)&#xA;}&#xA;&#xA;type ByteWriter interface {&#xA;    WriteByte(c byte) error&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在标准库中，有如下类型实现了io.ByteReader或io.ByteWriter:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;bufio.Reader/Writer 分别实现了io.ByteReader和io.ByteWriter&#xA;bytes.Buffer 同时实现了io.ByteReader和io.ByteWriter&#xA;bytes.Reader 实现了io.ByteReader&#xA;strings.Reader 实现了io.ByteReader&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接下来的示例中，我们通过bytes.Buffer来一次读取或写入一个字节（主要代码）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var ch byte&#xA;fmt.Scanf(&amp;quot;%c\n&amp;quot;, &amp;amp;ch)&#xA;&#xA;buffer := new(bytes.Buffer)&#xA;err := buffer.WriteByte(ch)&#xA;if err == nil {&#xA;    fmt.Println(&amp;quot;写入一个字节成功！准备读取该字节……&amp;quot;)&#xA;    newCh, _ := buffer.ReadByte()&#xA;    fmt.Printf(&amp;quot;读取的字节：%c\n&amp;quot;, newCh)&#xA;} else {&#xA;    fmt.Println(&amp;quot;写入错误&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;程序从标准输入接收一个字节（ASCII字符），调用buffer的WriteByte将该字节写入buffer中，之后通过ReadByte读取该字节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;完整的代码见：code/src/chapter01/io/byterwer.go&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一般地，我们不会使用bytes.Buffer来一次读取或写入一个字节。那么，这两个接口有哪些用处呢？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在标准库encoding/binary中，实现Google-ProtoBuf中的Varints读取，ReadVarint就需要一个io.ByteReader类型的参数，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，它需要一个字节一个字节的读取。关于encoding/binary包在后面会详细介绍。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在标准库image/jpeg中，Encode函数的内部实现使用了ByteWriter写入一个字节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;小贴士&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以通过在Go语言源码src/pkg中搜索&amp;rdquo;io.ByteReader&amp;rdquo;或&amp;rdquo;io.ByteWiter&amp;rdquo;，获得哪些地方用到了这两个接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你会发现，这两个接口在二进制数据或归档压缩时用的比较多。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ByteScanner、RuneReader和RuneScanner将这三个接口放在一起，是考虑到与ByteReader相关或相应。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ByteScanner接口的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type ByteScanner interface {&#xA;    ByteReader&#xA;    UnreadByte() error&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可见，它内嵌了ByteReader接口（可以理解为继承了ByteReader接口），UnreadByte方法的意思是：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;将上一次ReadByte的字节还原，使得再次调用ReadByte返回的结果和上一次调用相同，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，UnreadByte是重置上一次的ReadByte。注意，UnreadByte调用之前必须调用了ReadByte，且不能连续调用UnreadByte。即：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;buffer := bytes.NewBuffer([]byte{&#39;a&#39;, &#39;b&#39;})&#xA;err := buffer.UnreadByte()&#xA;和&#xA;buffer := bytes.NewBuffer([]byte{&#39;a&#39;, &#39;b&#39;})&#xA;buffer.ReadByte()&#xA;err := buffer.UnreadByte()&#xA;err = buffer.UnreadByte()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;err都非nil，错误为：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;bytes.Buffer: UnreadByte: previous operation was not a read&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;RuneReader接口和ByteReader类似，只是ReadRune方法读取单个UTF-8字符，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;返回其rune和该字符占用的字节数。该接口在regexp包有用到。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;之前有人在QQ群中问道：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;strings.Index(“行业交流群”,“交流”) 返回的是单字节字符的位置：6。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是想要的是unicode字符的位置：2。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当时以为strings.IndexRune可以，然而IndexRune还不如Index，一方面第二个参数是rune类型；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另一方面返回的结果跟Index是一样的。这里通过RuneReader接口来实现这个需求，代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// strings.Index的UTF-8版本// 即 Utf8Index(&amp;quot;Go语言学习园地&amp;quot;, &amp;quot;学习&amp;quot;) 返回 4，而不是strings.Index的 8&#xA;&#xA;func Utf8Index(str, substr string) int {&#xA;    asciiPos := strings.Index(str, substr)&#xA;    if asciiPos == -1 || asciiPos == 0 {&#xA;    return asciiPos&#xA;    }&#xA;    pos := 0&#xA;    totalSize := 0&#xA;    reader := strings.NewReader(str)&#xA;    for _, size, err := reader.ReadRune(); err == nil; _, size, err = reader.ReadRune(){&#xA;    totalSize += size&#xA;    pos++&#xA;    // 匹配到&#xA;    if totalSize == asciiPos {&#xA;        return pos&#xA;    }&#xA;    }&#xA;    return pos&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;该实现借助了strings.Index。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外，此处的strings.NewReader可以换成bytes.NewBufferString，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过，根据strings.NewReader的文档，strings.Reader比bytes.Buffer效率更高，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;只是strings.Reader是只读的，而bytes.Buffer是可读写的（从前面介绍的实现的接口可以知道）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于bytes和strings包，后面章节会详细介绍。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;RuneScanner接口和ByteScanner类似，就不赘述了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser和WriteSeeker接口&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这些接口是上面介绍的接口的两个或三个组合而成的新接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;例如ReadWriter接口：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type ReadWriter interface {&#xA;    Reader&#xA;    Writer&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这是Reader接口和Writer接口的简单组合（内嵌）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这些接口的作用是：有些时候同时需要某两个接口的所有功能，即必须同时实现了某两个接口的类型才能够被传入使用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可见，io包中有大量的&amp;rdquo;小接口&amp;rdquo;，这样方便组合为&amp;rdquo;大接口&amp;rdquo;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SectionReader 类型SectionReader是一个struct（没有任何导出的字段），实现了 Read, Seek 和 ReadAt，同时，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;内嵌了 ReaderAt 接口。结构定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type SectionReader struct {&#xA;    r     ReaderAt  // 该类型最终的 Read/ReadAt 最终都是通过 r 的 ReadAt 实现&#xA;    base  int64     // NewSectionReader 会将 base 设置为 off&#xA;    off   int64     // 从 r 中的 off 偏移处开始读取数据&#xA;    limit int64     // limit - off = SectionReader 流的长度&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;从名称我们可以猜到，该类型读取数据流中部分数据。看一下&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader&lt;/code&gt;的文档说明就知道了：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;NewSectionReader 返回一个 SectionReader，它从 r 中的偏移量 off 处读取 n 个字节后以 EOF 停止。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，SectionReader 只是内部（内嵌）ReaderAt表示的数据流的一部分：从 off 开始后的n个字节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个类型的作用是：方便重复操作某一段(section)数据流；或者同时需要ReadAt和Seek的功能。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于该类型所支持的操作，前面都有介绍，因此提供示例代码了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于该类型在标准库中的使用，我们在 8.5 archive/zip — zip归档访问 会讲到。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;LimitedReader 类型LimitedReader 类型定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type LimitedReader struct {&#xA;    R Reader // underlying reader，最终的读取操作通过 R.Read 完成&#xA;    N int64  // max bytes remaining&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;文档说明如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从 R 读取但将返回的数据量限制为 N 字节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;每调用一次 Read 都将更新 N 来反应新的剩余数量。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，最多只能返回 N 字节数据。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;LimitedReader只实现了Read方法（Reader接口）。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用示例如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;content := &amp;quot;This Is LimitReader Example&amp;quot;&#xA;reader := strings.NewReader(content)&#xA;limitReader := &amp;amp;io.LimitedReader{R: reader, N: 8}&#xA;for limitReader.N &amp;gt; 0 {&#xA;    tmp := make([]byte, 2)&#xA;    limitReader.Read(tmp)&#xA;    fmt.Printf(&amp;quot;%s&amp;quot;, tmp)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可见，通过该类型可以达到 只允许读取一定长度数据 的目的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在io包中，LimitReader 函数的实现其实就是调用 LimitedReader：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func LimitReader(r Reader, n int64) Reader { return &amp;amp;LimitedReader{r, n} }&lt;/p&gt;&#xA;&#xA;&lt;p&gt;PipReader 和 PipWriter 类型PipReader（一个没有任何导出字段的struct）是管道的读取端。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它实现了io.Reader和io.Closer接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于 Read 方法的说明：从管道中读取数据。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;该方法会堵塞，直到管道写入端开始写入数据或写入端关闭了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果写入端关闭时带上了error（即调用CloseWithError关闭），该方法返回的err就是写入端传递的error；否则err为EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;PipWriter（一个没有任何导出字段的struct）是管道的写入端。它实现了io.Writer和io.Closer接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于 Write 方法的说明：写数据到管道中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;该方法会堵塞，直到管道读取端读完所有数据或读取端关闭了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果读取端关闭时带上了error（即调用CloseWithError关闭），该方法返回的err就是读取端传递的error；否则err为 ErrClosedPipe。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其他方法的使用通过例子一起讲解：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    Pipe()&#xA;}&#xA;&#xA;func Pipe() {&#xA;    pipeReader, pipeWriter := io.Pipe()&#xA;    go PipeWrite(pipeWriter)&#xA;    go PipeRead(pipeReader)&#xA;    time.Sleep(1e7)&#xA;}&#xA;&#xA;func PipeWrite(pipeWriter *io.PipeWriter) {&#xA;    var (&#xA;    i   = 0&#xA;    err error&#xA;    n int&#xA;    )&#xA;    data := []byte(&amp;quot;Go语言学习园地&amp;quot;)&#xA;    for _, err = pipeWriter.Write(data); err == nil; n, err = pipeWriter.Write(data) {&#xA;    i++&#xA;    if i == 3 {&#xA;        pipeWriter.CloseWithError(errors.New(&amp;quot;输出3次后结束&amp;quot;))&#xA;    }&#xA;    }&#xA;    fmt.Println(&amp;quot;close 后输出的字节数：&amp;quot;, n, &amp;quot; error：&amp;quot;,  err)&#xA;}&#xA;&#xA;func PipeRead(pipeReader *io.PipeReader) {&#xA;    var (&#xA;    err error&#xA;    n   int&#xA;    )&#xA;    data := make([]byte, 1024)&#xA;    for n, err = pipeReader.Read(data); err == nil; n, err = pipeReader.Read(data) {&#xA;    fmt.Printf(&amp;quot;%s\n&amp;quot;, data[:n])&#xA;    }&#xA;    fmt.Println(&amp;quot;writer 端 closewitherror后：&amp;quot;, err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;writer 端 closewitherror后： 输出3次后结束close 后输出的字节数： 20  error： io: read/write on closed pipe&lt;/p&gt;&#xA;&#xA;&lt;p&gt;细心的读者可能发现：不是输出3此后结束吗？怎么“Go语言学习园地”却输出了4次？这个问题我们稍候讨论。我们先来分析一下例子代码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;io.Pipe()用于创建创建一个同步的内存管道（synchronous in-memory pipe），&lt;/p&gt;&#xA;&#xA;&lt;p&gt;函数签名：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Pipe() (*PipeReader, *PipeWriter)它将 io.Reader 连接到 io.Writer。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一端的读取匹配另一端的写入，直接在这两端之间复制数据；它没有内部缓存。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它对于并行调用 Read 和 Write 以及其它函数或 Close 来说都是安全的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一旦等待的I/O结束，Close 就会完成。并行调用 Read 或并行调用 Write 也同样安全： 同种类的调用将按顺序进行控制。稍候我们会分析管道相关的源码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正因为是*同步*的，因此不能在一个goroutine中进行读和写。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在 PipeWrite 函数中，我们循环往管道中写数据，写第三次时，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们调用 CloseWithError 方法关闭管道的写入端，之后再一次调用 Write 方法，发现返回了error，于是退出了循环。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可是，从输出结果中，我们发现，最后一次写虽然返回error（返回的n并非0），&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是读取端却能读到最后一次写的数据，这让人很费解。下面我们一起来探索一下相关源码，分析问题的原因。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;io 包 管道（pipe） 源码分析从上文知道，PipWriter 和 PipeReader 都没有导出成员。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;查看源码发现，两者都只有一个成员：p *pipe，这两种类型的所有方法都是调用了 pipe 类型对应的方法实现的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;pipe类型的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// A pipe is the shared pipe structure underlying PipeReader and PipeWriter.&#xA;&#xA;type pipe struct {&#xA;    rl    sync.Mutex // gates readers one at a time&#xA;    wl    sync.Mutex // gates writers one at a time&#xA;    l     sync.Mutex // protects remaining fields&#xA;    data  []byte     // data remaining in pending write&#xA;    rwait sync.Cond  // waiting reader&#xA;    wwait sync.Cond  // waiting writer&#xA;    rerr  error      // if reader closed, error to give writes&#xA;    werr  error      // if writer closed, error to give reads&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;字段说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;rl/wl 用于控制同一时刻只能有一个读取器或写入器&lt;/p&gt;&#xA;&#xA;&lt;p&gt;l 用于保护其他字段&lt;/p&gt;&#xA;&#xA;&lt;p&gt;data 在管道中的数据&lt;/p&gt;&#xA;&#xA;&lt;p&gt;rwait/wwait sync.Cond类型（后续会讲解），分别控制读取器或写入器等待&lt;/p&gt;&#xA;&#xA;&lt;p&gt;rerr/werr 读取器（写入器）关闭，该错误会被Write（Read）方法返回&lt;/p&gt;&#xA;&#xA;&lt;p&gt;pipe的read方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (p *pipe) read(b []byte) (n int, err error) {&#xA;    // One reader at a time.（控制一次只能一个读取器）&#xA;    p.rl.Lock()&#xA;    defer p.rl.Unlock()&#xA;&#xA;    // 保护其他字段的读写&#xA;    p.l.Lock()&#xA;    defer p.l.Unlock()&#xA;    for {&#xA;    // Reader端关闭后，再Read，则返回ErrClosedPipe&#xA;    if p.rerr != nil {&#xA;        return 0, ErrClosedPipe&#xA;    }&#xA;    // 管道中有数据，退出循环&#xA;    if p.data != nil {&#xA;        break&#xA;    }&#xA;    // Writer端关闭，返回p.werr&#xA;    if p.werr != nil {&#xA;        return 0, p.werr&#xA;    }&#xA;    // 没有数据或管道没有关闭，读取端等待&#xA;    p.rwait.Wait()&#xA;    }&#xA;    // 管道中有数据，将其copy一份到b中&#xA;    n = copy(b, p.data)&#xA;    p.data = p.data[n:]&#xA;    // 如果管道数据被读光，需要唤醒在等待的Writer&#xA;    if len(p.data) == 0 {&#xA;    p.data = nil&#xA;    p.wwait.Signal()&#xA;    }&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;加上的代码注释已经很清楚了，因此不再赘述。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;pipe的write方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (p *pipe) write(b []byte) (n int, err error) {&#xA;    // pipe uses nil to mean not available&#xA;    if b == nil {&#xA;    // zero的定义为：var zero [0]byte&#xA;    b = zero[:]&#xA;    }&#xA;&#xA;    // One writer at a time.&#xA;    p.wl.Lock()&#xA;    defer p.wl.Unlock()&#xA;&#xA;    p.l.Lock()&#xA;    defer p.l.Unlock()&#xA;    // 上面说的问题来了：不管三七二十一，一上来些将数据放进管道中&#xA;    p.data = b&#xA;    // 唤醒在等待的Reader&#xA;    p.rwait.Signal()&#xA;    for {&#xA;    // 数据被读走，退出循环&#xA;    if p.data == nil {&#xA;        break&#xA;    }&#xA;    // Reader端关闭，设置err = p.rerr，退出循环&#xA;    if p.rerr != nil {&#xA;        err = p.rerr&#xA;        break&#xA;    }&#xA;    // Writer端关闭后，再Writer，设置err = ErrClosedPipe&#xA;    if p.werr != nil {&#xA;        err = ErrClosedPipe&#xA;    }&#xA;    // 数据没被读走（全部）或管道读取端没关闭，则等待&#xA;    p.wwait.Wait()&#xA;    }&#xA;    // 计算写入的字节数&#xA;    n = len(b) - len(p.data)&#xA;    p.data = nil // in case of rerr or werr&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过上面两个方法的代码注释，应该清楚例子中为啥输出4次了吧？我们再分析一下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当i == 3，调用CloseWithError之后，程序执行 for 中的 n, err = pipeWriter.Write(data)，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据上面pipe.write方法，p.data 会被设置上数据，这个时候，Reader被唤醒，将数据读走（第4次）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于异步，多goroutine，跟调度有关系，这个时候Writer可能在等待，也可能在Reader读完数据后将其唤醒，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;总之，Writer会执行到 if p.werr != nil，即例子中Write循环结束；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而Reader被唤醒之后，首先判断的是p.data != nil，而不是 p.werr != nil，因此数据被正常读取，且没错误被返回，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这时执行下一次循环，当然，这时候由于没有Write，且 p.werr != nil，于是Read方法返回err(=p.werr)。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;个人认为这是一个bug，已经向官方提出：issue5330，修复处：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在pipe.write方法的defer p.l.Unlock()后面增加如下代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 写端关闭了，不让写入数据&#xA;if p.werr != nil {&#xA;    p.rwait.Signal()&#xA;    err = ErrClosedPipe&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;同时，for循环中如下代码没有必要，删除：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Writer端关闭后，再Writer，设置err = ErrClosedPipe&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if p.werr != nil {&#xA;    err = ErrClosedPipe&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;pipe.read方法中，调整检查p.werr和p.data的顺序，即改为：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if p.werr != nil {&#xA;    return 0, p.werr&#xA;}&#xA;if p.data != nil {&#xA;    break&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样不至于有错误时还把数据读走。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外，对于管道的close方法（非CloseWithError时），err会被置为EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Copy 和 CopyN 函数Copy 函数的签名：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Copy(dst Writer, src Reader) (written int64, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;函数文档：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Copy 将 src 复制到 dst，直到在 src 上到达 EOF 或发生错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回复制的字节数，如果有的话，还会返回在复制时遇到的第一个错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;成功的 Copy 返回 err == nil，而非 err == EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于 Copy 被定义为从 src 读取直到 EOF 为止，因此它不会将来自 Read 的 EOF 当做错误来报告。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 dst 实现了 ReaderFrom 接口，其复制操作可通过调用 dst.ReadFrom(src) 实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;此外，若 dst 实现了 WriterTo 接口，其复制操作可通过调用 src.WriteTo(dst) 实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;io.Copy(os.Stdout, strings.NewReader(&amp;quot;Go语言学习园地&amp;quot;))直接将内容输出（写入Stdout中）。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们甚至可以这么做：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    io.Copy(os.Stdout, os.Stdin)&#xA;    fmt.Println(&amp;quot;Got EOF -- bye&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行：echo &amp;ldquo;Hello, World&amp;rdquo; | go run main.go&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CopyN 函数的签名：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func CopyN(dst Writer, src Reader, n int64) (written int64, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;函数文档：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CopyN 将 n 个字节从 src 复制到 dst。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回复制的字节数以及在复制时遇到的最早的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于 Read 可以返回要求的全部数量及一个错误（包括 EOF），因此 CopyN 也能如此。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 dst 实现了 ReaderFrom 接口，复制操作也就会使用它来实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;io.CopyN(os.Stdout, strings.NewReader(&amp;quot;Go语言学习园地&amp;quot;), 8)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Go语言ReadAtLeast 和 ReadFull 函数ReadAtLeast 函数的签名：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;函数文档：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReadAtLeast 将 r 读取到 buf 中，直到读了最少 min 个字节为止。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回复制的字节数，如果读取的字节较少，还会返回一个错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若没有读取到字节，错误就只是 EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果一个 EOF 发生在读取了少于 min 个字节之后，ReadAtLeast 就会返回 ErrUnexpectedEOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 min 大于 buf 的长度，ReadAtLeast 就会返回 ErrShortBuffer。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于返回值，当且仅当 err == nil 时，才有 n &amp;gt;= min。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一般可能不太会用到这个函数。使用时需要注意返回的error判断。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReadFull 函数的签名：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ReadFull(r Reader, buf []byte) (n int, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;函数文档：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReadFull 精确地从 r 中将 len(buf) 个字节读取到 buf 中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回复制的字节数，如果读取的字节较少，还会返回一个错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若没有读取到字节，错误就只是 EOF。如果一个 EOF 发生在读取了一些但不是所有的字节后，ReadFull 就会返回 ErrUnexpectedEOF&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于返回值，当且仅当 err == nil 时，才有 n == len(buf)。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意该函数和ReadAtLeast的区别：ReadFull 将buf读满；而ReadAtLeast是最少读取min个字节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;WriteString 函数这是为了方便写入string类型提供的函数，函数签名：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func WriteString(w Writer, s string) (n int, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当 w 实现了 WriteString 方法时，直接调用该方法，否则执行w.Write([]byte(s))。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;MultiReader 和 MultiWriter 函数这两个函数的定义分别是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func MultiReader(readers ...Reader) Reader&#xA;func MultiWriter(writers ...Writer) Writer&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;它们接收多个Reader或Writer，返回一个Reader或Writer。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们可以猜想到这两个函数就是操作多个Reader或Writer就像操作一个。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;事实上，在io包中定义了两个非导出类型：mutilReader和multiWriter，它们分别实现了io.Reader和io.Writer接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;类型定义为：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type multiReader struct {&#xA;    readers []Reader&#xA;}&#xA;&#xA;type multiWriter struct {&#xA;    writers []Writer&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;对于这两种类型对应的实现方法（Read和Write方法）的使用，我们通过例子来演示。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;MultiReader的使用：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;readers := []io.Reader{&#xA;    strings.NewReader(&amp;quot;from strings reader&amp;quot;),&#xA;    bytes.NewBufferString(&amp;quot;from bytes buffer&amp;quot;),&#xA;}&#xA;reader := io.MultiReader(readers...)&#xA;data := make([]byte, 0, 1024)&#xA;var (&#xA;    err error&#xA;    n   int&#xA;)&#xA;for err != io.EOF {&#xA;    tmp := make([]byte, 512)&#xA;    n, err = reader.Read(tmp)&#xA;    if err == nil {&#xA;    data = append(data, tmp[:n]...)&#xA;    } else {&#xA;    if err != io.EOF {&#xA;        panic(err)&#xA;    }&#xA;    }&#xA;}&#xA;fmt.Printf(&amp;quot;%s\n&amp;quot;, data)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;from strings readerfrom bytes buffer代码中首先构造了一个io.Reader的slice，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由 strings.Reader 和 bytes.Buffer 两个实例组成，然后通过MultiReader得到新的Reader，循环读取新Reader中的内容。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从输出结果可以看到，第一次调用Reader的Read方法获取到的是slice中第一个元素的内容&lt;/p&gt;&#xA;&#xA;&lt;p&gt;……也就是说，MultiReader只是逻辑上将多个Reader组合起来，并不能通过调用一次Read方法获取所有Reader的内容。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在所有的Reader内容都被读完后，Reader会返回EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;MultiWriter的使用：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;file, err := os.Create(&amp;quot;tmp.txt&amp;quot;)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;defer file.Close()&#xA;writers := []io.Writer{&#xA;    file,&#xA;    os.Stdout,&#xA;}&#xA;writer := io.MultiWriter(writers...)&#xA;writer.Write([]byte(&amp;quot;Go语言学习园地&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这段程序执行后在生成tmp.txt文件，同时在文件和屏幕中都输出：Go语言学习园地。这和Unix中的tee命令类似。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;动手试试&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Go实现Unix中tee命令的功能很简单吧。multiWriter的write方法是如何实现的？有兴趣可以自己实现一个，然后对着源码比较一下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;TeeReader函数函数签名如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func TeeReader(r Reader, w Writer) ReaderTeeReader 返回一个 Reader，它将从 r 中读到的数据写入 w 中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所有经由它处理的从 r 的读取都匹配于对应的对 w 的写入。它没有内部缓存，即写入必须在读取完成前完成。任何在写入时遇到的错误都将作为读取错误返回。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，我们通过Reader读取内容后，会自动写入到Writer中去。例子代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;reader := io.TeeReader(strings.NewReader(&amp;quot;Go语言学习园地&amp;quot;), os.Stdout)&#xA;reader.Read(make([]byte, 20))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出结果：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Go语言学习园地这种功能的实现其实挺简单，无非是在Read完后执行Write。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;至此，io所有接口、类型和函数都讲解完成。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-反射篇</title>
      <link>http://www.nljb.net/default/Golang-%E5%8F%8D%E5%B0%84%E7%AF%87/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Go语言的基本语法的使用已经在前几篇陆陆续续学完了，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面可能想写一些Go的标准库的使用了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;先是reflect库。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;reflect库的godoc在http://golang.org/pkg/reflect/&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;Type和Value&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先，reflect包有两个数据类型我们必须知道，一个是Type，一个是Value。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Type就是定义的类型的一个数据类型，Value是值的类型&lt;/p&gt;&#xA;&#xA;&lt;p&gt;具体的Type和Value里面包含的方法就要看文档了：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://golang.org/pkg/reflect/&#34;&gt;http://golang.org/pkg/reflect/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import(&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;reflect&amp;quot;&#xA;)&#xA;&#xA;type MyStruct struct{&#xA;    name string&#xA;}&#xA;&#xA;func (this *MyStruct)GetName() string {&#xA;    return this.name&#xA;}&#xA;&#xA;func main() {&#xA;    s := &amp;quot;this is string&amp;quot;&#xA;    fmt.Println(reflect.TypeOf(s))&#xA;    fmt.Println(&amp;quot;-------------------&amp;quot;)&#xA;&#xA;    fmt.Println(reflect.ValueOf(s))&#xA;    var x float64 = 3.4&#xA;    fmt.Println(reflect.ValueOf(x))&#xA;    fmt.Println(&amp;quot;-------------------&amp;quot;)&#xA;&#xA;    a := new(MyStruct)&#xA;    a.name = &amp;quot;yejianfeng&amp;quot;&#xA;    typ := reflect.TypeOf(a)&#xA;&#xA;    fmt.Println(typ.NumMethod())&#xA;    fmt.Println(&amp;quot;-------------------&amp;quot;)&#xA;&#xA;    b := reflect.ValueOf(a).MethodByName(&amp;quot;GetName&amp;quot;).Call([]reflect.Value{})&#xA;    fmt.Println(b[0])&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出结果：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-反射篇/1_0.jpg&#34; alt=&#34;&#34; width=&#34;300&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个程序看到几点：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1 TypeOf和ValueOf是获取Type和Value的方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2 ValueOf返回的&lt;float64 Value&gt;是为了说明这里的value是float643 第三个b的定义实现了php中的string-&amp;gt;method的方法，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;为什么返回的是reflect.Value[]数组呢？当然是因为Go的函数可以返回多个值的原因了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Value的方法和属性&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-反射篇/2.jpg&#34; alt=&#34;&#34; width=&#34;300&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;好了，我们看到Value的Type定义了这么多Set方法：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面看这么个例子：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import(&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;reflect&amp;quot;&#xA;)&#xA;&#xA;type MyStruct struct{&#xA;    name string&#xA;}&#xA;&#xA;func (this *MyStruct)GetName() string {&#xA;    return this.name&#xA;}&#xA;&#xA;func main() {&#xA;    fmt.Println(&amp;quot;--------------&amp;quot;)&#xA;    var a MyStruct&#xA;    b := new(MyStruct)&#xA;    fmt.Println(reflect.ValueOf(a))&#xA;    fmt.Println(reflect.ValueOf(b))&#xA;&#xA;    fmt.Println(&amp;quot;--------------&amp;quot;)&#xA;    a.name = &amp;quot;yejianfeng&amp;quot;&#xA;    b.name = &amp;quot;yejianfeng&amp;quot;&#xA;    val := reflect.ValueOf(a).FieldByName(&amp;quot;name&amp;quot;)&#xA;&#xA;    //painc: val := reflect.ValueOf(b).FieldByName(&amp;quot;name&amp;quot;)&#xA;    fmt.Println(val)&#xA;&#xA;    fmt.Println(&amp;quot;--------------&amp;quot;)&#xA;    fmt.Println(reflect.ValueOf(a).FieldByName(&amp;quot;name&amp;quot;).CanSet())&#xA;    fmt.Println(reflect.ValueOf(&amp;amp;(a.name)).Elem().CanSet())&#xA;&#xA;    fmt.Println(&amp;quot;--------------&amp;quot;)&#xA;    var c string = &amp;quot;yejianfeng&amp;quot;&#xA;    p := reflect.ValueOf(&amp;amp;c)&#xA;    fmt.Println(p.CanSet())   //false&#xA;    fmt.Println(p.Elem().CanSet())  //true&#xA;    p.Elem().SetString(&amp;quot;newName&amp;quot;)&#xA;    fmt.Println(c)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;返回：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-反射篇/3.jpg&#34; alt=&#34;&#34; width=&#34;300&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这段代码能有一些事情值得琢磨：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1 为什么a和b的ValueOf返回的是不一样的？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;a是一个结构，b是一个指针。好吧，在Go中，指针的定义和C中是一样的。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2 reflect.ValueOf(a).FieldByName(&amp;ldquo;name&amp;rdquo;)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;这是一个绕路的写法，其实和a.name是一样的意思，主要是要说明一下Value.FieldByName的用法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3 val := reflect.ValueOf(b).FieldByName(&amp;ldquo;name&amp;rdquo;) 是有error的，为什么？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;b是一个指针，指针的ValueOf返回的是指针的Type，它是没有Field的，所以也就不能使用FieldByName&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;4 fmt.Println(reflect.ValueOf(a).FieldByName(&amp;ldquo;name&amp;rdquo;).CanSet())为什么是false?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;看文档中的解释：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;好吧，什么是addressable，and was not obtained by the use of unexported struct fields?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CanSet当Value是可寻址的时候，返回true，否则返回false&lt;/p&gt;&#xA;&#xA;&lt;p&gt;看到第二个c和p的例子，我们可以这么理解：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当前面的CanSet是一个指针的时候（p）它是不可寻址的，但是当是p.Elem()(实际上就是*p)，它就是可以寻址的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个确实有点绕。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;总而言之，reflect包是开发过程中几乎必备的包之一。能合理和熟练使用它对开发有很大的帮助&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Date-命令设置系统时间的方法</title>
      <link>http://www.nljb.net/default/Date-%E5%91%BD%E4%BB%A4%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;名称 : date&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用权限 : 所有使用者&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用方式 :&lt;/p&gt;&#xA;&#xA;&lt;p&gt;date&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[-u]&#xA;[-d datestr]&#xA;[-s datestr]&#xA;[--utc]&#xA;[--universal]&#xA;[--date=datestr] &#xA;[--set=datestr] &#xA;[--help] &#xA;[--version] &#xA;[+FORMAT] &#xA;[MMDDhhmm[[CC]YY][.ss]]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;说明 :&lt;/p&gt;&#xA;&#xA;&lt;p&gt;date 可以用来显示或设定系统的日期与时间&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其中可用的标记列表如下 :&lt;/p&gt;&#xA;&#xA;&lt;p&gt;时间方面 :&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;% : 印出 %&#xA;%n : 下一行&#xA;%t : 跳格&#xA;%H : 小时(00..23)&#xA;%I : 小时(01..12)&#xA;%k : 小时(0..23)&#xA;%l : 小时(1..12)&#xA;%M : 分钟(00..59)&#xA;%p : 显示本地 AM 或 PM&#xA;%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)&#xA;%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数&#xA;%S : 秒(00..61)&#xA;%T : 直接显示时间 (24 小时制)&#xA;%X : 相当于 %H:%M:%S&#xA;%Z : 显示时区&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;日期方面 :&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;%a : 星期几 (Sun..Sat)&#xA;%A : 星期几 (Sunday..Saturday)&#xA;%b : 月份 (Jan..Dec)&#xA;%B : 月份 (January..December)&#xA;%c : 直接显示日期与时间&#xA;%d : 日 (01..31)&#xA;%D : 直接显示日期 (mm/dd/yy)&#xA;%h : 同 %b&#xA;%j : 一年中的第几天 (001..366)&#xA;%m : 月份 (01..12)&#xA;%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)&#xA;%w : 一周中的第几天 (0..6)&#xA;%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)&#xA;%x : 直接显示日期 (mm/dd/yy)&#xA;%y : 年份的最后两位数字 (00.99)&#xA;%Y : 完整年份 (0000..9999)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;若是不以加号作为开头，则表示要设定时间&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而时间格式为 MMDDhhmm[[CC]YY][.ss]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其中 MM 为月份，DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;参数 :&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-d datestr : 显示 datestr 中所设定的时间 (非系统时间)&#xA;--help : 显示辅助讯息&#xA;-s datestr : 将系统时间设为 datestr 中所设定的时间&#xA;-u : 显示目前的格林威治时间&#xA;--version : 显示版本编号&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;例子 :&lt;/p&gt;&#xA;&#xA;&lt;p&gt;显示时间后跳行，再显示目前日期 :&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date &#39;+%T%n%D&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;显示月份与日数 :&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date &#39;+%B %d&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;显示日期与设定时间(12:34:56) :&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date --date &#39;12:34:56&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意 :&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当你不希望出现无意义的 0 时(比如说 &lt;sup&gt;1999&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;/07)，则可以在标记中插入 - 符号&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如说 date &amp;lsquo;+%-H:%-M:%-S&amp;rsquo; 会把时分秒中无意义的 0 给去掉&lt;/p&gt;&#xA;&#xA;&lt;p&gt;像是原本的 08:09:04 会变为 8:9:4。另外，只有取得权限者(比如说 root)才能设定系统时间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当你以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样下次重新开机时系统时间才会持续抱持最新的正确值。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;例子：修改日期时间&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在命令行输入:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;显示当前时间 Fri Aug 3 14:15:16 CST 2007&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date -s &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;按字符串方式修改时间&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以只修改日期,不修改时间,输入: date -s 2007-08-03&lt;/p&gt;&#xA;&#xA;&lt;p&gt;只修改时间,输入:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date -s 14:15:00&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;同时修改日期时间,注意要加双引号,日期与时间之间有一空格,输入:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date -s &amp;quot;2007-08-03 14:15:00&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改完后,记得输入:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;clock -w &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;把系统时间写入CMOS&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>3G-网卡适配</title>
      <link>http://www.nljb.net/default/3G-%E7%BD%91%E5%8D%A1%E9%80%82%E9%85%8D/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Content:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一、查看上网卡信息&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# pacman -S usbutils&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;插入上网卡前后比对，我的信息如下&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#lsusb&#xA;Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub&#xA;Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub&#xA;Bus 001 Device 002: ID 8087:0020 Intel Corp. Integrated Rate Matching Hub&#xA;Bus 002 Device 002: ID 8087:0020 Intel Corp. Integrated Rate Matching Hub&#xA;Bus 001 Device 003: ID 04fc:2801 Sunplus Technology Co., Ltd &#xA;Bus 001 Device 004: ID 20b9:1682  &#xA;Bus 002 Device 003: ID 192f:0916 Avago Technologies, Pte.&#xA;&#xA;# lsusb&#xA;Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub&#xA;Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub&#xA;Bus 001 Device 002: ID 8087:0020 Intel Corp. Integrated Rate Matching Hub&#xA;Bus 002 Device 002: ID 8087:0020 Intel Corp. Integrated Rate Matching Hub&#xA;Bus 001 Device 003: ID 04fc:2801 Sunplus Technology Co., Ltd &#xA;Bus 001 Device 005: ID 05c6:1000 Qualcomm, Inc. Mass Storage Device&#xA;Bus 002 Device 003: ID 192f:0916 Avago Technologies, Pte.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以看出 Bus 001 Device 005: ID 05c6:1000 Qualcomm, Inc. Mass Storage Device 这个就是上网卡的信息了&lt;/p&gt;&#xA;&#xA;&lt;p&gt;看到上网卡的 idVendor 05c6 和 idProduct 1000，格式是 idVendor:idProduct&lt;/p&gt;&#xA;&#xA;&lt;p&gt;二、把上网卡从cd-rom设备转换到modem设备&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# pacman -S usb_modeswitch&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;安装好后到/etc/usb_modeswitch.d/目录运行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#head -n 2 * 就可以看到当前版本usb_modeswitch支持的3g上网卡的型号了&#xA;&#xA;# usb_modeswitch -c /etc/usb_modeswitch.setup&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;试试成功不，如果不成功，那么试试这个&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# usb_modeswitch -v 05c6 -p 1000 -M 5553424312345678000000000000061b000000020000000000000000000000 -R 1&#xA;# modprobe usbserial vendor=0x05c6 product=0x1000&#xA;# ls /dev/tty*&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;看能不能看的到ttyUSB0这些，如果有则继续，如果无请另寻它法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;三、开始拨号&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# pacman -S wvdial&#xA;&#xA;# wvdialconf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;会自动生成 /etc/wvdial.conf&lt;/p&gt;&#xA;&#xA;&lt;p&gt;再添加下面几行进去&lt;/p&gt;&#xA;&#xA;&lt;p&gt;（电信cdma的例子，电话号码：#777 用户名：(或是card) 密码: vnet.mobi (或是card)）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Phone = #777&#xA;Username = &#xA;Password = vnet.mobi&#xA;Stupid Mode = 1&#xA;&#xA;#wvdial&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-绘图技术-image-draw-包介绍</title>
      <link>http://www.nljb.net/default/Golang-%E7%BB%98%E5%9B%BE%E6%8A%80%E6%9C%AF-image-draw-%E5%8C%85%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;image/draw 包仅仅定义了一个操作：通过可选的蒙版图（mask image）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;把一个原始图片绘制到目标图片上，这个操作是出奇的灵活，可以优雅和高效的执行很多常见的图像处理任务。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Draw calls DrawMask with a nil mask.&#xA;func Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point, op Op)&#xA;func DrawMask(dst Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op Op)&#xA;第一个函数Draw是没有使用蒙版mask的调用方法，它内部其实就是调用的mask为 nil的方法。&#xA;&#xA;它的参数描述如下：&#xA;dst  绘图的背景图。&#xA;r 是背景图的绘图区域&#xA;src 是要绘制的图&#xA;sp 是 src 对应的绘图开始点（绘制的大小 r变量定义了）&#xA;mask 是绘图时用的蒙版，控制替换图片的方式。&#xA;mp 是绘图时蒙版开始点（绘制的大小 r变量定义了）&#xA;op Op is a Porter-Duff compositing operator.  参考文章：http://blog.csdn.net/ison81/article/details/5468763 &#xA;Porter-Duff 等式12种规则可以看这篇博客：http://www.blogjava.net/onedaylover/archive/2008/01/16/175675.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;下图就是几个相关的例子：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;mask 蒙版是渐变&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图技术-image-draw-包介绍/1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;给一个矩形填充颜色&#xA;使用 Draw方法的逻辑效果图：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图技术-image-draw-包介绍/2.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;m := image.NewRGBA(image.Rect(0, 0, 640, 480))&#xA;blue := color.RGBA{0, 0, 255, 255}&#xA;draw.Draw(m, m.Bounds(), &amp;amp;image.Uniform{blue}, image.ZP, draw.Src)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;拷贝图片的一部分&#xA;效果特效如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图技术-image-draw-包介绍/3.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;r := image.Rectangle{dp, dp.Add(sr.Size())}  // 获得更换区域&#xA;draw.Draw(dst, r, src, sr.Min, draw.Src)&#xA;&#xA;如果是复制整个图片，则更简单：&#xA;&#xA;sr = src.Bounds()         // 获取要复制图片的尺寸&#xA;r := sr.Sub(sr.Min).Add(dp)   // 目标图的要剪切区域&#xA;draw.Draw(dst, r, src, sr.Min, draw.Src)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;图片滚动效果&#xA;效果如下图:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图技术-image-draw-包介绍/4.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;假设我们需要把图片 m 上移20个像素.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;b := m.Bounds()&#xA;p := image.Pt(0, 20)&#xA;// Note that even though the second argument is b,&#xA;// the effective rectangle is smaller due to clipping.&#xA;draw.Draw(m, b, m, b.Min.Add(p), draw.Src)&#xA;dirtyRect := b.Intersect(image.Rect(b.Min.X, b.Max.Y-20, b.Max.X, b.Max.Y))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;把一个图片转成RGBA格式&#xA;效果图:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图技术-image-draw-包介绍/5.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;b := src.Bounds()&#xA;m := image.NewRGBA(b)&#xA;draw.Draw(m, b, src, b.Min, draw.Src)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过蒙版画特效&#xA;效果图&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图技术-image-draw-包介绍/6.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type circle struct {&#xA;    p image.Point&#xA;    r int&#xA;}&#xA;&#xA;func (c *circle) ColorModel() color.Model {&#xA;    return color.AlphaModel&#xA;}&#xA;&#xA;func (c *circle) Bounds() image.Rectangle {&#xA;    return image.Rect(c.p.X-c.r, c.p.Y-c.r, c.p.X+c.r, c.p.Y+c.r)&#xA;}&#xA;&#xA;func (c *circle) At(x, y int) color.Color {&#xA;    xx, yy, rr := float64(x-c.p.X)+0.5, float64(y-c.p.Y)+0.5, float64(c.r)&#xA;    if xx*xx+yy*yy &amp;lt; rr*rr {&#xA;    return color.Alpha{255}&#xA;    }&#xA;    return color.Alpha{0}&#xA;}&#xA;&#xA;draw.DrawMask(dst, dst.Bounds(), src, image.ZP, &amp;amp;circle{p, r}, image.ZP, draw.Over)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意,一个image对象只需要实现下面几个就可,这也就是Go接口强大的地方.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Image interface {&#xA;    // ColorModel returns the Image&#39;s color model.&#xA;    ColorModel() color.Model&#xA;    // Bounds returns the domain for which At can return non-zero color.&#xA;    // The bounds do not necessarily contain the point (0, 0).&#xA;    Bounds() Rectangle&#xA;    // At returns the color of the pixel at (x, y).&#xA;    // At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid.&#xA;    // At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one.&#xA;    At(x, y int) color.Color&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;画一个字体&#xA;效果图，画一个蓝色背景的字体。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图技术-image-draw-包介绍/7.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关伪代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;src := &amp;amp;image.Uniform{color.RGBA{0, 0, 255, 255}}&#xA;mask := theGlyphImageForAFont()&#xA;mr := theBoundsFor(glyphIndex)&#xA;draw.DrawMask(dst, mr.Sub(mr.Min).Add(p), src, image.ZP, mask, mr.Min, draw.Over)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面例子完整的代码请看：&#xA;&lt;a href=&#34;http://golang.org/doc/progs/image_draw.go&#34;&gt;http://golang.org/doc/progs/image_draw.go&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;参考：&#xA;&lt;a href=&#34;http://blog.golang.org/go-imagedraw-package&#34;&gt;http://blog.golang.org/go-imagedraw-package&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-绘图基础-绘制简单图形</title>
      <link>http://www.nljb.net/default/Golang-%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80-%E7%BB%98%E5%88%B6%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2/</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;上一节的例子效果是通过设置每一个点的的RGBA属性来实现的,这是最基础的方式，通过这种方式我们可以绘制任意形状的图形。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1、设置点的颜色一个简单例子：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;效果如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图基础-绘制简单图形/1_0.jpg&#34; alt=&#34;&#34; width=&#34;140&#34; height=&#34;240&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码如下，跟最初我们的代码唯一不同的是设置点颜色时，多了一个条件判断语句：if x%8 == 0 ，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码如下，这种情况下，其实我们通过算法简单的实现了画垂直线的效果：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/color&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    const (&#xA;    dx = 300&#xA;    dy = 500&#xA;    )&#xA;&#xA;    // 需要保存的文件&#xA;    imgcounter := 123&#xA;    imgfile, _ := os.Create(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter))&#xA;    defer imgfile.Close()&#xA;&#xA;    // 新建一个 指定大小的 RGBA位图&#xA;    img := image.NewNRGBA(image.Rect(0, 0, dx, dy))&#xA;&#xA;    for y := 0; y &amp;lt; dy; y++ {&#xA;    for x := 0; x &amp;lt; dx; x++ {&#xA;&#xA;        if x%8 == 0 {&#xA;        // 设置某个点的颜色，依次是 RGBA&#xA;        img.Set(x, y, color.RGBA{uint8(x % 256), uint8(y % 256), 0, 255})&#xA;        }&#xA;    }&#xA;    }&#xA;&#xA;    // 以PNG格式保存文件&#xA;    err := png.Encode(imgfile, img)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;比如下面一个函数就是简单的画水平线的代码函数。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 画 水平线&#xA;func (img *Image) drawHorizLine(color color.Color, fromX, toX, y int) {&#xA;    // 遍历画每个点&#xA;    for x := fromX; x &amp;lt;= toX; x++ {&#xA;    img.Set(x, y, color)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2、划线&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Golang 官方库没有提供划线的库，不过既然有了画点的方法，我们就可以根据一套算法画出点&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面的效果和代码是按照 Bresenham&amp;rsquo;s line algorithm 算法画的线。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm&#34;&gt;http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个算法画的线简单可以用下面图来标示：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图基础-绘制简单图形/2_0.jpg&#34; alt=&#34;&#34; width=&#34;240&#34; height=&#34;120&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面演示代码画出来的效果图如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意，为了便于看到效果， 图的左右都画了一条竖线，斜线是按照上面算法画出来的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图基础-绘制简单图形/3_0.jpg&#34; alt=&#34;&#34; width=&#34;140&#34; height=&#34;240&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里的代码借鉴了下面的代码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/akavel/polyclip-go/blob/9b07bdd6e0a784f7e5d9321bff03425ab3a98beb/polyutil/draw.go&#34;&gt;https://github.com/akavel/polyclip-go/blob/9b07bdd6e0a784f7e5d9321bff03425ab3a98beb/polyutil/draw.go&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/color&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;// Putpixel describes a function expected to draw a point on a bitmap at (x, y) coordinates.&#xA;type Putpixel func(x, y int)&#xA;&#xA;// 求绝对值&#xA;func abs(x int) int {&#xA;    if x &amp;gt;= 0 {&#xA;    return x&#xA;    }&#xA;    return -x&#xA;}&#xA;&#xA;// Bresenham&#39;s algorithm, http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm&#xA;// https://github.com/akavel/polyclip-go/blob/9b07bdd6e0a784f7e5d9321bff03425ab3a98beb/polyutil/draw.go&#xA;// TODO: handle int overflow etc.&#xA;func drawline(x0, y0, x1, y1 int, brush Putpixel) {&#xA;    dx := abs(x1 - x0)&#xA;    dy := abs(y1 - y0)&#xA;    sx, sy := 1, 1&#xA;    if x0 &amp;gt;= x1 {&#xA;    sx = -1&#xA;    }&#xA;    if y0 &amp;gt;= y1 {&#xA;    sy = -1&#xA;    }&#xA;    err := dx - dy&#xA;&#xA;    for {&#xA;    brush(x0, y0)&#xA;    if x0 == x1 &amp;amp;&amp;amp; y0 == y1 {&#xA;        return&#xA;    }&#xA;    e2 := err * 2&#xA;    if e2 &amp;gt; -dy {&#xA;        err -= dy&#xA;        x0 += sx&#xA;    }&#xA;    if e2 &amp;lt; dx {&#xA;        err += dx&#xA;        y0 += sy&#xA;    }&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;    const (&#xA;    dx = 300&#xA;    dy = 500&#xA;    )&#xA;&#xA;    // 需要保存的文件&#xA;&#xA;    // 新建一个 指定大小的 RGBA位图&#xA;    img := image.NewNRGBA(image.Rect(0, 0, dx, dy))&#xA;&#xA;    drawline(5, 5, dx-8, dy-10, func(x, y int) {&#xA;    img.Set(x, y, color.RGBA{uint8(x), uint8(y), 0, 255})&#xA;    })&#xA;&#xA;    // 左右都画一条竖线&#xA;    for i := 0; i &amp;lt; dy; i++ {&#xA;    img.Set(0, i, color.Black)&#xA;    img.Set(dx-1, i, color.Black)&#xA;    }&#xA;&#xA;    imgcounter := 250&#xA;    imgfile, _ := os.Create(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter))&#xA;    defer imgfile.Close()&#xA;&#xA;    // 以PNG格式保存文件&#xA;    err := png.Encode(imgfile, img)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3、特殊图形&#xA;这次绘制出来的图形效果如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图基础-绘制简单图形/4_0.jpg&#34; alt=&#34;&#34; width=&#34;240&#34; height=&#34;240&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里的代码借鉴了下面的代码：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/xMachinae/pallinda13/blob/master/uppg2.go&#34;&gt;https://github.com/xMachinae/pallinda13/blob/master/uppg2.go&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA; import (&#xA;     &amp;quot;fmt&amp;quot;&#xA;     &amp;quot;image&amp;quot;&#xA;     &amp;quot;image/png&amp;quot;&#xA;     &amp;quot;log&amp;quot;&#xA;     &amp;quot;os&amp;quot;&#xA; )&#xA;&#xA; func Pic(dx, dy int) [][]uint8 {&#xA;     pic := make([][]uint8, dx)&#xA;     for i := range pic {&#xA;     pic[i] = make([]uint8, dy)&#xA;     for j := range pic[i] {&#xA;         pic[i][j] = uint8(i * j)&#xA;     }&#xA;     }&#xA;     return pic&#xA; }&#xA;&#xA; func main() {&#xA;     Show(Pic)&#xA; }&#xA;&#xA; func Show(f func(int, int) [][]uint8) {&#xA;     const (&#xA;     dx = 256&#xA;     dy = 256&#xA;     )&#xA;     data := f(dx, dy) // 图片坐标点的颜色二维数组。&#xA;     m := image.NewNRGBA(image.Rect(0, 0, dx, dy))&#xA;     for y := 0; y &amp;lt; dy; y++ {&#xA;     for x := 0; x &amp;lt; dx; x++ {&#xA;         v := data[y][x]&#xA;         i := y*m.Stride + x*4&#xA;         m.Pix[i] = v&#xA;         m.Pix[i+1] = v&#xA;         m.Pix[i+2] = 255&#xA;         m.Pix[i+3] = 255&#xA;     }&#xA;     }&#xA;     ShowImage(m)&#xA; }&#xA;&#xA; func ShowImage(m image.Image) {&#xA;&#xA;     // 需要保存的文件&#xA;     imgcounter := 1234&#xA;     imgfile, _ := os.Create(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter))&#xA;     defer imgfile.Close()&#xA;&#xA;     // 以PNG格式保存文件&#xA;     err := png.Encode(imgfile, m)&#xA;     if err != nil {&#xA;     log.Fatal(err)&#xA;     }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;更复杂的算法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如下面代码实现了图片简单的上下左右翻转的功能。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;图片旋转的算法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mpl/goexif/blob/a588a5577cedfda71e3645f8137c38495f308f6c/exif/rotate_test.go&#34;&gt;https://github.com/mpl/goexif/blob/a588a5577cedfda71e3645f8137c38495f308f6c/exif/rotate_test.go&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-绘图基础-不同的输出源</title>
      <link>http://www.nljb.net/default/Golang-%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80-%E4%B8%8D%E5%90%8C%E7%9A%84%E8%BE%93%E5%87%BA%E6%BA%90/</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;先看一个简单代码， 它执行后会产生下面的300*500的png图片文件：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图基础-不同的输出源/1_0.jpg&#34; alt=&#34;&#34; width=&#34;140&#34; height=&#34;240&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA; import (&#xA;     &amp;quot;fmt&amp;quot;&#xA;     &amp;quot;image&amp;quot;&#xA;     &amp;quot;image/color&amp;quot;&#xA;     &amp;quot;image/png&amp;quot;&#xA;     &amp;quot;log&amp;quot;&#xA;     &amp;quot;os&amp;quot;&#xA; )&#xA;&#xA; func main() {&#xA;     const (&#xA;     dx = 300&#xA;     dy = 500&#xA;     )&#xA;&#xA;     // 需要保存的文件&#xA;     imgcounter := 123&#xA;     imgfile, _ := os.Create(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter))&#xA;     defer imgfile.Close()&#xA;&#xA;     // 新建一个 指定大小的 RGBA位图&#xA;     img := image.NewNRGBA(image.Rect(0, 0, dx, dy))&#xA;&#xA;     for y := 0; y &amp;lt; dy; y++ {&#xA;     for x := 0; x &amp;lt; dx; x++ {&#xA;         // 设置某个点的颜色，依次是 RGBA&#xA;         img.Set(x, y, color.RGBA{uint8(x % 256), uint8(y % 256), 0, 255})&#xA;     }&#xA;     }&#xA;&#xA;     // 以PNG格式保存文件&#xA;     err := png.Encode(imgfile, img)&#xA;     if err != nil {&#xA;     log.Fatal(err)&#xA;     }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们再看一个代码，以http文件流的方式展示图片，效果如下:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图基础-不同的输出源/2_0.jpg&#34; alt=&#34;&#34; width=&#34;140&#34; height=&#34;240&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/color&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;func pic(w http.ResponseWriter, req *http.Request) {&#xA;    const (&#xA;    dx = 300&#xA;    dy = 500&#xA;    )&#xA;&#xA;    // 新建一个 指定大小的 RGBA位图&#xA;    img := image.NewNRGBA(image.Rect(0, 0, dx, dy))&#xA;&#xA;    for y := 0; y &amp;lt; dy; y++ {&#xA;    for x := 0; x &amp;lt; dx; x++ {&#xA;        // 设置某个点的颜色，依次是 RGBA&#xA;        img.Set(x, y, color.RGBA{uint8(x % 256), uint8(y % 256), 0, 255})&#xA;    }&#xA;    }&#xA;&#xA;    // 图片流方式输出&#xA;    w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;image/png&amp;quot;)&#xA;    png.Encode(w, img)&#xA;}&#xA;&#xA;func main() {&#xA;    http.HandleFunc(&amp;quot;/&amp;quot;, pic)&#xA;    s := &amp;amp;http.Server{&#xA;    Addr:           &amp;quot;:82&amp;quot;,&#xA;    ReadTimeout:    30 * time.Second,&#xA;    WriteTimeout:   30 * time.Second,&#xA;    MaxHeaderBytes: 1 &amp;lt;&amp;lt; 20}&#xA;    s.ListenAndServe()&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过两种方式来展示图片,我们可以看到,上面两个代码最大的区别就是输出源不一样,&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一个是到文件,一个是到http流. 而我们的代码也很清晰的展示了这两种方式只需要修改对应的实现即可.其他代码是没有变化的.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里代码中的 image.NewNRGBA 返回的 image对象是一个内存中的图片。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-官方图片库</title>
      <link>http://www.nljb.net/default/Golang-%E5%AE%98%E6%96%B9%E5%9B%BE%E7%89%87%E5%BA%93/</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Golang 的图片出来通过提供操作每一个像素点设置颜色（http://www.cnblogs.com/ghj1976/p/3441536.html）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;提供通过可选蒙版图片重叠操作 （http://www.cnblogs.com/ghj1976/p/3443638.html） 这两种基础方式&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样任何想要的效果都可以自己实现， 但是旋转、缩放等相关的图像算法也是比较麻烦的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这时候我们就需要借助官方提供的图片包处理了，图片包在：https://code.google.com/p/graphics-go&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获取方法： go get code.google.com/p/graphics-go/graphics&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它支持的几个效果举例：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;图片旋转&lt;/p&gt;&#xA;&#xA;&lt;p&gt;效果:一个旋转前,一个旋转后&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-官方图片库/1.jpg&#34; alt=&#34;&#34; width=&#34;200&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码例子：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;code.google.com/p/graphics-go/graphics&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    src, err := LoadImage(&amp;quot;348.png&amp;quot;)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    dst := image.NewRGBA(image.Rect(0, 0, 350, 400))&#xA;&#xA;    err = graphics.Rotate(dst, src, &amp;amp;graphics.RotateOptions{3.5})&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    // 需要保存的文件&#xA;    imgcounter := 123&#xA;    saveImage(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter), dst)&#xA;}&#xA;&#xA;// LoadImage decodes an image from a file.&#xA;func LoadImage(path string) (img image.Image, err error) {&#xA;    file, err := os.Open(path)&#xA;    if err != nil {&#xA;    return&#xA;    }&#xA;    defer file.Close()&#xA;    img, _, err = image.Decode(file)&#xA;    return&#xA;}&#xA;&#xA;// 保存Png图片&#xA;func saveImage(path string, img image.Image) (err error) {&#xA;    // 需要保存的文件&#xA;    imgfile, err := os.Create(path)&#xA;    defer imgfile.Close()&#xA;&#xA;    // 以PNG格式保存文件&#xA;    err = png.Encode(imgfile, img)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;代码说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;旋转的参数是顺时针旋转的弧度，弧度相关的介绍如下：(http://youthpasses.blog.51cto.com/&lt;sup&gt;2909834&lt;/sup&gt;&amp;frasl;&lt;sub&gt;799353&lt;/sub&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;每个角度对应的弧度可以看下面图。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-官方图片库/2.jpg&#34; alt=&#34;&#34; width=&#34;200&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码参考：(http://stackoverflow.com/questions/12430874/image-manipulation-in-golang)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;图片模糊处理&lt;/p&gt;&#xA;&#xA;&lt;p&gt;效果：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面一个是清晰版本，一个是模糊出来后的版本。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-官方图片库/3.jpg&#34; alt=&#34;&#34; width=&#34;200&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;仔细对比细节是可以看到模糊效果的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;code.google.com/p/graphics-go/graphics&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    src, err := LoadImage(&amp;quot;348.png&amp;quot;)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    dst := image.NewRGBA(image.Rect(0, 0, 350, 400))&#xA;&#xA;    err = graphics.Blur(dst, src, &amp;amp;graphics.BlurOptions{StdDev: 1.1})&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    // 需要保存的文件&#xA;    imgcounter := 510&#xA;    saveImage(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter), dst)&#xA;}&#xA;&#xA;// LoadImage decodes an image from a file.&#xA;func LoadImage(path string) (img image.Image, err error) {&#xA;    file, err := os.Open(path)&#xA;    if err != nil {&#xA;    return&#xA;    }&#xA;    defer file.Close()&#xA;    img, _, err = image.Decode(file)&#xA;    return&#xA;}&#xA;&#xA;// 保存Png图片&#xA;func saveImage(path string, img image.Image) (err error) {&#xA;    // 需要保存的文件&#xA;    imgfile, err := os.Create(path)&#xA;    defer imgfile.Close()&#xA;&#xA;    // 以PNG格式保存文件&#xA;    err = png.Encode(imgfile, img)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;代码说明：&#xA;模糊参数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// BlurOptions are the blurring parameters.&#xA;// StdDev is the standard deviation of the normal, higher is blurrier.&#xA;// StdDev 是正常的标准偏差， 值越大越虚化&#xA;// Size is the size of the kernel. If zero, it is set to Ceil(6 * StdDev).&#xA;//&#xA;type BlurOptions struct {&#xA;    StdDev float64&#xA;    Size   int&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;缩略图&#xA;原始图:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-官方图片库/4.jpg&#34; alt=&#34;&#34; width=&#34;200&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;确保数据完整的缩放,效果如下:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-官方图片库/5.jpg&#34; alt=&#34;&#34; width=&#34;20&#34; height=&#34;80&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;code.google.com/p/graphics-go/graphics&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    src, err := LoadImage(&amp;quot;348.png&amp;quot;)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    // 缩略图的大小&#xA;    dst := image.NewRGBA(image.Rect(0, 0, 20, 80))&#xA;&#xA;    // 产生缩略图,等比例缩放&#xA;    err = graphics.Scale(dst, src)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    // 需要保存的文件&#xA;    imgcounter := 734&#xA;    saveImage(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter), dst)&#xA;}&#xA;&#xA;// LoadImage decodes an image from a file.&#xA;func LoadImage(path string) (img image.Image, err error) {&#xA;    file, err := os.Open(path)&#xA;    if err != nil {&#xA;    return&#xA;    }&#xA;    defer file.Close()&#xA;    img, _, err = image.Decode(file)&#xA;    return&#xA;}&#xA;&#xA;// 保存Png图片&#xA;func saveImage(path string, img image.Image) (err error) {&#xA;    // 需要保存的文件&#xA;    imgfile, err := os.Create(path)&#xA;    defer imgfile.Close()&#xA;&#xA;    // 以PNG格式保存文件&#xA;    err = png.Encode(imgfile, img)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;图片数据可以丢弃的缩放效果:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-官方图片库/6.jpg&#34; alt=&#34;&#34; width=&#34;20&#34; height=80&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;code.google.com/p/graphics-go/graphics&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    src, err := LoadImage(&amp;quot;348.png&amp;quot;)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    // 缩略图的大小&#xA;    dst := image.NewRGBA(image.Rect(0, 0, 20, 80))&#xA;&#xA;    // 产生缩略图&#xA;    err = graphics.Thumbnail(dst, src)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    // 需要保存的文件&#xA;    imgcounter := 670&#xA;    saveImage(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter), dst)&#xA;}&#xA;&#xA;// LoadImage decodes an image from a file.&#xA;func LoadImage(path string) (img image.Image, err error) {&#xA;    file, err := os.Open(path)&#xA;    if err != nil {&#xA;    return&#xA;    }&#xA;    defer file.Close()&#xA;    img, _, err = image.Decode(file)&#xA;    return&#xA;}&#xA;&#xA;// 保存Png图片&#xA;func saveImage(path string, img image.Image) (err error) {&#xA;    // 需要保存的文件&#xA;    imgfile, err := os.Create(path)&#xA;    defer imgfile.Close()&#xA;&#xA;    // 以PNG格式保存文件&#xA;    err = png.Encode(imgfile, img)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;更多相关资料请看下面地址:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://code.google.com/p/graphics-go/source/browse/graphics/?r=9a6eb915f43de825cd2a26c8b8866422d0a3f2ec&#34;&gt;https://code.google.com/p/graphics-go/source/browse/graphics/?r=9a6eb915f43de825cd2a26c8b8866422d0a3f2ec&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-字体-FreeType-go</title>
      <link>http://www.nljb.net/default/Golang-%E5%AD%97%E4%BD%93-FreeType-go/</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;FreeType库（http://www.freetype.org/）是一个完全免费(开源)的、高质量的且可移植的字体引擎&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它提供统一的接口来访问多种字体格式文件，包括TrueType, OpenType, Type1, CID, CFF, Windows FON/FNT, X11 PCF等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;支持单色位图、反走样位图的渲染。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;freetype-go就是用go语言实现了FreeType驱动。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它的项目地址： &lt;a href=&#34;https://code.google.com/p/freetype-go&#34;&gt;https://code.google.com/p/freetype-go&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面是使用它绘制的一个字体效果图：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-字体-FreeType-go/4bed2e738bd4b31cd3dc1d1f85d6277f9f2ff8b6.jpg&#34; alt=&#34;&#34; width=&#34;100&#34; height=&#34;80&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;code.google.com/p/freetype-go/freetype&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/color&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;io/ioutil&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;const (&#xA;    dx       = 100         // 图片的大小 宽度&#xA;    dy       = 40          // 图片的大小 高度&#xA;    fontFile = &amp;quot;RAVIE.TTF&amp;quot; // 需要使用的字体文件&#xA;    fontSize = 20          // 字体尺寸&#xA;    fontDPI  = 72          // 屏幕每英寸的分辨率&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    // 需要保存的文件&#xA;    imgcounter := 123&#xA;    imgfile, _ := os.Create(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter))&#xA;    defer imgfile.Close()&#xA;&#xA;    // 新建一个 指定大小的 RGBA位图&#xA;    img := image.NewNRGBA(image.Rect(0, 0, dx, dy))&#xA;&#xA;    // 画背景&#xA;    for y := 0; y &amp;lt; dy; y++ {&#xA;    for x := 0; x &amp;lt; dx; x++ {&#xA;        // 设置某个点的颜色，依次是 RGBA&#xA;        img.Set(x, y, color.RGBA{uint8(x), uint8(y), 0, 255})&#xA;    }&#xA;    }&#xA;&#xA;    // 读字体数据&#xA;    fontBytes, err := ioutil.ReadFile(fontFile)&#xA;    if err != nil {&#xA;    log.Println(err)&#xA;    return&#xA;    }&#xA;    font, err := freetype.ParseFont(fontBytes)&#xA;    if err != nil {&#xA;    log.Println(err)&#xA;    return&#xA;    }&#xA;&#xA;    c := freetype.NewContext()&#xA;    c.SetDPI(fontDPI)&#xA;    c.SetFont(font)&#xA;    c.SetFontSize(fontSize)&#xA;    c.SetClip(img.Bounds())&#xA;    c.SetDst(img)&#xA;    c.SetSrc(image.White)&#xA;&#xA;    pt := freetype.Pt(10, 10+int(c.PointToFix32(fontSize)&amp;gt;&amp;gt;8)) // 字出现的位置&#xA;&#xA;    _, err = c.DrawString(&amp;quot;ABCDE&amp;quot;, pt)&#xA;    if err != nil {&#xA;    log.Println(err)&#xA;    return&#xA;    }&#xA;&#xA;     // 以PNG格式保存文件&#xA;     err = png.Encode(imgfile, img)&#xA;     if err != nil {&#xA;     log.Fatal(err)&#xA;     }&#xA;&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-Raster-字体颜色</title>
      <link>http://www.nljb.net/default/Golang-Raster-%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2/</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;import &amp;quot;code.google.com/p/freetype-go/freetype/raster&amp;quot; &#xA;&#xA;type RGBAPainter&#xA;func NewRGBAPainter(m *image.RGBA) *RGBAPainter&#xA;func (r *RGBAPainter) Paint(ss []Span, done bool)&#xA;func (r *RGBAPainter) SetColor(c color.Color)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The raster package provides an anti-aliasing 2-D rasterizer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is part of the larger Freetype-Go suite of font-related packages&#xA;but the raster package is not specific to font rasterization&#xA;and can be used standalone without any other Freetype-Go package.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Rasterization is done by the same area/coverage accumulation algorithm as the Freetype &amp;ldquo;smooth&amp;rdquo; module&#xA;and the Anti-Grain Geometry library.&#xA;A description of the area/coverage algorithm is at &lt;a href=&#34;http://projects.tuxee.net/cl-vectors/section-the-cl-aa-algorithm&#34;&gt;http://projects.tuxee.net/cl-vectors/section-the-cl-aa-algorithm&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Error-in-service-module</title>
      <link>http://www.nljb.net/default/Error-in-service-module/</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;linux-hiuk:~ # cat  /etc/pam.d/login&#xA;#%PAM-1.0&#xA;auth     requisite      pam_nologin.so&#xA;auth     [user_unknown=ignore success=ok ignore=ignore auth_err=die default=bad]pam_securetty.so&#xA;auth     include        common-auth&#xA;account  include        common-account&#xA;password include        common-password&#xA;session  required       pam_loginuid.so&#xA;session  include        common-session&#xA;#session  required      pam_lastlog.so  nowtmp showfailed&#xA;session  optional       pam_mail.so standard&#xA;session  optional       pam_ck_connector.so&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Systemd-FAQ-简体中文</title>
      <link>http://www.nljb.net/default/Systemd-FAQ-%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87/</link>
      <pubDate>2014-07-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Systemd FAQ (简体中文)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Systemd_FAQ_(简体中文&#34;&gt;https://wiki.archlinux.org/index.php/Systemd_FAQ_(简体中文&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Systemd_FAQ_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29&#34;&gt;https://wiki.archlinux.org/index.php/Systemd_FAQ_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://blip.tv/linuxconfau/beyond-init-systemd-4715015&#34;&gt;http://blip.tv/linuxconfau/beyond-init-systemd-4715015&lt;/a&gt;   (Beyond init: systemd)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Contents&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1 常见问题&#xA;1.1 Q: 为什么控制台上会显示日志信息？&#xA;1.2 Q: 如何修改启用的可登陆的 tty 控制台（getty）数量？&#xA;1.3 Q: 怎样输出更详细的开机信息？&#xA;1.4 Q: 开机后控制台信息会被清空，如何避免？&#xA;1.5 Q: 我不用官方内核，内核版本和编译参数有什么要注意的吗？&#xA;1.6 Q: 怎样知道一个目标需要哪些进程服务？&#xA;1.7 Q: 电脑关闭了但电源没有断。&#xA;1.8 Q: 切换到 systemd 后，为什么 fakeRAID 没有挂载?&#xA;1.9 Q: 如何在启动的时候，运行自定义的一个脚本？&#xA;1.10 Q: .service 状态显示绿色的 &amp;quot;active (exited)&amp;quot; (例如 iptables)&#xA;1.11 Q: Failed to issue method call: File exists 错误&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;常见问题&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Q: 为什么控制台上会显示日志信息？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:请自行设置内核日志等级（loglevel）&#xA;以前，/etc/rc.sysinit 帮我们把 dmesg 的日志等级设置为 3，是比较合适的。&#xA;内核参数中加入 loglevel=3 或 quiet 即可。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: 如何修改启用的可登陆的 tty 控制台（getty）数量？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:添加新的 getty：&#xA;在 /etc/systemd/system/getty.target.wants/ 添加新的软链接即可：&#xA;# ln -sf /usr/lib/systemd/system/getty@.service /etc/systemd/system/getty.target.wants/getty@tty9.service&#xA;# systemctl start getty@tty9.service&#xA;移除 getty：&#xA;从 /etc/systemd/system/getty.target.wants/ 删除对应的软链接即可：&#xA;# rm /etc/systemd/system/getty.target.wants/getty@tty5.service /etc/systemd/system/getty.target.wants/getty@tty6.service&#xA;# systemctl stop getty@tty5.service getty@tty6.service&#xA;用户也可以通过编辑/etc/systemd/logind.conf，将NAutoVTs修改为需要的 TTY 个数&#xA;用这种方式，按需启动将会保持，而之前的方式将会在启动时就启动 TTY.&#xA;systemd 不使用 /etc/inittab 文件。&#xA;注意: 自 systemd 版本 30，系统默认只开启一个 getty&#xA;只有切换到别的 tty 时，才会开启新的 getty（socket 激活式）&#xA;但仍可使用上述方法强制添加新的 getty。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: 怎样输出更详细的开机信息？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:如果内核信息输出后就什么信息都不输出了，很可能是因为你在内核参数中添加了 quiet&#xA;删除即可，然后你就可以看到一列列绿色的 [ OK ] 和红色的 [ FAILED ]了&#xA;所有信息都记录在系统日志，可以通过 $ systemctl 查看系统状态，通过 journalctl 查看日志。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: 开机后控制台信息会被清空，如何避免？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:自己写一个 getty@tty1.service 文件 &#xA;把/usr/lib/systemd/system/getty@.service复制到/etc/systemd/system/getty@tty1.service&#xA;修改 TTYVTDisallocate 为 no.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: 电脑关闭了但电源没有断。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:使用 $ systemctl poweroff&#xA;而不是 systemctl halt.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: 切换到 systemd 后，为什么 fakeRAID 没有挂载?&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:请确保使用了&#xA;# systemctl enable dmraid.service&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: 如何在启动的时候，运行自定义的一个脚本？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:在/etc/systemd/system中新建一个文件(名称可以为 myscript.service) &#xA;然后在其中写入如下内容：&#xA;&#xA;[Unit]&#xA;Description=My script&#xA;&#xA;[Service]&#xA;ExecStart=/usr/bin/my-script&#xA;&#xA;[Install]&#xA;WantedBy=multi-user.target &#xA;然后开启该守护进程&#xA;# systemctl enable myscript.service&#xA;本例是说当目标multi-usr载入的时候，会启动你这个自定义脚本。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: .service 状态显示绿色的 &amp;ldquo;active (exited)&amp;rdquo; (例如 iptables)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:这很正常，本例中的 iptables 并不是守护进程，而是由内核控制，所以装载完规则后自动退出了。&#xA;通过下面命令检查规则是否正确加载 # iptables --list&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: Failed to issue method call: File exists 错误&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:此错误一般发生在systemctl enable创建系统连接到/etc/systemd/system/的时候&#xA;一般是在切换显示管理器(例如从 GDM 到 KDM)时出现，这时/etc/systemd/system/display-manager.service 已经存在&#xA;要解决此问题，使用 systemctl -f enable 覆盖原有链接。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;在之前是直接将 /etc/inittab 文件中id:5:initdefault 数字修改为  id:3:initdefault 就可以了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;现在再进入这个文件提示不再使用了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;需要修改 /etc/systemd/system/default.target 这个软连接文件.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个软连接默认指向第5运行等级(GUI):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/etc/systemd/system/default.target -&amp;gt; /lib/systemd/system/runlevel5.target&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;现在只要将这个软连接指向需要的运行等级就行了. 比如命令行界面多用户模式:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd /etc/systemd/system&#xA;mv default.target runlevel5.target&#xA;ln -s /lib/systemd/system/runlevel3.target default.target&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样使默认启动等级的target指向等级为3(CLI)的运行等级target.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/etc/systemd/system/default.target -&amp;gt; /lib/systemd/system/runlevel3.target&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后重启系统就默认进入命令行多用户模式了,不会再启动GDM了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果想从GUI模式快速重新启动到命令行模式,可以直接使用命令 init 3&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下次如果想要改回去,只要把default.target改下名称,把runlevel5.target再改回default.target就行啦.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mv default.target runlevel3.target&#xA;mv runlevel5.target default.target&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>通过代码了解-Golang-interface</title>
      <link>http://www.nljb.net/default/%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E4%BA%86%E8%A7%A3-Golang-interface/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;func main() {&#xA;    var s []interface{} = []string{&amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;}&#xA;    for _, x := range s.([]string) {&#xA;    println(x)&#xA;    }   &#xA;}&#xA;&#xA;运行会报错：&#xA;cannot use []string literal (type []string) as type []interface {} in assignment&#xA;invalid type assertion: s.([]string) (non-interface type []interface {} on left)&#xA;&#xA;package main&#xA;&#xA;func main() {&#xA;    var s interface{} = []string{&amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;}&#xA;    for _, x := range s.([]string) {&#xA;    println(x)&#xA;    }&#xA;}&#xA;ok&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&amp;quot;fmt&amp;quot;)&#xA;&#xA;type Animal interface {&#xA;    Run()&#xA;}&#xA;&#xA;type Cat struct {&#xA;}&#xA;&#xA;func (cat *Cat) Run() {&#xA;    fmt.Println(&amp;quot;Cat Run&amp;quot;)&#xA;}&#xA;&#xA;type Dog struct {&#xA;}&#xA;&#xA;func (dog *Dog) Run() {&#xA;    fmt.Println(&amp;quot;Dog Run&amp;quot;)&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;    var animal Animal&#xA;&#xA;    animal = &amp;amp;Cat{}&#xA;&#xA;    animal.Run()&#xA;&#xA;    animal = &amp;amp;Dog{}&#xA;&#xA;    animal.Run()&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>网线八根线的作用</title>
      <link>http://www.nljb.net/default/%E7%BD%91%E7%BA%BF%E5%85%AB%E6%A0%B9%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;网线八根线的作用&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1,2,3,6为有效线，他是负责传输和接受数据的~ ,其他的用于电话~ &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果你拿着RJ-45连接头对着自己，锁扣朝上，那么从左到右各插脚的编号依次是1到8。根据TIA/EIA568规范各插脚的用途如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;插脚编号 作用 &#xA;1 输出数据 (+) &#xA;2 输出数据 (-) &#xA;3 输入数据 (+) &#xA;4 保留为电话使用 &#xA;5 保留为电话使用 &#xA;6 输入数据 (-) &#xA;7 保留为电话使用 &#xA;8 保留为电话使用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;网线的接法&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;一、PC连HUB （电脑连接上网设备）&#xA;A端：（标准568B）：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕。&#xA;B端：（标准568B）：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕。&#xA;&#xA;二、PC连PC （电脑连接电脑）&#xA;A端：(568A)： 白绿，绿，白橙，蓝，白蓝，橙，白棕，棕；&#xA;B端：（标准568B）：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕。&#xA;&#xA;三、HUB连HUB （上网设备连接上网设备）&#xA;A端：(568A)： 白绿，绿，白橙，蓝，白蓝，橙，白棕，棕；&#xA;B端：（568B）： 白橙，橙，白绿，蓝，白蓝，绿，白棕，棕。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>系统分隔符-Windows-and-Linux</title>
      <link>http://www.nljb.net/default/%E7%B3%BB%E7%BB%9F%E5%88%86%E9%9A%94%E7%AC%A6-Windows-and-Linux/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;const (&#xA;    PathSeparator     = &#39;/&#39; // OS-specific path separator&#xA;    PathListSeparator = &#39;:&#39; // OS-specific path list separator&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>用sshpass实现ssh的自动登陆</title>
      <link>http://www.nljb.net/default/%E7%94%A8sshpass%E5%AE%9E%E7%8E%B0ssh%E7%9A%84%E8%87%AA%E5%8A%A8%E7%99%BB%E9%99%86/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;用sshpass实现ssh的自动登陆&lt;/p&gt;&#xA;&#xA;&lt;p&gt;要实现ssh自动登录，网上搜了一下，主要有两种方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1、生成公钥。&#xA;2、编写expect脚本。这两种方法，用起来都有点复杂。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在新立得上安装ssh的时候，偶然发现一个sshpass，百度谷歌之，英文资料甚多，而中文资料寥寥。其实sshpass的用法很简单。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;用法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    sshpass 参数 SSH命令(ssh，sftp，scp等)。&#xA;    参数:&#xA;    -p password    //将参数password作为密码。&#xA;    -f passwordfile //提取文件passwordfile的第一行作为密码。&#xA;    -e        //将环境变量SSHPASS作为密码。&#xA;&#xA;    比如说：&#xA;    scp abc@192.168.0.5:/home/xxx/test /root   这个命令的作用是将服务器端文件test传到本地文件夹/root下。&#xA;    利用sshpass，假设密码为efghi，则可写作：&#xA;    ssh -p efghi scp abc@192.168.0.5:/home/xxx/test /root&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;另外，对于ssh的第一次登陆，会提示：“Are you sure you want to continue connecting (yes/no)”，这时用sshpass会不好使&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;可以在ssh命令后面加上 -o StrictHostKeyChecking=no来解决。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;比如说上面的命令，就可以写作ssh -p efghi scp abc@192.168.0.5:/home/xxx/test /root -o StrictHostKeyChecking=no。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>对于WIFI密码中带有英文字符或特殊字符</title>
      <link>http://www.nljb.net/default/%E5%AF%B9%E4%BA%8EWIFI%E5%AF%86%E7%A0%81%E4%B8%AD%E5%B8%A6%E6%9C%89%E8%8B%B1%E6%96%87%E5%AD%97%E7%AC%A6%E6%88%96%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;对于WIFI密码中带有英文字符或特殊字符需要使用S:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1:iwlist eth1 scanning 查看无线路由 &#xA;2:iwconfig eth1 essid &amp;quot;无线路由的名称&amp;quot; &#xA;3: ifconfig eth1 IP &#xA;4: route add default gw 网关 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;对于带密码的路由器,设置如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1:iwconfig eth1 key s:密码 &#xA;2:iwconfig eth1 key open &#xA;3:ifconfig eth1 essid &amp;quot;名称&amp;quot; &#xA;4:ifconfig eth1 IP5:route add default gw 网关&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>在Golang中获取系统的磁盘内存占用</title>
      <link>http://www.nljb.net/default/%E5%9C%A8Golang%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A3%81%E7%9B%98%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;获取磁盘占用情况(Linux/Mac下有效)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://wendal.net/2012/1224.html&#34;&gt;http://wendal.net/2012/1224.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获取磁盘占用情况(Linux/Mac下有效)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获取内存占用&lt;/p&gt;&#xA;&#xA;&lt;p&gt;很明显,Windows下的支持是最弱的, 当然,还能通过调用win32 API的方式获取缺失的信息&#xA;Golang的API并非完全跨平台, 正如上述的syscall.Statfs_t结构体,在Windows下是没有的&#xA;2013年4月6号更新,windows下获取磁盘空间的方法&#xA;通过调用win32 api&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//读取内存状态信息&#xA;func(ev*Ev)GetMemo()(int,int,int){&#xA;    //内存状态文件路径&#xA;    varmeminfostring=&amp;quot;/proc/meminfo&amp;quot;&#xA;    //存储各状态信息&#xA;    vartotalint&#xA;    varfreeint&#xA;    varusedint&#xA;    //读取文件&#xA;    evolver.FileRF(meminfo,func(f*os.File){&#xA;    //建立文件流&#xA;    rd:=bufio.NewReader(f)&#xA;    for{&#xA;        //按行读取&#xA;        data,err:=rd.ReadString(&#39;\n&#39;)&#xA;        iferr==io.EOF{&#xA;        break&#xA;        }&#xA;        iferr!=nil{&#xA;        break&#xA;        }&#xA;        //判断是否为需要的信息&#xA;        ifstrings.HasPrefix(data,&amp;quot;MemTotal&amp;quot;){&#xA;        totalValue:=strings.Split(evolver.Trim(strings.Split(data,&amp;quot;:&amp;quot;)[1]),&amp;quot;&amp;quot;)[0]&#xA;        total=evolver.ToInt(totalValue,0)&#xA;        }elseifstrings.HasPrefix(data,&amp;quot;MemFree&amp;quot;){&#xA;        freeValue:=strings.Split(evolver.Trim(strings.Split(data,&amp;quot;:&amp;quot;)[1]),&amp;quot;&amp;quot;)[0]&#xA;        free=evolver.ToInt(freeValue,0)&#xA;        }&#xA;        //计算以用空间&#xA;        used=total-free&#xA;    }&#xA;    })&#xA;    //返回结果&#xA;    returnfree,used,total&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>命名规范-Java</title>
      <link>http://www.nljb.net/default/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83-Java/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;一、(Package)包的命名&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Java包的名字都是由小写单词组成。但是由于Java面向对象编程的特性，每一名Java程序员都可以编写属于自己的Java包，为了保障每个 Java包命名的唯一性，在最新的Java编程规范中，要求程序员在自己定义的包的名称之前加上唯一的前缀。由于互联网上的域名称是不会重复的，所以程序员一般采用自己在互联网上的域名称作为自己程序包的唯一前缀。&#xA;&#xA;例如：    net.frontfree.javagroup&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;二、(Class)类的命名&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;类的名字必须由大写字母开头而单词中的其他字母均为小写；如果类名称由多个单词组成，则每个单词的首字母均应为大写例如TestPage；如果类名称中包含单词缩写，则这个所写词的每个字母均应大写，如：XMLExample,还有一点命名技巧就是由于类是设计用来代表对象的，所以在命名类时应尽量选择名词。&#xA;&#xA;例如：    Circle&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;三、方法的命名&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头。&#xA;&#xA;例如：    sendMessge&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;四、参数的命名&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;参数的命名规范和方法的命名规范相同，而且为了避免阅读程序时造成迷惑，请在尽量保证参数名称为一个单词的情况下使参数的命名尽可能明确。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;五、Javadoc注释&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Java除了可以采用我们常见的注释方式之外，Java语言规范还定义了一种特殊的注释，也就是我们所说的Javadoc注释，它是用来记录我们代码中的API的。Javadoc注释是一种多行注释，以/**开头，而以*/结束，注释可以包含一些HTML标记符和专门的关键词。使用Javadoc 注释的好处是编写的注释可以被自动转为在线文档，省去了单独编写程序文档的麻烦。&#xA;&#xA;　　例如：&#xA;　　/**&#xA;　　*    This    is    an    example    of&#xA;　　*    Javadoc&#xA;　　*&#xA;　　*    @author    darchon&#xA;　　*    @version    0.1,    10/11/2002&#xA;　　*/&#xA;&#xA;在每个程序的最开始部分，一般都用Javadoc注释对程序的总体描述以及版权信息，之后在主程序中可以为每个类、接口、方法、字段添加 Javadoc注释，每个注释的开头部分先用一句话概括该类、接口、方法、字段所完成的功能，这句话应单独占据一行以突出其概括作用，在这句话后面可以跟随更加详细的描述段落。在描述性段落之后还可以跟随一些以Javadoc注释标签开头的特殊段落，例如上面例子中的@auther和@version，这些段落将在生成文档中以特定方式显示。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;六、变量命名&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;变量命名应该采用首字母小写，其他字母首字母大写的方式。&#xA;&#xA;　　· Static    Final    变量的名字应该都大写，并且指出完整含义。&#xA;　　· 如果需要对变量名进行缩写时，一定要注意整个代码中缩写规则的一致性。例如，如果在代码的某些区域中使用intCnt，而在另一些区域中又使用intCount，就会给代码增加不必要的复杂性。建议变量名中尽量不要出现缩写。&#xA;　　· 通过在结尾处放置一个量词，就可创建更加统一的变量，它们更容易理解，也更容易搜索。例如，请使用 strCustomerFirst和strCustomerLast，而不要使用strFirstCustomer和strLastCustomer。常用的量词后缀有：First（一组变量中的第一个）、Last（一组变量中的最后一个）、Next（一组变量中的下一个变量）、Prev（一组变量中的上一个）、Cur（一组变量中的当前变量）。&#xA;　　· 为每个变量选择最佳的数据类型，这样即能减少对内存的需求量，加快代码的执行速度，又会降低出错的可能性。用于变量的数据类型可能会影响该变量进行计算所产生的结果。在这种情况下，编译器不会产生运行期错误，它只是迫使该值符合数据类型的要求。这类问题极难查找。&#xA;　　· 尽量缩小变量的作用域。如果变量的作用域大于它应有的范围，变量可继续存在，并且在不再需要该变量后的很长时间内仍然占用资源。它们的主要问题是，任何类中的任何方法都能对它们进行修改，并且很难跟踪究竟是何处进行修改的。占用资源是作用域涉及的一个重要问题。对变量来说，尽量缩小作用域将会对应用程序的可靠性产生巨大的影响。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;七、关于常量的命名方法&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在JAVA代码中，无论什么时候，均提倡应用常量取代数字、固定字符串。也就是说，程序中除0，1以外，尽量不应该出现其他数字。常量可以集中在程序开始部分定义或者更宽的作用域内，名字应该都使用大写字母，并且指出该常量完整含义。如果一个常量名称由多个单词组成，则应该用下划线“_”来分割这些单词如：NUM_DAYS_IN_WEEK、MAX_VALUE。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;八、推荐的命名&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1、类名推荐&#xA;&#xA;当要区别接口和实现类的时候，可以在类的后面加上“Impl”。例如： interface Container ,class ContainerImpl&#xA;class Container3PImpl&#xA;class ContainerYICTImpl&#xA;&#xA;2、Exception类名推荐&#xA;&#xA;Exception类最好能用“Exception”做为类命名的结尾。例如：&#xA;DataNotFoundException&#xA;InvalidArgumentException&#xA;&#xA;3、抽象类名推荐&#xA;&#xA;抽象类最好能用“Abstract”做为类命名的开头。例如：&#xA;AbstractBeanDefinition&#xA;AbstractBeanFactory&#xA;&#xA;4、Test类名推荐&#xA;&#xA;Test类最好能用“Test”做为类命名的结尾。例如：&#xA;ContainerTest&#xA;&#xA;5、工厂类方法推荐&#xA;&#xA;工厂方法最好能把该方法做要创建的对象类型描述出来。例如：&#xA;public Container createContainer();&#xA;public Location newLocation();&#xA;&#xA;· 虽然为一个设计低劣的程序添加注释不会使其变成好的程序，但是如果按照编程规范编写程序并且为程序添加良好的注释却可以帮助你编写出设计完美，运行效率高且易于理解的程序，尤其是在多人合作完成同一项目时编程规范就变得更加重要。俗话说“磨刀不误砍柴工”，花费一点时间去适应一下Java编程规范是有好处的。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>命名规范-Golang</title>
      <link>http://www.nljb.net/default/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83-Golang/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在Go中名称不但具有表达含义的功能，同时也具有约束使用的特点。如果一个函数的名称是小写的则表示该函数不能在其他包中使用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;命名必须使用骆驼命名法，而不能使用下划线法。&#xA;任何需要对外暴露的名字必须大写字母开头，不需要暴露在包外的名字必须以小写字母开头。&#xA;接口的命令，按照惯例，如果接口只有一个方法，则该接口命名为方法名成加上”ER“后缀。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>命名规范-Bash</title>
      <link>http://www.nljb.net/default/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83-Bash/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1 概述&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1.1 目的&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;定义Shell脚本命名和编码规范，作为OS裁剪设计、开发以及维护人员的技术参考资料。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;1.2 概述&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;本文主要根据Fedora Core 4.0的特点，描述安装脚本、OS初始脚本、补丁制作等方面的代码编写规范。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;1.3 开发工具&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;shell脚本是个文件，没有开发环境，FC4图形环境下，可用gedit、vi、vim、joe等，推荐使用gedit，并将环境设置为sh高亮显示；字符界面下，可用vi、joe、vim；Windows下，可用ultraedit。文件保存时，有汉字提示的Shell脚本文件，文件保存时，字符编码必须为GB18030/GBK/GB2132三种格式之一。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2 对象命名规范&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2.1 命名约定&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.本文档的命名约定是系统配置文件、脚本文件；&#xA;&#xA;2.文件名、变量名、函数名不超过20个字符； &#xA;&#xA;3.命名只能使用英文字母，数字和下划线，只有一个英文单词时使用全拼，有多个单词时，用下划线连接，长度较长时，可以取单词前3～4个字母。遇到复杂情况大家一起讨论决定； &#xA;&#xA;4.文件名全部以小写命名，不能大小写混用（通过U盘交换文件时，大小写可能会丢失，即：大写文件名可能会全部变成小写文件名）；&#xA;&#xA;5.避免使用Linux的保留字如true、关键字如PWD等（见附表）； &#xA;&#xA;6.从配置文件导出配置时，要注意过滤空行和注释&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.2 Shell脚本命名及规范&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Shell脚本文件包括如下文件：&#xA;&#xA;1、Linux启动初始化文件，如/etc/rc.d/rc.sysinit等&#xA;&#xA;2、隐藏初始化文件，如~/.bash_profile、~/.xinitrc等&#xA;&#xA;3、用户自定义Shell文件，如/root/install/scripts/findtermtype。sh&#xA;&#xA;这些文件的命名长度都不能超过20个字符。脚本命令过长时，以“_”相隔，如rdc09_tianjin.sh、inst_cp86.sh等。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.3 缩进&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;由于Shell没有很好的编辑环境，所以，缩进应该是每行1个TAB，不建议用空格缩进。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.4 页宽&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;每行不要超过80行，如果超出，建议用“\”折行，有管道的命令行除外。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.5 环境变量&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;变量：全部是大写字母&#xA;&#xA;变量引用：全部以变量名加双引号引用，如”$TERMTYPE”，或“${TERMTYPE}”，如果变量类型是数值型不引用，如:&#xA;&#xA;如果需要从配置文件导出变量，则在变量前加一大写字母，以识别导出变量与自定义环境变量的区别，如：&#xA;&#xA;变量值的引用尽量以$开头，如$(ls inst_*.sh)，避免使用`ls inst_*。sh`&#xA;&#xA;循环控制变量可以命名为单个字母， 比如 i、j等。 也可以是更有意义的名称， 比如 UserIndex。&#xA;&#xA;环境变量在脚本开头定义。&#xA;&#xA;函数中使用较多的文件，以环境变量的形式在文件开头定义&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.6 函数&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;函数以动名词形式存储，且第二个单词首字母要大写，如updateConfig()&#xA;&#xA;每个函数控制在50－100行，超出行数建议分成两个函数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.7 语句&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if 语句 &#xA;&#xA;if/then/else 语句中最可能被执行的部分应该放在 then 子句中， 不太可能被执行的部分应该放在 else 子句中。 &#xA;&#xA;如果可能， 尽量不要使用一连串的 if 语句， 而应该以 case 语句替代。 &#xA;&#xA;不要使 if 语句嵌套超过5层以上， 尽量以更清楚的代码替代。 &#xA;&#xA;case 语句 &#xA;&#xA;概要 &#xA;&#xA;case 语句中的单个子句应该以 case 常数的数字顺序或字母顺序排列。 子句中的执行语句应该尽量保持简单， 一般不要超过4到5行代码。 如果执行语句过于复杂， 应该将它放置在独立的函数中。 &#xA;&#xA;case 语句的 *) 子句应该只在正常的默认情况或检测到错误的情况下使用。 &#xA;&#xA;格式 &#xA;&#xA;case 语句遵循同样的缩进和命名约定。 &#xA;&#xA;while 语句 &#xA;&#xA;使用 Exit 过程退出 while 循环是不好的; 如果可能， 应该只使用循环条件来结束循环。 &#xA;&#xA;while 循环的所有初始化代码应该紧贴在进入 while 循环之前， 不要被其他无关语句分隔开。 &#xA;&#xA;循环结束后的处理应该紧跟在循环之后。 &#xA;&#xA;for 语句 &#xA;&#xA;如果需要执行确定次数的增量循环， 应该用 for 语句替代 while 语句。 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.8 信号捕捉&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;如果在进行重要配置修改时，应捕捉用户按键，如果用户按下Ctrl+C等重要操作终止程序，则调用回退程序，如：&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.9 关于注释&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;程序头应加注版本与功能说明的注释。但程序第一行不能汉字。&#xA;&#xA;程序体中应包含必要的注释，注释说明如下：&#xA;&#xA;单行注释，可以放在代码行的尾部或代码行的上部；&#xA;&#xA;多行注释，用于注解复杂的功能说明，可以放在程序体中，也可以放在代码块的开始部分&#xA;&#xA;代码修改时，对修改的内容要加必要版本注释及功能说明，格式参考如下：&#xA;&#xA;不再有用的注释要删除。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>ulimit</title>
      <link>http://www.nljb.net/default/ulimit/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;ulimint -a 用来显示当前的各种用户进程限制&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Linux对于每个用户，系统限制其最大进程数，为提高性能，可以根据设备资源情况&lt;/p&gt;&#xA;&#xA;&lt;p&gt;设置个Linux用户的最大进程数，一些需要设置为无限制：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;数据段长度：ulimit -d unlimited&#xA;最大内存大小：ulimit -m unlimited&#xA;堆栈大小：ulimit -s unlimited&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们在用这个命令的时候主要是为了产生core文件，就是程序运行发行段错误时的文件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit -c unlimited   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;生成core文件&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;查看限制情况 ulimit -a&#xA;可以看到如下信息&#xA;core file size          (blocks, -c) 0&#xA;data seg size           (kbytes, -d) unlimited&#xA;file size               (blocks, -f) unlimited&#xA;pending signals                 (-i) 1024&#xA;max locked memory       (kbytes, -l) 32&#xA;max memory size         (kbytes, -m) unlimited&#xA;open files                      (-n) 1024&#xA;pipe size            (512 bytes, -p) 8&#xA;POSIX message queues     (bytes, -q) 819200&#xA;stack size              (kbytes, -s) 10240&#xA;cpu time               (seconds, -t) unlimited&#xA;max user processes              (-u) 4096&#xA;virtual memory          (kbytes, -v) unlimited&#xA;file locks                      (-x) unlimited&#xA;而我们需要修改的是open files (-n) 1024的值&#xA;于是命令就是limit -n 2048(随各自需要设置)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;功能说明：控制shell程序的资源。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;语　　法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit [-aHS][-c &amp;lt;core文件上限&amp;gt;][-d &amp;lt;数据节区大小&amp;gt;][-f &amp;lt;文件大小&amp;gt;][-m &amp;lt;内存大小&amp;gt;][-n &amp;lt;文件数目&amp;gt;][-p &amp;lt;缓冲区大小&amp;gt;][-s &amp;lt;堆叠大小&amp;gt;][-t &amp;lt;CPU时间&amp;gt;][-u &amp;lt;程序数目&amp;gt;][-v &amp;lt;虚拟内存大小&amp;gt;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;补充说明：ulimit为shell内建指令，可用来控制shell执行程序的资源。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;参　　数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   -a 　显示目前资源限制的设定。 &#xA;   -c &amp;lt;core文件上限&amp;gt; 　设定core文件的最大值，单位为区块。 &#xA;   -d &amp;lt;数据节区大小&amp;gt; 　程序数据节区的最大值，单位为KB。 &#xA;   -f &amp;lt;文件大小&amp;gt; 　shell所能建立的最大文件，单位为区块。 &#xA;   -H 　设定资源的硬性限制，也就是管理员所设下的限制。 &#xA;   -m &amp;lt;内存大小&amp;gt; 　指定可使用内存的上限，单位为KB。 &#xA;   -n &amp;lt;文件数目&amp;gt; 　指定同一时间最多可开启的文件数。 &#xA;   -p &amp;lt;缓冲区大小&amp;gt; 　指定管道缓冲区的大小，单位512字节。 &#xA;   -s &amp;lt;堆叠大小&amp;gt; 　指定堆叠的上限，单位为KB。 &#xA;   -S 　设定资源的弹性限制。 &#xA;   -t &amp;lt;CPU时间&amp;gt; 　指定CPU使用时间的上限，单位为秒。 &#xA;   -u &amp;lt;程序数目&amp;gt; 　用户最多可开启的程序数目。 &#xA;   -v &amp;lt;虚拟内存大小&amp;gt; 　指定可使用的虚拟内存上限，单位为KB。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;1,说明:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit用于shell启动进程所占用的资源.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2,类别:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;shell内建命令&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3,语法格式:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit [-acdfHlmnpsStvw] [size]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;4,参数介绍:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-H 设置硬件资源限制.&#xA;-S 设置软件资源限制.&#xA;-a 显示当前所有的资源限制.&#xA;-c size:设置core文件的最大值.单位:blocks&#xA;-d size:设置数据段的最大值.单位:kbytes&#xA;-f size:设置创建文件的最大值.单位:blocks&#xA;-l size:设置在内存中锁定进程的最大值.单位:kbytes&#xA;-m size:设置可以使用的常驻内存的最大值.单位:kbytes&#xA;-n size:设置内核可以同时打开的文件描述符的最大值.单位:n&#xA;-p size:设置管道缓冲区的最大值.单位:kbytes&#xA;-s size:设置堆栈的最大值.单位:kbytes&#xA;-t size:设置CPU使用时间的最大上限.单位:seconds&#xA;-v size:设置虚拟内存的最大值.单位:kbytes&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;5,简单实例:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1]在RH8的环境文件/etc/profile中,我们可以看到系统是如何配置ulimit的:&#xA;&#xA;CODE:&#xA;#grep ulimit /etc/profile&#xA;ulimit -S -c 0 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1&#xA;&#xA;这条语句设置了对软件资源和对core文件大小的设置&#xA;&#xA;2]如果我们想要对由shell创建的文件大小作些限制,如:&#xA;&#xA;CODE:&#xA;#ll h&#xA;-rw-r--r-- 1 lee lee 150062 7月 22 02:39 h&#xA;#ulimit -f 100 #设置创建文件的最大块(一块=512字节)&#xA;#cat h&amp;gt;newh&#xA;File size limit exceeded&#xA;#ll newh&#xA;-rw-r--r-- 1 lee lee 51200 11月 8 11:47 newh&#xA;&#xA;文件h的大小是150062字节,而我们设定的创建文件的大小是512字节x100块=51200字节&#xA;当然系统就会根据你的设置生成了51200字节的newh文件.&#xA;&#xA;3]可以像实例1]一样,把你要设置的ulimit放在/etc/profile这个环境文件中&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;1,可以用ulimit -a查看一下栈的大小:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在内核2.6.20下， stack size 为8192 kbytes&#xA;如果这里没有限制，就栈的大小就只受内存的限制。2G是上限。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2,文件 CORE&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;开启或关闭core文件的生成&#xA;ulimit -c 可以查看是否打开此选项，若为0则为关闭；&#xA;ulimit -c 0可手动关闭&#xA;ulimit -c 1000 为设置core文件大小最大为1000k&#xA;ulimit -c unlimited 设置core文件大小为不限制大小&#xA;&#xA;很多系统在默认的情况下是关闭生成core文件的，这个命令可以加到你的profile中去&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;1,说明:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit用于shell启动进程所占用的资源.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2,类别:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;shell内建命令&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3,语法格式:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit [-acdfHlmnpsStvw] [size]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;4,参数介绍:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-H 设置硬件资源限制.&#xA;-S 设置软件资源限制.&#xA;-a 显示当前所有的资源限制.&#xA;-c size:设置core文件的最大值.单位:blocks&#xA;-d size:设置数据段的最大值.单位:kbytes&#xA;-f size:设置创建文件的最大值.单位:blocks&#xA;-l size:设置在内存中锁定进程的最大值.单位:kbytes&#xA;-m size:设置可以使用的常驻内存的最大值.单位:kbytes&#xA;-n size:设置内核可以同时打开的文件描述符的最大值.单位:n&#xA;-p size:设置管道缓冲区的最大值.单位:kbytes&#xA;-s size:设置堆栈的最大值.单位:kbytes&#xA;-t size:设置CPU使用时间的最大上限.单位:seconds&#xA;-v size:设置虚拟内存的最大值.单位:kbytes 5,简单实例: &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;5.举例&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在Linux下写程序的时候，如果程序比较大，经常会遇到“段错误”（segmentation fault）这样的问题，这主要就是由于Linux系统初始的堆栈大小（stack size）太小的缘故，一般为10M。我一般把stack size设置成256M，这样就没有段错误了！&#xA;&#xA;命令为：&#xA;ulimit   -s 262140 &#xA;&#xA;如果要系统自动记住这个配置，就编辑/etc/profile文件，在 “ulimit -S -c 0 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1”行下，添加“ulimit   -s 262140”，保存重启系统就可以了！ &#xA;1]在RH8的环境文件/etc/profile中,我们可以看到系统是如何配置ulimit的:&#xA;&#xA;#grep ulimit /etc/profile&#xA;ulimit -S -c 0 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1&#xA;&#xA;这条语句设置了对软件资源和对core文件大小的设置&#xA;&#xA;2]如果我们想要对由shell创建的文件大小作些限制,如:&#xA;&#xA;#ll h&#xA;-rw-r--r-- 1 lee lee 150062 7月 22 02:39 h&#xA;#ulimit -f 100 #设置创建文件的最大块(一块=512字节)&#xA;#cat h&amp;gt;newh&#xA;File size limit exceeded&#xA;#ll newh&#xA;-rw-r--r-- 1 lee lee 51200 11月 8 11:47 newh&#xA;&#xA;文件h的大小是150062字节,而我们设定的创建文件的大小是512字节x100块=51200字节&#xA;&#xA;当然系统就会根据你的设置生成了51200字节的newh文件.&#xA;&#xA;3]可以像实例1]一样,把你要设置的ulimit放在/etc/profile这个环境文件中.&#xA;&#xA;用途,设置或报告用户资源极限。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;语法&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit [ -H ] [ -S ] [ -a ] [ -c ] [ -d ] [ -f ] [ -m ] [ -n ] [ -s ] [ -t ] [ Limit ]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;标志&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-a     列出所有当前资源极限。&#xA;-c     以 512 字节块为单位，指定核心转储的大小。&#xA;-d     以 K 字节为单位指定数据区域的大小。&#xA;-f     使用 Limit 参数时设定文件大小极限（以块计），或者在未指定参数时报告文件大小极限。缺省值为 -f 标志。&#xA;-H     指定设置某个给定资源的硬极限。如果用户拥有 root 用户权限，可以增大硬极限。任何用户均可减少硬极限。&#xA;-m     以 K 字节为单位指定物理存储器的大小。&#xA;-n     指定一个进程可以拥有的文件描述符的数量的极限。&#xA;-s     以 K 字节为单位指定堆栈的大小。&#xA;-S     指定为给定的资源设置软极限。软极限可增大到硬极限的值。如果 -H 和 -S 标志均未指定，极限适用于以上二者。&#xA;-t     指定每个进程所使用的秒数。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;退出状态&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;返回以下退出值：&#xA;0     成功完成。&#xA;&amp;gt;0     拒绝对更高的极限的请求，或发生错误。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;示例,要将文件大小极限设置为 51,200 字节，输入：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit -f 100&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>exec.Command-status.ExitStatus</title>
      <link>http://www.nljb.net/default/exec.Command-status.ExitStatus/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 可用串口&#xA;&#xA;func (d *Dial) SerialOK(dev []string) string {&#xA;&#xA;    // 遍历设备&#xA;&#xA;    for _, v := range dev {&#xA;&#xA;    // 通过调用程序来判断可用串口&#xA;&#xA;    cmd := exec.Command(&amp;quot;/danoo/bin/danoo_3g_signal&amp;quot;, v)&#xA;&#xA;    // 运行程序&#xA;&#xA;    if err := cmd.Start(); err != nil {&#xA;&#xA;        continue&#xA;&#xA;    }&#xA;&#xA;    // 线程&#xA;&#xA;    chTime := make(chan int)&#xA;&#xA;    // 飞一会干掉他&#xA;&#xA;    go (func(ch chan int, cmd *exec.Cmd) {&#xA;&#xA;        // 让程序飞一会&#xA;&#xA;        time.Sleep(time.Second * 5)&#xA;&#xA;        // 然后干掉它&#xA;        cmd.Process.Kill()&#xA;&#xA;        // 返回&#xA;&#xA;        ch &amp;lt;- 0&#xA;&#xA;    })(chTime, cmd)&#xA;&#xA;    // 等待程序结束&#xA;&#xA;    if err := cmd.Wait(); err != nil {&#xA;&#xA;        if exiterr, ok := err.(*exec.ExitError); ok {&#xA;&#xA;        if status, ok := exiterr.Sys().(syscall.WaitStatus); ok {&#xA;&#xA;            if status.ExitStatus() == 99 {&#xA;&#xA;            return v&#xA;&#xA;            }&#xA;&#xA;        }&#xA;&#xA;        }&#xA;&#xA;    }&#xA;&#xA;    // 返回锁&#xA;&#xA;    &amp;lt;-chTime&#xA;&#xA;    }&#xA;&#xA;    // 返回&#xA;&#xA;    return &amp;quot;&amp;quot;&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>SSH-远程登录慢的原因</title>
      <link>http://www.nljb.net/default/SSH-%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;有时候在ssh远程登录到其他主机上时发现登录时间太长，要等待很久才会出现输入密码的提示，google了一下，发现主要有两个问题会导致ssh登录慢：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1.使用了dns反查，这样的话当ssh某个IP时，系统会试图通过DNS反查相对应的域名，如果DNS中没有这个IP的域名解析，则会等到DNS查询超时才会进行下一步，消耗很长时间。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;修改方式: vim /etc/ssh/sshd_config 增加一行记录：UseDNS no&#xA;&#xA;默认情况下会有一行被注释掉的记录#UseDNS yes，虽然这条记录被注释掉了，但ssh缺省情况下UseDNS的值是yes，所以要显式的指定该值为no。&#xA;&#xA;重新启动ssh服务&#xA;远程登录会快很多。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;这种情况在本地主机或远程主机启动图形的情况下比较明显，该参数似乎是在做图形方面的认证，具体功能还不清楚，但修改以后可以明显提高ssh远程登录速度。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;vim /etc/ssh/sshd_config&#xA;修改GSSAPIAuthentication参数为 no，默认是yes&#xA;重新启动ssh服务&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;ssh –vvv&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-vvv的参数可以查看ssh登录的过程，看看当前进行到了哪一步。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>SSH--C-压缩传输</title>
      <link>http://www.nljb.net/default/SSH--C-%E5%8E%8B%E7%BC%A9%E4%BC%A0%E8%BE%93/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;-C&#xA;&#xA;Requests compression of all data (including stdin, stdout, stderr, and data for forwarded X11 and TCP connections).  The compression algorithm is the&#xA;&#xA;same used by gzip(1), and the “level” can be controlled by the CompressionLevel option for protocol version 1.  Compression is desirable on modem&#xA;&#xA;lines and other slow connections, but will only slow down things on fast networks.  The default value can be set on a host-by-host basis in the con‐&#xA;&#xA;figuration files; see the Compression option.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Python-danoo_3g_dog.py-and-danoo_3g_dial.py</title>
      <link>http://www.nljb.net/default/Python-danoo_3g_dog.py-and-danoo_3g_dial.py/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python&#xA;import time,os&#xA;def get_link():&#xA;    f = open(&amp;quot;/etc/wvdial.conf&amp;quot;,&amp;quot;r&amp;quot;)&#xA;    str_end = []&#xA;    for str in f:&#xA;    try:&#xA;        str = str.strip()&#xA;        str.index(&#39;Modem&#39;)&#xA;        str_member = str[str.index(&#39;=&#39;)+1:].strip()&#xA;        str_end.append(str_member)&#xA;    except ValueError:&#xA;        continue&#xA;    f.close()&#xA;    return str_end[:]&#xA;def get_dialer_list():&#xA;    af = open(&amp;quot;/etc/wvdial.conf&amp;quot;,&amp;quot;r&amp;quot;)&#xA;    str_end = []&#xA;    for str in af:&#xA;    try:&#xA;        str = str.strip()&#xA;        str.index(&#39;Dialer&#39;)&#xA;        str_member = str[str.index(&#39;[Dialer&#39;)+7:-1].strip()&#xA;        str_end.append(str_member)&#xA;    except ValueError:&#xA;        continue&#xA;    af.close()&#xA;    return str_end[:]&#xA;DANOO_USB = get_link()&#xA;DANOO_APN = get_dialer_list()&#xA;print &#39;&amp;gt;&amp;gt;&amp;gt;&#39;,DANOO_APN&#xA;print &#39;&amp;gt;&amp;gt;&amp;gt;&#39;,DANOO_USB&#xA;if not len(DANOO_APN) == len(DANOO_USB):&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt;&#39;,&#39;wvdial.conf Config Error&#39;&#xA;    exit(0)&#xA;while True:&#xA;    WV_MEMBER = len(DANOO_APN)&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Dial Device Number&#39;,WV_MEMBER&#xA;    for x in range(WV_MEMBER):&#xA;    try:&#xA;        f = file(DANOO_USB[x])&#xA;        f.close()&#xA;    except IOError:&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; No such file or directory&#39;,DANOO_USB[x]&#xA;        continue&#xA;    ST_WV = &#39;wvdial&#39;+&#39; &#39;+DANOO_APN[x]&#xA;    ST_WVDIAL = os.system(ST_WV)&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt;&#39;,&#39;Connect&#39;,DANOO_APN[x],&#39;Error Sleep 10s&#39;&#xA;    time.sleep(10)&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt;&#39;,&#39;Connect ALL Failure Sleep 30s Reconnect&#39;&#xA;    time.sleep(30)&#xA;-----------------------------------------------  ↓ OLD  ↓ --------------------------------------------------------------------------&#xA;#!/usr/bin/env python&#xA;import time,os&#xA;def get_link():&#xA;    f = open(&amp;quot;/etc/wvdial.conf&amp;quot;,&amp;quot;r&amp;quot;)&#xA;    str_end = []&#xA;    for str in f:&#xA;    try:&#xA;        str = str.strip()&#xA;        str.index(&#39;Modem&#39;)&#xA;        str_member = str[str.index(&#39;=&#39;)+1:].strip()&#xA;        str_end.append(str_member)&#xA;    except ValueError:&#xA;        continue&#xA;    f.close()&#xA;    return str_end[:]&#xA;def get_dialer_list():&#xA;    af = open(&amp;quot;/etc/wvdial.conf&amp;quot;,&amp;quot;r&amp;quot;)&#xA;    str_end = []&#xA;    for str in af:&#xA;    try:&#xA;        str = str.strip()&#xA;        str.index(&#39;Dialer&#39;)&#xA;        str_member = str[str.index(&#39;[Dialer&#39;)+7:-1].strip()&#xA;        str_end.append(str_member)&#xA;    except ValueError:&#xA;        continue&#xA;    af.close()&#xA;    return str_end[:]&#xA;DANOO_USB = get_link()&#xA;DANOO_APN = get_dialer_list()&#xA;print &#39;&amp;gt;&amp;gt;&amp;gt;&#39;,DANOO_APN&#xA;print &#39;&amp;gt;&amp;gt;&amp;gt;&#39;,DANOO_USB&#xA;if not len(DANOO_APN) == len(DANOO_USB):&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt;&#39;,&#39;wvdial.conf Config Error&#39;&#xA;    exit(0)&#xA;while True:&#xA;    WV_MEMBER = len(DANOO_APN)&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Dial Device Number&#39;,WV_MEMBER&#xA;    for x in range(WV_MEMBER):&#xA;    try:&#xA;        f = file(DANOO_USB[x])&#xA;        f.close()&#xA;    except IOError:&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; No such file or directory&#39;,DANOO_USB[x]&#xA;        continue&#xA;    ST_WV = &#39;wvdial&#39;+&#39; &#39;+DANOO_APN[x]&#xA;    ST_WVDIAL = os.system(ST_WV)&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt;&#39;,&#39;Connect&#39;,DANOO_APN[x],&#39;Error Sleep 10s&#39;&#xA;    time.sleep(10)&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt;&#39;,&#39;Connect ALL Failure Reload drive&#39;&#xA;    os.system(&#39;pkill wvdial&#39;)&#xA;    os.system(&#39;pkill pppd&#39;)&#xA;    time.sleep(10)&#xA;    MOD_R = os.system(&#39;modprobe -r option usbserial&#39;)&#xA;    MOD_A = os.system(&#39;modprobe option&#39;)&#xA;    if MOD_R != 0:&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Remove drive Error&#39;&#xA;    if MOD_A != 0:&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Load drive Error&#39;&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt;&#39;,&#39;Connect ALL Failure Sleep 30s Reconnect&#39;&#xA;    time.sleep(30)&#xA;&#xA;----------------------------------------------- ↓ DOG ↓ --------------------------------------------------------------------------&#xA;#def CHECK_WGET(w_addr,f_addr):&#xA;# messaget = 0&#xA;# try:&#xA;# file = urllib.urlopen(w_addr)&#xA;# messaget = file.read()&#xA;# except IOError:&#xA;# print &#39;&amp;gt;&amp;gt;&amp;gt; urlopen %s error&#39; % w_addr&#xA;# file.close()&#xA;# if messaget != 0:&#xA;# messaget.index(f_addr)&#xA;# messaget = 1&#xA;# return messaget&#xA;----------------------------------------------------------------------------------------------------------------------------------------------------&#xA;#!/usr/bin/env python&#xA;import os,time,subprocess&#xA;CHECK_NET = [&#39;www.baidu.com&#39;,&#39;www.google.cn&#39;,&#39;www.qq.com&#39;,&#39;www.msn.com&#39;]&#xA;print &#39;&amp;gt;&amp;gt;&amp;gt; Check Netwrok Address -&amp;gt;&#39;,CHECK_NET&#xA;def shell_command(command):&#xA;    command_info = subprocess.call(command,shell=True)&#xA;    if command_info != 0:&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; command error -&amp;gt; &#39;,command&#xA;    return command_info&#xA;def CHECK_PING(ping_add):&#xA;    PING_ADD = &#39;ping -c 5&#39;+&#39; &#39;+ping_add+&#39; &#39;+&#39;&amp;gt;/dev/null&#39;&#xA;    PING_INFO = shell_command(PING_ADD)&#xA;    return not PING_INFO&#xA;def CHECK_TTYUSB(tty_usb):&#xA;    TTY_INFO = 1&#xA;    try:&#xA;    file(tty_usb)&#xA;    except IOError:&#xA;    TTY_INFO = 0&#xA;    return TTY_INFO&#xA;def CHECK_TTYUSB_INFO():&#xA;    global dial_pid&#xA;    if CHECK_TTYUSB(&#39;/dev/ttyUSB0&#39;):&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Check /dev/ttyUSB0 OK&#39;&#xA;    elif CHECK_TTYUSB(&#39;/dev/ttyUSB2&#39;):&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Check /dev/ttyUSB2 OK&#39;&#xA;    else:&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Check ttyUSB0 and ttyUSB2 Error -&amp;gt; No such file&#39;&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; kill &#39;,dial_pid.pid&#xA;    subprocess.Popen.kill(dial_pid)&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Network Check False -&amp;gt; Recheck Start Reload Driver&#39;&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Network Check False -&amp;gt; Recheck Reload Danoo 3G Dial&#39;&#xA;    if shell_command(&#39;pkill wvdial&#39;):&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; Recheck pkill wvdial Error&#39;&#xA;    if shell_command(&#39;pkill pppd&#39;):&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; Recheck pkill pppd Error&#39;&#xA;    if shell_command(&#39;modprobe -r option usbserial&#39;):&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; Recheck modprobe -r option usbserial Error&#39;&#xA;    if shell_command(&#39;modprobe option&#39;):&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; Recheck modprobe option Error&#39;&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Network Check False -&amp;gt; Reload End&#39;&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Check ttyUSB0 and ttyUSB2 -&amp;gt; Sleep 3600s Out Reboot -&amp;gt; Start&#39;&#xA;    time.sleep(3600)&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Check ttyUSB0 and ttyUSB2 -&amp;gt; Sleep 3600s Out Reboot -&amp;gt; End , Recheck Start&#39;&#xA;    NET_TTYS_RE = 0&#xA;    if CHECK_TTYUSB(&#39;/dev/ttyUSB0&#39;):&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; Recheck /dev/ttyUSB0 OK&#39;&#xA;    elif CHECK_TTYUSB(&#39;/dev/ttyUSB2&#39;):&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; Recheck /dev/ttyUSB2 OK&#39;&#xA;    else:&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; Recheck ttyUSB0 and ttyUSB2 -&amp;gt; No such file&#39;&#xA;        NET_TTYS_RE = 0&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; Recheck ttyUSB0 and ttyUSB2 -&amp;gt; Sleep 3600s Out Reboot -&amp;gt; End , Recheck End -&amp;gt; Reboot&#39;&#xA;        shell_command(&#39;reboot&#39;)&#xA;    if NET_TTYS_RE != 0:&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; Recheck ttyUSB0 and ttyUSB2 -&amp;gt; Sleep 3600s Out Reboot -&amp;gt; End , Recheck End -&amp;gt; Find ttyUSB or Network Not Reboot&#39;&#xA;def START_DIAL():&#xA;    global dial_pid&#xA;    try:&#xA;    dial_pid = subprocess.Popen(&#39;/danoo/bin/danoo_3g_dial.py&#39;)&#xA;    except IOSError:&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; /danoo/bin/danoo_3g_dial.py -&amp;gt; No such file&#39;&#xA;    exit(1)&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; /danoo/bin/danoo_3g_dial.py PID -&amp;gt;&#39;,dial_pid.pid&#xA;#####################################################################&#xA;START_DIAL()&#xA;CHECK_TTYUSB_INFO()&#xA;START_DIAL()&#xA;print &#39;&amp;gt;&amp;gt;&amp;gt; Danoo 3G DOG -&amp;gt; Time Sleep 1800s&#39;&#xA;time.sleep(1800)&#xA;while True:&#xA;    NET_INFO = 0&#xA;    for x in range(len(CHECK_NET)):&#xA;    if CHECK_PING(CHECK_NET[x]):&#xA;        NET_INFO = NET_INFO + 1&#xA;        break&#xA;    if not NET_INFO:&#xA;    CHECK_TTYUSB_INFO()&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Network Check False -&amp;gt; Start Reload Driver&#39;&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Network Check False -&amp;gt; Start Reload Danoo 3G Dial&#39;&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; kill &#39;,dial_pid.pid&#xA;    subprocess.Popen.kill(dial_pid)&#xA;    if shell_command(&#39;pkill wvdial&#39;):&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; pkill wvdial Error&#39;&#xA;    if shell_command(&#39;pkill pppd&#39;):&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; pkill pppd Error&#39;&#xA;    if shell_command(&#39;modprobe -r option usbserial&#39;):&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; modprobe -r option usbserial Error&#39;&#xA;    if shell_command(&#39;modprobe option&#39;):&#xA;        print &#39;&amp;gt;&amp;gt;&amp;gt; modprobe option Error&#39;&#xA;    START_DIAL()&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Network Check False -&amp;gt; Reload End&#39;&#xA;    else:&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Network Check True&#39;&#xA;    print &#39;&amp;gt;&amp;gt;&amp;gt; Danoo 3G DOG -&amp;gt; Time Sleep 1800s&#39;&#xA;    time.sleep(1800)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Python-auto_network</title>
      <link>http://www.nljb.net/default/Python-auto_network/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;################### NetWorks WIFI Connect Mode ######################&#xA;# NET_MODE -&amp;gt; &amp;quot;wep&amp;quot; or &amp;quot;wpa&amp;quot;, cannot be &amp;quot;NULL&amp;quot;&#xA;# NET_AUDH -&amp;gt; &amp;quot;dhcp&amp;quot; or &amp;quot;static&amp;quot;, cannot be &amp;quot;NULL&amp;quot;. WPA can only use dhcp.&#xA;# NET_APAD -&amp;gt;  AP Router IP address , cannot be &amp;quot;NULL&amp;quot;&#xA;NET_MODE=&amp;quot;wep&amp;quot;&#xA;NET_AUDH=&amp;quot;static&amp;quot;&#xA;NET_SSID=&amp;quot;danoowifi&amp;quot;&#xA;NET_PASS=&amp;quot;0175155789&amp;quot;&#xA;NET_IPAD=&amp;quot;192.168.10.133&amp;quot;&#xA;NET_MASK=&amp;quot;255.255.255.0&amp;quot;&#xA;NET_GETW=&amp;quot;192.168.10.1&amp;quot;&#xA;NET_APAD=&amp;quot;192.168.10.1&amp;quot;&#xA;######################################################################&#xA;&#xA;其实可以通过find()搜索play_wifi文件内&#39;=&#39;号位置后采集,然后将采集的位置加1即可,空值在bool中标识为假&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python&#xA;import os,time&#xA;def shell_command(command):&#xA;    command_info = os.system(command)&#xA;    if command_info != 0:&#xA;    print &#39;command error -&amp;gt; &#39;,command&#xA;    return command_info&#xA;def config_file_command(command_member):&#xA;    f = open(&#39;/root/.danoo_player_wifi&#39;,&#39;r&#39;)&#xA;    str1 = f.readline().strip()&#xA;    while len(str1):&#xA;    str1 = f.readline().strip()&#xA;    try:&#xA;        file_str1 = str1.split(&#39;=&#39;)&#xA;        file_member = file_str1.index(command_member)&#xA;        return_str1 = file_str1[file_member+1].strip(&#39;&amp;quot;&#39;)  &#xA;    except ValueError:&#xA;        continue&#xA;    try:&#xA;    return return_str1&#xA;    except UnboundLocalError:&#xA;    print &#39;.danoo_player_wifi Config File Error&#39;&#xA;    exit(0)&#xA;    f.close()&#xA;def device_info():&#xA;    shell_command(&#39;ifconfig eth1 down&#39;)&#xA;    if shell_command(&#39;ifconfig -a eth1&#39;) != 0:&#xA;    print &#39;eth1 Device not found -&amp;gt; exit&#39;&#xA;    exit(0)&#xA;    SHELL_ID = shell_command(&#39;ifconfig eth1 up&#39;)&#xA;    ETH_LABLE_A=0&#xA;    while SHELL_ID != 0:&#xA;    SHELL_ID = shell_command(&#39;ifconfig eth1 up&#39;)&#xA;    if ETH_LABLE_A == 1:&#xA;        time.sleep(6)&#xA;    elif ETH_LABLE_A &amp;gt; 1 and ETH_LABLE_A &amp;lt; 6: &#xA;        time.sleep(10)&#xA;    elif ETH_LABLE_A == 6:&#xA;        print &#39;eth1 Device UP Error -&amp;gt; exit&#39;&#xA;        exit(1)&#xA;    ETH_LABLE_A = ETH_LABLE_A + 1&#xA;def eth_dhcp():&#xA;    shell_command(&#39;dhclient -r eth1&#39;)&#xA;    shell_command(&#39;dhclient eth1&#39;)&#xA;def check_net():&#xA;    PING_ADD = &#39;ping -c 3&#39;+&#39; &#39;+NET_APAD&#xA;    PING_INFO = shell_command(PING_ADD)&#xA;    return PING_INFO&#xA;if bool(config_file_command(&#39;NET_MODE&#39;)):&#xA;    NET_MODE = config_file_command(&#39;NET_MODE&#39;)&#xA;else:&#xA;    print &#39;NET_MODE Config Error&#39;&#xA;    exit(1)&#xA;if bool(config_file_command(&#39;NET_AUDH&#39;)):&#xA;    NET_AUDH = config_file_command(&#39;NET_AUDH&#39;)&#xA;else:&#xA;    print &#39;NET_AUDH Config Error&#39;&#xA;    exit(1)&#xA;if bool(config_file_command(&#39;NET_SSID&#39;)):&#xA;    NET_SSID = config_file_command(&#39;NET_SSID&#39;)&#xA;else:&#xA;    print &#39;NET_SSID Config Error&#39;&#xA;    exit(1)&#xA;if bool(config_file_command(&#39;NET_PASS&#39;)):&#xA;    NET_PASS = config_file_command(&#39;NET_PASS&#39;)&#xA;else:&#xA;    print &#39;NET_PASS Config Error&#39;&#xA;    exit(1)&#xA;NET_IPAD = config_file_command(&#39;NET_IPAD&#39;)&#xA;NET_MASK = config_file_command(&#39;NET_MASK&#39;)&#xA;NET_GETW = config_file_command(&#39;NET_GETW&#39;)&#xA;if bool(config_file_command(&#39;NET_APAD&#39;)):&#xA;    NET_APAD = config_file_command(&#39;NET_APAD&#39;)&#xA;else:&#xA;    print &#39;NET_APAD Config Error&#39;&#xA;    exit(1)&#xA;def eth_dhcp():&#xA;    shell_command(&#39;dhclient -r eth1&#39;)&#xA;    shell_command(&#39;dhclient eth1&#39;)&#xA;##################################################################&#xA;if check_net():&#xA;    device_info()&#xA;##################################################################&#xA;while True:&#xA;    CHECK_NET_INFO = check_net()&#xA;    if NET_MODE == &#39;wep&#39;:&#xA;        ETH_LABLE_B = 0&#xA;        print &#39;CKECK_NET_INFO = &#39;,CHECK_NET_INFO&#xA;        while CHECK_NET_INFO:&#xA;        WEP_ETH = &#39;iwconfig eth1 essid&#39;+&#39; &#39;+NET_SSID+&#39; &#39;+&#39;key&#39;+&#39; &#39;+NET_PASS&#xA;        print WEP_ETH&#xA;        shell_command(WEP_ETH)&#xA;        time.sleep(3)&#xA;        shell_command(WEP_ETH)&#xA;        time.sleep(3)&#xA;        shell_command(WEP_ETH)&#xA;        time.sleep(9)&#xA;        if ETH_LABLE_B == 1:&#xA;            time.sleep(60)&#xA;        elif ETH_LABLE_B &amp;gt; 1 and ETH_LABLE_B &amp;lt; 3: &#xA;            time.sleep(180)&#xA;        elif ETH_LABLE_B &amp;gt; 6:&#xA;            time.sleep(3600)&#xA;        ETH_LABLE_B = ETH_LABLE_B + 1&#xA;        if NET_AUDH == &#39;static&#39;:&#xA;            WEP_ETH_CONFIG = &#39;ifconfig eth1&#39;+&#39; &#39;+NET_IPAD+&#39; &#39;+&#39;netmask&#39;+&#39; &#39;+NET_MASK&#xA;            print WEP_ETH_CONFIG&#xA;            shell_command(WEP_ETH_CONFIG)&#xA;        elif NET_AUDH == &#39;dhcp&#39;:&#xA;            eth_dhcp()&#xA;        time.sleep(10)&#xA;        CHECK_NET_INFO = check_net()&#xA;    #########################################################################&#xA;    elif NET_MODE == &#39;wpa&#39;:&#xA;        ETH_LABLE_C = 0&#xA;        print &#39;CHECK_NET_INFO = &#39;,CHECK_NET_INFO&#xA;        while CHECK_NET_INFO:&#xA;        af = open(&#39;/etc/wpa_supplicant/wpa_supplicant.conf&#39;,&#39;w&#39;)&#xA;        WPA_CONFIG = &#39;&#39;&#39;&#xA;        ctrl_interface=/var/run/wpa_supplicant&#xA;        ctrl_interface_group=0             &#xA;&#xA;        network={                       &#xA;               ssid=&amp;quot;%s&amp;quot;&#xA;               key_mgmt=WPA-PSK   &#xA;               proto=WPA2        &#xA;               psk=&amp;quot;%s&amp;quot;&#xA;               pairwise=TKIP CCMP  &#xA;               group=TKIP CCMP   &#xA;        }&#39;&#39;&#39; % (NET_SSID,NET_PASS)&#xA;        af.write(WPA_CONFIG)&#xA;        af.close()&#xA;        KILL_WPA = &amp;quot;kill -9 `pidof wpa_supplicant`&amp;quot;&#xA;        shell_command(KILL_WPA)&#xA;        WPA_ADD = &#39;wpa_supplicant -ieth1 -c/etc/wpa_supplicant/wpa_supplicant.conf &amp;amp;&#39;&#xA;        os.system(WPA_ADD)&#xA;        time.sleep(30)&#xA;        if ETH_LABLE_C == 1:&#xA;            time.sleep(60)&#xA;        elif ETH_LABLE_C &amp;gt; 1 and ETH_LABLE_C &amp;lt; 3: &#xA;            time.sleep(180)&#xA;        elif ETH_LABLE_C &amp;gt; 6:&#xA;            time.sleep(3600)&#xA;        ETH_LABLE_C = ETH_LABLE_C + 1&#xA;        eth_dhcp()&#xA;        CHECK_NET_INFO = check_net()&#xA;    #########################################################################&#xA;    else:&#xA;        print &#39;File Config NET_MODE Type Error&#39;&#xA;        exit(0)&#xA;&#xA;    if bool(config_file_command(&#39;NET_GETW&#39;)):&#xA;        ROUTE_ADD = &#39;route add default gw&#39;+&#39; &#39;+NET_GETW+&#39; &#39;+&#39;dev eth1&#39;&#xA;        if shell_command(ROUTE_ADD) != 0:&#xA;        print &#39;Route add Error&#39;&#xA;    print &#39;Check Network OK , Sleep 3600s&#39;&#xA;    time.sleep(3600)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Python-New-danoo_3g_dog.py-and-danoo_3g_dial.py</title>
      <link>http://www.nljb.net/default/Python-New-danoo_3g_dog.py-and-danoo_3g_dial.py/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python&#xA;import time,os,sys,commands&#xA;def get_link():&#xA;    f = open(&amp;quot;/etc/wvdial.conf&amp;quot;,&amp;quot;r&amp;quot;)&#xA;    str_end = []&#xA;    for str in f:&#xA;    try:&#xA;        str = str.strip()&#xA;        str.index(&#39;Modem&#39;)&#xA;        str_member = str[str.index(&#39;=&#39;)+1:].strip()&#xA;        str_end.append(str_member)&#xA;    except ValueError:&#xA;        continue&#xA;    f.close()&#xA;    return str_end[:]&#xA;def get_dialer_list():&#xA;    af = open(&amp;quot;/etc/wvdial.conf&amp;quot;,&amp;quot;r&amp;quot;)&#xA;    str_end = []&#xA;    for str in af:&#xA;    try:&#xA;        str = str.strip()&#xA;        str.index(&#39;Dialer&#39;)&#xA;        str_member = str[str.index(&#39;[Dialer&#39;)+7:-1].strip()&#xA;        str_end.append(str_member)&#xA;    except ValueError:&#xA;        continue&#xA;    af.close()&#xA;    return str_end[:]&#xA;def print_log(log_head=&#39;&#39;,log_info=&#39;&#39;):&#xA;    f_log = open(&#39;/var/log/danoo_3G_dial.log&#39;,&#39;a+&#39;)&#xA;    print log_head,log_info&#xA;    print &amp;gt;&amp;gt;f_log,log_head,log_info&#xA;    f_log.close()&#xA;try:&#xA;    file(&amp;quot;/etc/wvdial.conf&amp;quot;,&amp;quot;r&amp;quot;)&#xA;except IOError:&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt;&#39;,&#39;wvdial.conf File Error&#39;)&#xA;    exit(1)&#xA;file(&#39;/var/log/danoo_3G_dial.log&#39;,&#39;w&#39;)&#xA;DANOO_USB = get_link()&#xA;DANOO_APN = get_dialer_list()&#xA;print_log(&#39;&amp;gt;&amp;gt;&amp;gt;&#39;,DANOO_APN)&#xA;print_log(&#39;&amp;gt;&amp;gt;&amp;gt;&#39;,DANOO_USB)&#xA;if not len(DANOO_APN) == len(DANOO_USB):&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt;&#39;,&#39;wvdial.conf Config Error&#39;)&#xA;    exit(1)&#xA;while True:&#xA;    WV_MEMBER = len(DANOO_APN)&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Dial Device Number&#39;,WV_MEMBER)&#xA;    for x in range(WV_MEMBER):&#xA;    try:&#xA;        f = file(DANOO_USB[x])&#xA;        f.close()&#xA;    except IOError:&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; No such file or directory&#39;,DANOO_USB[x])&#xA;        continue&#xA;    ST_WV = &#39;wvdial&#39;+&#39; &#39;+DANOO_APN[x]&#xA;    ST_INFO_L,ST_WVDIAL = commands.getstatusoutput(ST_WV)&#xA;    print_log(ST_WVDIAL)&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Connect Error Sleep 10s&#39;,DANOO_APN[x])&#xA;    time.sleep(10)&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt;&#39;,&#39;Connect ALL Failure Sleep 30s Reconnect&#39;)&#xA;    time.sleep(30)&#xA;-------------------------------------------------------------------------------------------------------------------------&#xA;                               分界线&#xA;-------------------------------------------------------------------------------------------------------------------------&#xA;&#xA;#!/usr/bin/env python&#xA;import os,time,subprocess,urllib2,socket&#xA;# wget  timeout&#xA;socket.setdefaulttimeout(30)&#xA;def print_log(log_head=&#39;&#39;,log_info=&#39;&#39;):&#xA;    f_log = open(&#39;/var/log/danoo_3G_dog.log&#39;,&#39;a+&#39;)&#xA;    print log_head,log_info&#xA;    print &amp;gt;&amp;gt;f_log,log_head,log_info&#xA;    f_log.close()&#xA;file(&#39;/var/log/danoo_3G_dog.log&#39;,&#39;w&#39;)&#xA;CHECK_NET = [&#39;http://www.baidu.com&#39;,&#39;http://www.google.com&#39;,&#39;http://cn.bing.com&#39;]&#xA;CHECK_USB = [&#39;/dev/ttyUSB0&#39;,&#39;/dev/ttyUSB2&#39;]&#xA;print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Check Netwrok Address -&amp;gt;&#39;,CHECK_NET)&#xA;print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Check HuaWei USB Device -&amp;gt;&#39;,CHECK_USB)&#xA;def shell_command(command):&#xA;    command_info = subprocess.call(command,shell=True)&#xA;    if command_info != 0:&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; command error -&amp;gt; &#39;,command)&#xA;    return command_info&#xA;def CHECK_NETWORK():&#xA;    wget_member = 0&#xA;    for x in CHECK_NET:&#xA;    try:&#xA;        open_get = urllib2.urlopen(x)&#xA;    except urllib2.URLError:&#xA;        continue&#xA;    open_file = open_get.read()&#xA;    if len(open_file) != 0:&#xA;        wget_member += 1&#xA;    open_get.close()&#xA;    if wget_member &amp;gt; 0:&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Check Network Connection Is Working&#39;)&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Network Connection Working -&amp;gt; CHECK_3G_INFO -&amp;gt; 0&#39;)&#xA;    f_l = file(&#39;/tags/check_3g_info&#39;,&#39;w&#39;)&#xA;    f_l.write(&#39;0&#39;)&#xA;    f_l.close&#xA;    net_info = True&#xA;    else:&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Check Network Connection Fails&#39;)&#xA;    net_info = False&#xA;    return net_info&#xA;def CHECK_MEMBER():&#xA;    try:&#xA;    f = file(&#39;/tags/check_3g_info&#39;,&#39;r&#39;)&#xA;    except IOError:&#xA;    f = file(&#39;/tags/check_3g_info&#39;,&#39;w+r&#39;)&#xA;    f.write(&#39;0&#39;)&#xA;    f.seek(0)&#xA;    CHECK_3G_INFO = f.read()&#xA;    f.close&#xA;    return CHECK_3G_INFO&#xA;def CHECK_TTYUSB():&#xA;    usb_member = 0&#xA;    for u in CHECK_USB:&#xA;    try:&#xA;        file(u)&#xA;    except IOError:&#xA;        usb_member += 1&#xA;        continue&#xA;    if usb_member != 2:&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Check ttyUSB0 and ttyUSB2 OK -&amp;gt; Such Device&#39;)&#xA;    usb_info = True&#xA;    else:&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Check ttyUSB0 and ttyUSB2 Error -&amp;gt; No Such Device&#39;)&#xA;    usb_info = False&#xA;    return usb_info&#xA;def CHECK_RETTYUSB():&#xA;    if CHECK_TTYUSB() == False:&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; No Such ttyUSB0 and ttyUSB2 Device -&amp;gt; Reload Drive&#39;)&#xA;    if shell_command(&#39;modprobe -r option usbserial&#39;):&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Reload modprobe -r option usbserial Error&#39;)&#xA;    else:&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Reload modprobe -r option usbserial OK&#39;)&#xA;    if shell_command(&#39;modprobe option&#39;):&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Reload modprobe option Error&#39;)&#xA;    else:&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Reload modprobe option OK&#39;)&#xA;    if CHECK_TTYUSB() == False :&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; No Such ttyUSB0 and ttyUSB2 Device -&amp;gt; Reload Drive Error&#39;)&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Check ttyUSB0 and ttyUSB2 -&amp;gt; Sleep 3600s Out Reboot -&amp;gt; Start&#39;)&#xA;        time.sleep(3600)&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Check ttyUSB0 and ttyUSB2 -&amp;gt; Sleep 3600s Out Reboot -&amp;gt; End , Recheck Start&#39;)&#xA;        CHECK_3G_INFO = int(CHECK_MEMBER())&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Check Reboot Member -&amp;gt; CHECK_3G_INFO -&amp;gt;&#39;,CHECK_3G_INFO)&#xA;        if CHECK_TTYUSB() == False and CHECK_NETWORK() == False and CHECK_3G_INFO &amp;lt; 3:&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Recheck ttyUSB0 and ttyUSB2 -&amp;gt; Sleep 3600s Out Reboot -&amp;gt; End , Recheck End -&amp;gt; Reboot&#39;)&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Reboot System -&amp;gt; CHECK_3G_INFO + 1&#39;)&#xA;        f_e = file(&#39;/tags/check_3g_info&#39;,&#39;w&#39;)&#xA;        f_e.write(str(CHECK_3G_INFO+1))&#xA;        f_e.close()&#xA;        shell_command(&#39;reboot&#39;)&#xA;        else:&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Recheck ttyUSB0 and ttyUSB2 -&amp;gt; Sleep 3600s Out Reboot -&amp;gt; End , Recheck End -&amp;gt; Find ttyUSB or Network Not Reboot or CHECK_MEMBER()&#39;)&#xA;    else:&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; No Such ttyUSB0 and ttyUSB2 Device -&amp;gt; Reload Drive OK&#39;)&#xA;&#xA;def START_DIAL():&#xA;    global dial_pid&#xA;    try:&#xA;    dial_pid = subprocess.Popen(&#39;./danoo_3g_dial&#39;)&#xA;    except IOError:&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; danoo_3g_dial -&amp;gt; No such file&#39;)&#xA;    exit(1)&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; danoo_3g_dial PID -&amp;gt;&#39;,dial_pid.pid)&#xA;# check usb device&#xA;CHECK_RETTYUSB()&#xA;# start wvdial&#xA;START_DIAL()&#xA;print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Danoo 3G DOG -&amp;gt; Time Sleep 1800s&#39;)&#xA;time.sleep(1800)&#xA;while True:&#xA;    if CHECK_NETWORK() == False:&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Network Check False -&amp;gt; Recheck Device&#39;)&#xA;    CHECK_RETTYUSB()&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; kill &#39;,dial_pid.pid)&#xA;    subprocess.Popen.kill(dial_pid)&#xA;    if shell_command(&#39;pkill wvdial&#39;):&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; pkill wvdial Error&#39;)&#xA;    if shell_command(&#39;pkill pppd&#39;):&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; pkill pppd Error&#39;)&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Network Check False -&amp;gt; Start Reload Driver&#39;)&#xA;    if shell_command(&#39;modprobe -r option usbserial&#39;):&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; modprobe -r option usbserial Error&#39;)&#xA;    else:&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; modprobe -r option usbserial OK&#39;)&#xA;    if shell_command(&#39;modprobe option&#39;):&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; modprobe option Error&#39;)&#xA;    else:&#xA;        print_log(&#39;&amp;gt;&amp;gt;&amp;gt; modprobe option OK&#39;)&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Network Check False -&amp;gt; Start Reload Danoo 3G Dial&#39;)&#xA;    START_DIAL()&#xA;    else:&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Network Check True&#39;)&#xA;    print_log(&#39;&amp;gt;&amp;gt;&amp;gt; Danoo 3G DOG -&amp;gt; Time Sleep 1800s&#39;)&#xA;    time.sleep(1800)  &#xA;-------------------------------------------------------------------------------------------------------------------------&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Python-New-Danoo_Auto_Network</title>
      <link>http://www.nljb.net/default/Python-New-Danoo_Auto_Network/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;################### NetWorks WIFI Connect Mode ######################&#xA;# NET_MODE -&amp;gt; &amp;quot;wep&amp;quot; or &amp;quot;wpa&amp;quot;, cannot be &amp;quot;NULL&amp;quot;&#xA;# NET_AUDH -&amp;gt; &amp;quot;dhcp&amp;quot; or &amp;quot;static&amp;quot;, cannot be &amp;quot;NULL&amp;quot;. WPA can only use dhcp.&#xA;# NET_APAD -&amp;gt; AP Router IP address , cannot be &amp;quot;NULL&amp;quot;&#xA;NET_MODE=&amp;quot;wep&amp;quot;&#xA;NET_AUDH=&amp;quot;static&amp;quot;&#xA;NET_SSID=&amp;quot;danoowifi&amp;quot;&#xA;NET_PASS=&amp;quot;0175155789&amp;quot;&#xA;NET_IPAD=&amp;quot;192.168.10.133&amp;quot;&#xA;NET_MASK=&amp;quot;255.255.255.0&amp;quot;&#xA;NET_GETW=&amp;quot;192.168.10.1&amp;quot;&#xA;NET_APAD=&amp;quot;192.168.10.1&amp;quot;&#xA;######################################################################&#xA;&#xA;其实可以通过find()搜索play_wifi文件内&#39;=&#39;号位置后采集,然后将采集的位置加1即可,空值在bool中标识为假&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python&#xA;import os,time&#xA;def shell_command(command):&#xA;    command_info = os.system(command)&#xA;    if command_info != 0:&#xA;    print &#39;command error -&amp;gt; &#39;,command&#xA;    return command_info&#xA;def config_file_command(command_member):&#xA;    f = open(&#39;/root/.danoo_player_wifi&#39;,&#39;r&#39;)&#xA;    str1 = f.readline().strip()&#xA;    while len(str1):&#xA;    str1 = f.readline().strip()&#xA;    try:&#xA;        file_str1 = str1.split(&#39;=&#39;)&#xA;        file_member = file_str1.index(command_member)&#xA;        return_str1 = file_str1[file_member+1].strip(&#39;&amp;quot;&#39;)  &#xA;    except ValueError:&#xA;        continue&#xA;    try:&#xA;    return return_str1&#xA;    except UnboundLocalError:&#xA;    print &#39;.danoo_player_wifi Config File Error&#39;&#xA;    exit(0)&#xA;    f.close()&#xA;def device_info():&#xA;    shell_command(&#39;ifconfig eth1 down&#39;)&#xA;    if shell_command(&#39;ifconfig -a eth1&#39;) != 0:&#xA;    print &#39;eth1 Device not found -&amp;gt; exit&#39;&#xA;    exit(0)&#xA;    SHELL_ID = shell_command(&#39;ifconfig eth1 up&#39;)&#xA;    ETH_LABLE_A=0&#xA;    while SHELL_ID != 0:&#xA;    SHELL_ID = shell_command(&#39;ifconfig eth1 up&#39;)&#xA;    if ETH_LABLE_A == 1:&#xA;        time.sleep(6)&#xA;    elif ETH_LABLE_A &amp;gt; 1 and ETH_LABLE_A &amp;lt; 6: &#xA;        time.sleep(10)&#xA;    elif ETH_LABLE_A == 6:&#xA;        print &#39;eth1 Device UP Error -&amp;gt; exit&#39;&#xA;        exit(1)&#xA;    ETH_LABLE_A = ETH_LABLE_A + 1&#xA;def eth_dhcp():&#xA;    shell_command(&#39;dhclient -r eth1&#39;)&#xA;    shell_command(&#39;dhclient eth1&#39;)&#xA;def check_net():&#xA;    PING_ADD = &#39;ping -c 3&#39;+&#39; &#39;+NET_APAD&#xA;    PING_INFO = shell_command(PING_ADD)&#xA;    return PING_INFO&#xA;if bool(config_file_command(&#39;NET_MODE&#39;)):&#xA;    NET_MODE = config_file_command(&#39;NET_MODE&#39;)&#xA;else:&#xA;    print &#39;NET_MODE Config Error&#39;&#xA;    exit(1)&#xA;if bool(config_file_command(&#39;NET_AUDH&#39;)):&#xA;    NET_AUDH = config_file_command(&#39;NET_AUDH&#39;)&#xA;else:&#xA;    print &#39;NET_AUDH Config Error&#39;&#xA;    exit(1)&#xA;if bool(config_file_command(&#39;NET_SSID&#39;)):&#xA;    NET_SSID = config_file_command(&#39;NET_SSID&#39;)&#xA;else:&#xA;    print &#39;NET_SSID Config Error&#39;&#xA;    exit(1)&#xA;if bool(config_file_command(&#39;NET_PASS&#39;)):&#xA;    NET_PASS = config_file_command(&#39;NET_PASS&#39;)&#xA;else:&#xA;    print &#39;NET_PASS Config Error&#39;&#xA;    exit(1)&#xA;NET_IPAD = config_file_command(&#39;NET_IPAD&#39;)&#xA;NET_MASK = config_file_command(&#39;NET_MASK&#39;)&#xA;if bool(config_file_command(&#39;NET_GETW&#39;)):&#xA;    NET_GETW = config_file_command(&#39;NET_GETW&#39;)&#xA;else:&#xA;    print &#39;NET_GETW Config Error&#39;&#xA;    exit(1)&#xA;if bool(config_file_command(&#39;NET_APAD&#39;)):&#xA;    NET_APAD = config_file_command(&#39;NET_APAD&#39;)&#xA;else:&#xA;    print &#39;NET_APAD Config Error&#39;&#xA;    exit(1)&#xA;def eth_dhcp():&#xA;    shell_command(&#39;dhclient -r eth1&#39;)&#xA;    shell_command(&#39;dhclient eth1&#39;)&#xA;##################################################################&#xA;CHECK_NET_INFO = check_net()&#xA;while CHECK_NET_INFO:&#xA;    if NET_MODE == &#39;wep&#39;:&#xA;    pass&#xA;    #########################################################################&#xA;    elif NET_MODE == &#39;wpa&#39;:&#xA;    pass&#xA;    #########################################################################&#xA;else:&#xA;    print &#39;network ok&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenVPN-时间错误会造成VPN无法正常连接</title>
      <link>http://www.nljb.net/default/OpenVPN-%E6%97%B6%E9%97%B4%E9%94%99%E8%AF%AF%E4%BC%9A%E9%80%A0%E6%88%90VPN%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;OpenVPN -&amp;gt; 时间错误会造成VPN无法正常连接&lt;/p&gt;&#xA;&#xA;&lt;p&gt;连接openvpn时出现错误提示：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;TLS_ERROR: BIO read tls_read_plaintext error: error:140890B2:&#xA;SSL routines:SSL3_GET_CLIENT_CERTIFICATE:no certificate returned&#xA;TLS Error: TLS object -&amp;gt; incoming plaintext read error&#xA;TLS Error: TLS handshake failed&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这个似乎是提示系统时间和证书时间不一致，具体解决措施为：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.修改vps时间与本地时间一致&#xA;2.重启vps&#xA;3.重新连接openvpn试试&#xA;4.如果依旧不能连接openvpn，可以在vps上重新生成一个新的证书。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux下Shell脚本输出带颜色文字</title>
      <link>http://www.nljb.net/default/Linux%E4%B8%8BShell%E8%84%9A%E6%9C%AC%E8%BE%93%E5%87%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%E6%96%87%E5%AD%97/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/Linux下Shell脚本输出带颜色文字/1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;文本终端的颜色可以使用“ANSI非常规字符序列”来生成。举例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;echo -e &amp;quot;\033[44;37;5m ME \033[0m COOL&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;以上命令设置作用如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;背景色为蓝色，前景色为白色，字体闪烁，输出字符“ME”，然后重新设置屏幕到缺省设置，输出字符 “COOL”。&#xA;“e”是命令 echo 的一个可选项，它用于激活特殊字符的解析器。&#xA;“\033”引导非常规字符序列。&#xA;“m”意味着设置属性然后结束非常规字符序列，这个例子里真正有效的字符是“44;37;5” 和“0”。&#xA;修改“44;37;5”可以生成不同颜色的组合，数值和编码的前后顺序没有关系。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;可以选择的编码如下所示：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;　　编码 颜色/动作&#xA;　　0 重新设置属性到缺省设置&#xA;　　1 设置粗体&#xA;　　2 设置一半亮度(模拟彩色显示器的颜色)&#xA;　　4 设置下划线(模拟彩色显示器的颜色)&#xA;　　5 设置闪烁&#xA;　　7 设置反向图象&#xA;　　22 设置一般密度&#xA;　　24 关闭下划线&#xA;　　25 关闭闪烁&#xA;　　27 关闭反向图象&#xA;　　30 设置黑色前景&#xA;　　31 设置红色前景&#xA;　　32 设置绿色前景&#xA;　　33 设置棕色前景&#xA;　　34 设置蓝色前景&#xA;　　35 设置紫色前景&#xA;　　36 设置青色前景&#xA;　　37 设置白色前景&#xA;　　38 在缺省的前景颜色上设置下划线&#xA;　　39 在缺省的前景颜色上关闭下划线&#xA;　　40 设置黑色背景&#xA;　　41 设置红色背景&#xA;　　42 设置绿色背景&#xA;　　43 设置棕色背景&#xA;　　44 设置蓝色背景&#xA;　　45 设置紫色背景&#xA;　　46 设置青色背景&#xA;　　47 设置白色背景&#xA;　　49 设置缺省黑色背景&#xA;　　例如：在编译脚本文件时，对服务启动完成后的OK字符串设置成绿色&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-驱动加载</title>
      <link>http://www.nljb.net/default/Linux-%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;一般使用 modprobe ，因为 insmod 不考虑 mod 的模块依赖问题。&#xA;&#xA;modprobe 会检索模块依赖关系后载入依赖的模块（当然并不是绝对都能……）&#xA;&#xA;不过 modprobe 只能载入 /lib/modules/&amp;lt;kernel ver&amp;gt;/ 里面的模块。而且这个模块必须在这个目录里面的配置文件里面注册了&#xA;&#xA;使用分析可载入模块的相依性 depmod -a&#xA;&#xA;删除模块可以使用rmmod xxx 或者 modprobe -r  xxx 即可&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;　depmod可检测模块的相依性，供modprobe在安装模块时使用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/etc/modprobe.d/50-blacklist.conf   ---&amp;gt;   blacklist vt6656_stage&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;　depmod [-adeisvV][-m &amp;lt;文件&amp;gt;][--help][模块名称]&#xA;    -a或--all 分析所有可用的模块。&#xA;　　-d或debug 执行排错模式。&#xA;　　-e 输出无法参照的符号。&#xA;　　-i 不检查符号表的版本。&#xA;　　-m&amp;lt;文件&amp;gt;或system-map&amp;lt;文件&amp;gt; 使用指定的符号表文件。&#xA;　　-s或--system-log 在系统记录中记录错误。&#xA;　　-v或--verbose 执行时显示详细的信息。&#xA;　　-V或--version 显示版本信息。&#xA;　　--help 显示帮助。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-通过文件修改密码</title>
      <link>http://www.nljb.net/default/Linux-%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1,/etc/rc.d/rc.local 此文件可以写系统启动后开启的命令&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;如 su – root -c ‘/home/mysql/ultserver/userver &amp;amp;’&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2,/etc/profile 系统环境变量设置点&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;export JAVA_HOME=/usr/java/jdk1.5.0_06&#xA;export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JABA_HOME/lib/tools.jar&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3,.bashrc 或 .bash_profile 设置用户而不是系统的环境变量&lt;/p&gt;&#xA;&#xA;&lt;p&gt;4,/etc/shadow 内容包括用户及被加密的密码以及其它/etc/passwd 不能包括的信息，比如用户的有效期限&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;einan:$1$VE.Mq2Xf$2c9Qi7EQ9JP8GKF8gH7PB1:13072:0:99999:7:::&#xA;linuxsir:$1$IPDvUhXP$8R6J/VtPXvLyXxhLWPrnt/:13072:0:99999:7::13108:&#xA;&#xA;第一字段：用户名（也被称为登录名），在/etc/shadow中，用户名和/etc/passwd 是相同的，这样就把passwd 和shadow&#xA;中用的用户记录联系在一起；这个字段是非空的；&#xA;第二字段：密码（已被加密），如果是有些用户在这段是x，表示这个用户不能登录到系统；这个字段是非空的；&#xA;第三字段：上次修改口令的时间；这个时间是从1970年01月01日算起到最近一次修改口令的时间间隔（天数），&#xA;您可以通过passwd 来修改用户的密码，然后查看/etc/shadow中此字段的变化；&#xA;第四字段：两次修改口令间隔最少的天数；如果设置为0,则禁用此功能；也就是说用户必须经过多少天才能修改其口令；&#xA;此项功能用处不是太大；默认值是通过/etc/login.defs文件定义中获取，PASS_MIN_DAYS 中有定义；&#xA;第五字段：两次修改口令间隔最多的天数；这个能增强管理员管理用户口令的时效性，应该说在增强了&#xA;系统的安全性；如果是系统默认值，是在添加用户时由/etc/login.defs文件定义中获取，在 &#xA;PASS_MAX_DAYS 中定义；&#xA;第六字段：提前多少天警告用户口令将过期；当用户登录系统后，系统登录程序提醒用户口令将&#xA;要作废；如果是系统默认值，是在添加用户时由/etc/login.defs文件定义中获取，&#xA;在PASS_WARN_AGE 中定义；&#xA;第七字段：在口令过期之后多少天禁用此用户；此字段表示用户口令作废多少天后，&#xA;系统会禁用此用户，也就是说系统会不能再让此用户登录，也不会提示用户过期，是完全禁用；&#xA;第八字段：用户过期日期；此字段指定了用户作废的天数（从1970年的1月1日开始的天数），&#xA;如果这个字段的值为空，帐号永久可用；&#xA;第九字段：保留字段，目前为空，以备将来Linux发展之用；如果更为详细的，&#xA;请用 man shadow来查看帮助，您会得到更为详尽的资料；&#xA;&#xA;/etc/password 帐户花名册&#xA;&#xA;beinan:x:500:500:beinan sun:/home/beinan:/bin/bash&#xA;linuxsir:x:505:502:linuxsir open,linuxsir office,13898667715:/home/linuxsir:/bin/bash&#xA;beinan:x:500:500:beinan sun:/home/beinan:/bin/bash&#xA;linuxsir:x:501:502::/home/linuxsir:/bin/bash&#xA;&#xA;第一字段：用户名（也被称为登录名）；在上面的例子中，我们看到这两个用户的用户名分别是 &#xA;beinan 和linuxsir；&#xA;第二字段：口令；在例子中我们看到的是一个x，其实密码已被映射到/etc/shadow 文件中；&#xA;第三字段：UID ；请参看本文的UID的解说；&#xA;第四字段：GID；请参看本文的GID的解说；&#xA;第五字段：用户名全称，这是可选的，可以不设置，在beinan这个用户中，用户的全称是beinan sun ；&#xA;而linuxsir 这个用户是没有设置全称；&#xA;第六字段：用户的家目录所在位置；beinan 这个用户是/home/beinan ，而linuxsir 这个用户是&#xA;/home/linuxsir ；&#xA;第七字段：用户所用SHELL 的类型，beinan和linuxsir 都用的是 bash ；所以设置为/bin/bash ； &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;5,/etc/init.d/：所有服务的预设启动 script 都是放在这里的，例如要启动或者关闭 iptables 的话：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/etc/init.d/iptables start &#xA;/etc/init.d/iptables stop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;6./etc/inittab 设置启动level，如果要从图形界面启动切换到字符界面就需要修改这个文件&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-通过-proc-查看硬件信息</title>
      <link>http://www.nljb.net/default/Linux-%E9%80%9A%E8%BF%87-proc-%E6%9F%A5%E7%9C%8B%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;用硬件检测程序kudzu探测新硬件：service kudzu start ( or restart)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;查看CPU信息：cat /proc/cpuinfo&#xA;查看板卡信息：cat /proc/pci&#xA;查看PCI信息：lspci (相比cat /proc/pci更直观）&#xA;查看内存信息：cat /proc/meminfo&#xA;查看USB设备：cat /proc/bus/usb/devices&#xA;查看键盘和鼠标:cat /proc/bus/input/devices&#xA;查看系统硬盘信息和使用情况：fdisk &amp;amp; disk - l &amp;amp; df&#xA;查看各设备的中断请求(IRQ):cat /proc/interrupts&#xA;查看系统体系结构：uname -a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在LINUX环境开发驱动程序，首先要探测到新硬件，接下来就是开发驱动程序。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;常用命令整理如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;用硬件检测程序kudzu探测新硬件：service kudzu start ( or restart)&#xA;查看CPU信息：cat /proc/cpuinfo&#xA;查看板卡信息：cat /proc/pci&#xA;查看PCI信息：lspci (相比cat /proc/pci更直观）&#xA;查看内存信息：cat /proc/meminfo&#xA;查看USB设备：cat /proc/bus/usb/devices&#xA;查看键盘和鼠标:cat /proc/bus/input/devices&#xA;查看系统硬盘信息和使用情况：fdisk &amp;amp; disk - l &amp;amp; df&#xA;查看各设备的中断请求(IRQ):cat /proc/interrupts&#xA;查看系统体系结构：uname –a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;看看系统认出的盘先： cat /proc/partitions&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;dmidecode查看硬件信息，包括bios、cpu、内存等信息&#xA;dmesg | more 查看硬件信息&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;对于“/proc”中文件可使用文件查看命令浏览其内容，文件中包含系统特定信息：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Cpuinfo 主机CPU信息&#xA;Dma 主机DMA通道信息&#xA;Filesystems 文件系统信息&#xA;Interrupts 主机中断信息&#xA;Ioprots 主机I/O端口号信息&#xA;Meninfo 主机内存信息&#xA;Version Linux内存版本信息&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-系统时区修改</title>
      <link>http://www.nljb.net/default/Linux-%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%8C%BA%E4%BF%AE%E6%94%B9/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 执行&#xA;tzselect&#xA;&#xA;// 回车后会有选项提示&#xA;TZ=&#39;Asia/Shanghai&#39;;export TZ&#xA;// 即时生效 亚洲上海CST时间&#xA;&#xA;// 时区设置使重启后依然设生效&#xA;hwclock -w&#xA;&#xA;// 时区配置查询文件&#xA;/etc/sysconfig/clock&#xA;&#xA;// 时区配置文件：&#xA;cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &#xA;&#xA;// 随后保存即可&#xA;hwclock -w&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-内核升级-内核编译步骤</title>
      <link>http://www.nljb.net/default/Linux-%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;执行命令：&#xA;#make clean&#xA;然后是：&#xA;#make mrproper&#xA;进入图形配置界面。在终端敲入以下命令：&#xA;#make menuconfig&#xA;设置完毕，进入编译阶段。如果补丁和配置正确，下面几步不会出错，按顺序执行，等待完成即可。&#xA;#make bzImage&#xA;#make modules&#xA;#make modules_install&#xA;#make install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-修改MAC地址方法</title>
      <link>http://www.nljb.net/default/Linux-%E4%BF%AE%E6%94%B9MAC%E5%9C%B0%E5%9D%80%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1.用命令行临时解决：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#sudo ifconfig eth0 down&#xA;#sudo ifconfig eth0 hw ether AA:BB:CC:DD:EE:FF&#xA;#sudo ifconfig eth0 up&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.启动自行修改&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#sudo vi /etc/network/interfaces&#xA;在eth0的配置中加入如下&#xA;hwaddress ether AA:BB:CC:DD:EE:FF&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;方法一：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.关闭网卡设备&#xA;ifconfig eth0 down&#xA;&#xA;2.修改MAC地址&#xA;ifconfig eth0 hw ether MAC地址&#xA;&#xA;3.重启网卡&#xA;ifconfig eth0 up&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;方法二：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在./etc/sysconfig/network-scripts/ifcfg-eth0中加入下面一句话：&#xA;&#xA;MACADDR=00:AA:BB:CC:DD:EE&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;方法三：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Linux 下如何更改网卡MAC地址 &#xA;&#xA;简单的办法是在/etc/rc.d/rc.sysinit文件中加入那些命令:&#xA;&#xA;ifconfig eth0 down&#xA;ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx&#xA;ifconfig eth0 up&#xA;&#xA;因为这个脚本运行在network之前,所以,MAC跟IP就是对应的&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;方法四：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Linux下的MAC地址更改,首先用命令关闭网卡设备。&#xA;&#xA;/sbin/ifconfig eth0 down&#xA;&#xA;然后就可以修改MAC地址了。&#xA;&#xA;/sbin/ifconfig eth0 hw ether xxxxxxxxxx （其中xx是您要修改的地址）&#xA;&#xA;最后重新启用网卡&#xA;&#xA;/sbin/ifconfig eth0 up&#xA;&#xA;网卡的MAC地址更改就完成了&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-下隐藏鼠标的方法</title>
      <link>http://www.nljb.net/default/Linux-%E4%B8%8B%E9%9A%90%E8%97%8F%E9%BC%A0%E6%A0%87%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近工作需要，调查了一下如何在界面启动以后不显示鼠标光标，但是触摸屏可以正常工作，现将方法总结一下:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1,就是使用unclutter,这个可以起作用，但是不是我想要的效果；&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;./unclutter: usage:&#xA;    -display &amp;lt;display&amp;gt;&#xA;    -idle &amp;lt;seconds&amp;gt;        time between polls to detect idleness.&#xA;    -keystroke        wait for keystroke before idling.&#xA;    -jitter &amp;lt;pixels&amp;gt;    pixels mouse can twitch without moving&#xA;    -grab            use grabpointer method not createwindow&#xA;    -reset            reset the timer whenever cursor becomes&#xA;            visible even if it hasn&#39;t moved&#xA;     -root                   apply to cursor on root window too&#xA;    -onescreen        apply only to given screen of display&#xA;     -visible               ignore visibility events&#xA;     -noevents              don&#39;t send pseudo events&#xA;    -regex            name or class below is a regular expression&#xA;    -not names...        don&#39;t apply to windows whose wm-name begins.&#xA;        (must be last argument)&#xA;    -notname names...    same as -not names...&#xA;    -notclass classes...    don&#39;t apply to windows whose wm-class begins.&#xA;        (must be last argument, cannot be used with&#xA;        -not or -notname)&#xA;&#xA;原因事它总有一刹那是出现鼠标的；&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2：xsetroot -cursor blank.bmp blank.bmp&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;其中blank.bmp是使用bitmap &amp;amp;制作的的一个空白鼠标；&#xA;效果是可以在桌面上起作用，但是在程序界面鼠标依然出现；&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3：setterm -cursor off关闭终端界面的光标；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;4：oneko一个类似于unclutter的程序；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;5：在调用startx启动的桌面系统中给XSERVER传递参数serverargs=&amp;rdquo; -nocursor &amp;ldquo;，这个可以起作用；&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在211行执行xinit的地方, 在 &amp;quot;$server&amp;quot;后面加上 -nocursor&#xA;xinit &amp;quot;$client&amp;quot; $clientargs -- &amp;quot;$server&amp;quot; -nocursor  $display $serverargs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-下添加路由的方法</title>
      <link>http://www.nljb.net/default/Linux-%E4%B8%8B%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;一,使用route 命令添加&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;使用route 命令添加的路由，机器重启或者网卡重启后路由就失效了，方法：&#xA;&#xA;//添加到主机的路由&#xA;# route add –host 192.168.168.110 dev eth0&#xA;# route add –host 192.168.168.119 gw 192.168.168.1&#xA;//添加到网络的路由&#xA;# route add –net IP netmask MASK eth0&#xA;# route add –net IP netmask MASK gw IP&#xA;# route add –net IP/24 eth1&#xA;//添加默认网关&#xA;# route add default gw IP&#xA;//删除路由&#xA;# route del –host 192.168.168.110 dev eth0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;二,在linux下设置永久路由的方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.在/etc/rc.local里添加&#xA;方法：&#xA;route add -net 192.168.3.0/24 dev eth0&#xA;route add -net 192.168.2.0/24 gw 192.168.3.254&#xA;&#xA;2.在/etc/sysconfig/network里添加到末尾&#xA;方法：GATEWAY=gw-ip 或者GATEWAY=gw-dev&#xA;&#xA;3./etc/sysconfig/static-router :&#xA;any net x.x.x.x/24 gw y.y.y.y &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-下强制Copy文件</title>
      <link>http://www.nljb.net/default/Linux-%E4%B8%8B%E5%BC%BA%E5%88%B6Copy%E6%96%87%E4%BB%B6/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Linux下默认cp命令是有别名的(alias cp=&amp;lsquo;cp -i&amp;rsquo;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;无法在复制时强制覆盖，即使你用 -f 参数也无法强制覆盖文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面提供几个从网上找的Linux下cp命令覆盖的方法。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1) 取消cp的alias（放心这不是永久生效）：&#xA;#unalias cp&#xA;#cp a /test/a&#xA;&#xA;2) 加反斜杠 \cp 执行cp命令时不走alias：&#xA;#\cp a /test/a&#xA;&#xA;3）另外一个有意思的方法：&#xA;#yes|cp a /test/a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-date-命令使用技巧</title>
      <link>http://www.nljb.net/default/Linux-date-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;[root@localhost ~]# date --set &amp;quot;1/1/09 00:01&amp;quot; &amp;lt;== （月/日/年时:分:秒）&#xA;[root@localhost ~]# date 012501012009.30 &amp;lt;== 月日时分年.秒&#xA;Linux查看日期时间命令 date 把系统时间设置为以下时间： date -s 2010-04-07 date -s 10:20:33&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;date命令&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;　　date命令的功能是显示和设置系统日期和时间。 &#xA;　　该命令的一般格式为： date [选项] 显示时间格式（以+开头，后面接格式） &#xA;　　date 设置时间格式 &#xA;　　命令中各选项的含义分别为： &#xA;　　-d datestr, --date datestr 显示由datestr描述的日期 &#xA;　　-s datestr, --set datestr 设置datestr 描述的日期 &#xA;　　-u, --universal 显示或设置通用时间 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;时间域&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;　　% H 小时（00..23） &#xA;　　% I 小时（01..12） &#xA;　　% k 小时（0..23） &#xA;　　% l 小时（1..12） &#xA;　　% M 分（00..59） &#xA;　　% p 显示出AM或PM &#xA;　　% r 时间（hh：mm：ss AM或PM），12小时 &#xA;　　% s 从1970年1月1日00：00：00到目前经历的秒数 &#xA;　　% S 秒（00..59） &#xA;　　% T 时间（24小时制）（hh:mm:ss） &#xA;　　% X 显示时间的格式（％H:％M:％S） &#xA;　　% Z 时区 日期域 &#xA;　　% a 星期几的简称（ Sun..Sat） &#xA;　　% A 星期几的全称（ Sunday..Saturday） &#xA;　　% b 月的简称（Jan..Dec） &#xA;　　% B 月的全称（January..December） &#xA;　　% c 日期和时间（ Mon Nov 8 14：12：46 CST 1999） &#xA;　　% d 一个月的第几天（01..31） &#xA;　　% D 日期（mm／dd／yy） &#xA;　　% h 和%b选项相同 &#xA;　　% j 一年的第几天（001..366） &#xA;　　% m 月（01..12） &#xA;　　% w 一个星期的第几天（0代表星期天） &#xA;　　% W 一年的第几个星期（00..53，星期一为第一天） &#xA;　　% x 显示日期的格式（mm/dd/yy） &#xA;　　% y 年的最后两个数字（ 1999则是99） &#xA;　　% Y 年（例如：1970，1996等） &#xA;　　需要特别说明的是，只有超级用户才能用date命令设置时间，一般用户只能用date命令显示时间。 &#xA;　　例1：用指定的格式显示时间。 &#xA;　　$ date ‘+This date now is =&amp;gt;%x ，time is now =&amp;gt;%X ，thank you !&#39; &#xA;　　This date now is =&amp;gt;11/12/99 ，time is now =&amp;gt;17:53:01 ，thank you ! &#xA;　　例2：用预定的格式显示当前的时间。 &#xA;　　# date &#xA;　　Fri Nov 26 15：20：18 CST 1999 &#xA;　　例3：设置时间为下午14点36分。 &#xA;　　# date -s 14:36:00 &#xA;　　Fri Nov 26 14：15：00 CST 1999 &#xA;　　例4：设置时间为1999年11月28号。 &#xA;　　# date -s 991128 &#xA;　　Sun Nov 28 00：00：00 CST 1999 &#xA;    例5：设置一天前&#xA;    date --date &amp;quot;1 days ago&amp;quot; +&amp;quot;%Y-%m-%d&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux ALSA 配置</title>
      <link>http://www.nljb.net/default/Linux-ALSA-%E9%85%8D%E7%BD%AE/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;查看系统audio设备查看audio设备摘要信息&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;aplay -l&#xA;&#xA;**** List of PLAYBACK Hardware Devices ****&#xA;card 0: Intel [HDA Intel], device 0: ALC662 rev1 Analog [ALC662 rev1 Analog]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;card 0: Intel [HDA Intel], device 1: ALC662 rev1 Digital [ALC662 rev1 Digital]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;card 1: NVidia [HDA NVidia], device 3: HDMI 0 [HDMI 0]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;card 1: NVidia [HDA NVidia], device 7: HDMI 0 [HDMI 0]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;card 1: NVidia [HDA NVidia], device 8: HDMI 0 [HDMI 0]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;card 1: NVidia [HDA NVidia], device 9: HDMI 0 [HDMI 0]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;查看audio详细信息&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;aplay -L&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可能输出&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;null&#xA;    Discard all samples (playback) or generate zero samples (capture)&#xA;front:CARD=Intel,DEV=0&#xA;    HDA Intel, ALC662 rev1 Analog&#xA;    Front speakers&#xA;surround40:CARD=Intel,DEV=0&#xA;    HDA Intel, ALC662 rev1 Analog&#xA;    4.0 Surround output to Front and Rear speakers&#xA;surround41:CARD=Intel,DEV=0&#xA;    HDA Intel, ALC662 rev1 Analog&#xA;    4.1 Surround output to Front, Rear and Subwoofer speakers&#xA;surround50:CARD=Intel,DEV=0&#xA;    HDA Intel, ALC662 rev1 Analog&#xA;    5.0 Surround output to Front, Center and Rear speakers&#xA;surround51:CARD=Intel,DEV=0&#xA;    HDA Intel, ALC662 rev1 Analog&#xA;    5.1 Surround output to Front, Center, Rear and Subwoofer speakers&#xA;surround71:CARD=Intel,DEV=0&#xA;    HDA Intel, ALC662 rev1 Analog&#xA;    7.1 Surround output to Front, Center, Side, Rear and Woofer speakers&#xA;iec958:CARD=Intel,DEV=0&#xA;    HDA Intel, ALC662 rev1 Digital&#xA;    IEC958 (S/PDIF) Digital Audio Output&#xA;hdmi:CARD=NVidia,DEV=0&#xA;    HDA NVidia, HDMI 0&#xA;    HDMI Audio Output&#xA;hdmi:CARD=NVidia,DEV=1&#xA;    HDA NVidia, HDMI 0&#xA;    HDMI Audio Output&#xA;hdmi:CARD=NVidia,DEV=2&#xA;    HDA NVidia, HDMI 0&#xA;    HDMI Audio Output&#xA;hdmi:CARD=NVidia,DEV=3&#xA;    HDA NVidia, HDMI 0&#xA;    HDMI Audio Output&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;配置文件,最简单的/etc/asound.conf格式如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;defaults.ctl.card 0&#xA;defaults.pcm.card 0&#xA;defaults.timer.card 0&#xA;&#xA;pcm.!default {&#xA;    type hw&#xA;    card 0&#xA;    device 0&#xA;}&#xA;&#xA;ctl.!default {&#xA;    type hw&#xA;    card 0&#xA;    device 0&#xA;}&#xA;&#xA;其中card和device的确定从aplay -l命令得到。对比aplaya -l的输出，可以看到上面的配置文件使用了Intel的音频设备。&#xA;设置默认输出设备&#xA;首先根据aplay -l的输出来确定声卡ID和设备ID&#xA;把Intel模拟输出作为默认的audio输出设备&#xA;&#xA;defaults.ctl.card 0&#xA;defaults.pcm.card 0&#xA;defaults.timer.card 0&#xA;&#xA;pcm.!default {&#xA;    type hw&#xA;    card 0&#xA;    device 0&#xA;}&#xA;&#xA;ctl.!default {&#xA;    type hw&#xA;    card 0&#xA;    device 0&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;把Nvidia HDMI数字输出作为默认的audio输出设备&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;defaults.ctl.card 1&#xA;defaults.pcm.card 1&#xA;defaults.timer.card 1&#xA;&#xA;pcm.!default {&#xA;    type hw&#xA;    card 1&#xA;    device 7&#xA;}&#xA;&#xA;ctl.!default {&#xA;    type hw&#xA;    card 1&#xA;    device 7&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;测试audio设备测试指定audio设备&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;speaker-test -D front:Intel -c2 -r44100 -FS16_LE -twav&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;测试默认audio设备&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;speaker-test -c2 -r44100 -FS16_LE -twav&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;调节audio设备&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;alsamixer -c 0 &amp;lt;---[声卡编号]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;配置文件的保存和还原&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;alsactl store -f /var/lib/alsa/asound.state&#xA;alsactl restore -f /var/lib/alsa/asound.state&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>HTTP-Client-Transport</title>
      <link>http://www.nljb.net/default/HTTP-Client-Transport/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 为什么[Client]结构定义了[RoundTripper]却使用[&amp;amp;http.Transport]赋值&#xA;http.Client{&#xA;    Transport: &amp;amp;http.Transport{&#xA;...&#xA;&#xA;// Client 结构&#xA;type Client struct {&#xA;    // Transport specifies the mechanism by which individual&#xA;    // HTTP requests are made.&#xA;    // If nil, DefaultTransport is used.&#xA;    Transport RoundTripper&#xA;...&#xA;&#xA;// Transport 结构&#xA;type Transport struct {&#xA;...&#xA;&#xA;// RoundTripper 竟然是个接口&#xA;type RoundTripper interface {&#xA;    // RoundTrip executes a single HTTP transaction, returning&#xA;    // the Response for the request req.  RoundTrip should not&#xA;    // attempt to interpret the response.  In particular,&#xA;    // RoundTrip must return err == nil if it obtained a response,&#xA;    // regardless of the response&#39;s HTTP status code.  A non-nil&#xA;    // err should be reserved for failure to obtain a response.&#xA;    // Similarly, RoundTrip should not attempt to handle&#xA;    // higher-level protocol details such as redirects,&#xA;    // authentication, or cookies.&#xA;    //&#xA;    // RoundTrip should not modify the request, except for&#xA;    // consuming and closing the Body. The request&#39;s URL and&#xA;    // Header fields are guaranteed to be initialized.&#xA;    RoundTrip(*Request) (*Response, error)&#xA;}&#xA;...&#xA;&#xA;// 接口中实现的方法是属于[Transport]的&#xA;func (t *Transport) RoundTrip(req *Request) (resp *Response, err error)&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;所以&amp;hellip;.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-读取文件信息-FileInfo-and-MD5</title>
      <link>http://www.nljb.net/default/Golang-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF-FileInfo-and-MD5/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;import &amp;quot;os&amp;quot;&#xA;import &amp;quot;fmt&amp;quot;&#xA;import &amp;quot;crypto/md5&amp;quot;&#xA;import &amp;quot;io&amp;quot;&#xA;&#xA;func main() {&#xA;&#xA;    fi,err:= os.Lstat(&amp;quot;Time.go&amp;quot;) &#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;info ERROR&amp;quot;,err) &#xA;    }&#xA;    fileHandle,err := os.Open(&amp;quot;Time.go&amp;quot;)&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;open ERROR&amp;quot;,err) &#xA;    }&#xA;    defer fileHandle.Close()&#xA;    h := md5.New()&#xA;    _, err = io.Copy(h,fileHandle)&#xA;    fmt.Println(fi.Name())&#xA;    fmt.Println(fi.Size())&#xA;    //fmt.Println(fi.Mode().Perm())&#xA;    //fmt.Println(fi.ModTime())&#xA;    //fmt.Println(fi.IsDir())&#xA;    fmt.Printf(&amp;quot;%x&amp;quot;, h.Sum(nil))&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-读取字符串流-ICCID</title>
      <link>http://www.nljb.net/default/Golang-%E8%AF%BB%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81-ICCID/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// CCID&#xA;if *ccid {&#xA;    v := Com(*device, &amp;quot;AT+CRSM=176,12258,0,0,10\r&amp;quot;)&#xA;    d := bytes.NewBuffer(v)&#xA;    for {&#xA;    l, e := d.ReadString(&#39;\n&#39;)&#xA;    if e == io.EOF {&#xA;        break&#xA;    } else if e != nil {&#xA;        os.Exit(2)&#xA;    }&#xA;    if strings.Contains(l, &amp;quot;+CRSM&amp;quot;) {&#xA;        line := strings.Split(z.Trim(l), &amp;quot;,&amp;quot;)&#xA;        id := strings.Trim(z.Trim(line[2]), &amp;quot;\&amp;quot;&amp;quot;)&#xA;        fmt.Printf(&amp;quot;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n&amp;quot;,&#xA;        (id[1]), (id[0]),&#xA;        (id[3]), (id[2]),&#xA;        (id[5]), (id[4]),&#xA;        (id[7]), (id[6]),&#xA;        (id[9]), (id[8]),&#xA;        (id[11]), (id[10]),&#xA;        (id[13]), (id[12]),&#xA;        (id[15]), (id[14]),&#xA;        (id[17]), (id[16]),&#xA;        (id[19]))&#xA;&#xA;    }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-语言文件操作</title>
      <link>http://www.nljb.net/default/Golang-%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;收集整理了一下的代码.参照着使用吧,自己做个记录.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Open(name string) (file *File, err error),*File 是实现了 io.Reader这个接口&#xA;&#xA;byte[] 转化为 bytes.Buffer:bytes.NewBuffer([]byte).&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一、建立与打开&lt;/p&gt;&#xA;&#xA;&lt;p&gt;建立文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Create(name string) (file *File, err Error)&#xA;&#xA;func NewFile(fd int, name string) *File&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：http://golang.org/pkg/os/#Create&lt;/p&gt;&#xA;&#xA;&lt;p&gt;打开文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Open(name string) (file *File, err Error)&#xA;&#xA;func OpenFile(name string, flag int, perm uint32) (file *File, err Error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：http://golang.org/pkg/os/#Open&lt;/p&gt;&#xA;&#xA;&lt;p&gt;二、写文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;写文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (file *File) Write(b []byte) (n int, err Error)&#xA;&#xA;func (file *File) WriteAt(b []byte, off int64) (n int, err Error)&#xA;&#xA;func (file *File) WriteString(s string) (ret int, err Error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：http://golang.org/pkg/os/#File.Write&lt;/p&gt;&#xA;&#xA;&lt;p&gt;写文件示例代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;func main() {&#xA;    userFile := &amp;quot;test.txt&amp;quot;&#xA;    fout,err := os.Create(userFile)&#xA;    defer fout.Close()&#xA;    if err != nil {&#xA;        fmt.Println(userFile,err)&#xA;        return&#xA;    }&#xA;    for i:= 0;i&amp;lt;10;i++ {&#xA;        fout.WriteString(&amp;quot;Just a test!\r\n&amp;quot;)&#xA;        fout.Write([]byte(&amp;quot;Just a test!\r\n&amp;quot;))&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;三、读文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;读文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (file *File) Read(b []byte) (n int, err Error)&#xA;&#xA;func (file *File) ReadAt(b []byte, off int64) (n int, err Error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：http://golang.org/pkg/os/#File.Read&lt;/p&gt;&#xA;&#xA;&lt;p&gt;读文件示例代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;func main() {&#xA;    userFile := &amp;quot;test.txt&amp;quot;&#xA;    fin,err := os.Open(userFile)&#xA;    defer fin.Close()&#xA;    if err != nil {&#xA;        fmt.Println(userFile,err)&#xA;        return&#xA;    }&#xA;    buf := make([]byte, 1024)&#xA;    for{&#xA;        n, _ := fin.Read(buf)&#xA;        if0 == n { break }&#xA;        os.Stdout.Write(buf[:n])&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;四、删除文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Remove(name string) Error&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用os库&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    fi, err := os.Open(&amp;quot;input.txt&amp;quot;)&#xA;    if err != nil { panic(err) }&#xA;    defer fi.Close()&#xA;&#xA;    fo, err := os.Create(&amp;quot;output.txt&amp;quot;)&#xA;    if err != nil { panic(err) }&#xA;    defer fo.Close()&#xA;&#xA;    buf := make([]byte, 1024)&#xA;    for {&#xA;    n, err := fi.Read(buf)&#xA;    if err != nil &amp;amp;&amp;amp; err != io.EOF { panic(err) }&#xA;    if n == 0 { break }&#xA;&#xA;    if n2, err := fo.Write(buf[:n]); err != nil {&#xA;        panic(err)&#xA;    } else if n2 != n {&#xA;        panic(&amp;quot;error in writing&amp;quot;)&#xA;    }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 这个例子使用了os.Open os.Create。&#xA;&#xA;// 使用bufio库&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;bufio&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    fi, err := os.Open(&amp;quot;input.txt&amp;quot;)&#xA;    if err != nil { panic(err) }&#xA;    defer fi.Close()&#xA;    r := bufio.NewReader(fi)&#xA;&#xA;    fo, err := os.Create(&amp;quot;output.txt&amp;quot;)&#xA;    if err != nil { panic(err) }&#xA;    defer fo.Close()&#xA;    w := bufio.NewWriter(fo)&#xA;&#xA;    buf := make([]byte, 1024)&#xA;    for {&#xA;    n, err := r.Read(buf)&#xA;    if err != nil &amp;amp;&amp;amp; err != io.EOF { panic(err) }&#xA;    if n == 0 { break }&#xA;&#xA;    if n2, err := w.Write(buf[:n]); err != nil {&#xA;        panic(err)&#xA;    } else if n2 != n {&#xA;        panic(&amp;quot;error in writing&amp;quot;)&#xA;    }&#xA;    }&#xA;&#xA;    if err = w.Flush(); err != nil { panic(err) }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用ioutil库&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;io/ioutil&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    b, err := ioutil.ReadFile(&amp;quot;input.txt&amp;quot;)&#xA;    if err != nil { panic(err) }&#xA;&#xA;    err = ioutil.WriteFile(&amp;quot;output.txt&amp;quot;, b, 0644)&#xA;    if err != nil { panic(err) }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-纳秒级别-局域网-广播-时间同步</title>
      <link>http://www.nljb.net/default/Golang-%E7%BA%B3%E7%A7%92%E7%BA%A7%E5%88%AB-%E5%B1%80%E5%9F%9F%E7%BD%91-%E5%B9%BF%E6%92%AD-%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import &amp;quot;fmt&amp;quot;&#xA;import &amp;quot;net&amp;quot;&#xA;import &amp;quot;os/exec&amp;quot;&#xA;import &amp;quot;time&amp;quot;&#xA;&#xA;func TimeRead(ch chan string) {&#xA;    ch &amp;lt;- &amp;quot;LOG &amp;gt;&amp;gt;&amp;gt; TimeRead Start&amp;quot;&#xA;    socket, err := net.ListenUDP(&amp;quot;udp4&amp;quot;,&amp;amp;net.UDPAddr{&#xA;    IP: net.IPv4(0,0,0,0),&#xA;    Port: 8888,&#xA;    })&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;Err &amp;gt;&amp;gt;&amp;gt; TimeRead&amp;quot;,err)&#xA;    }&#xA;    for {&#xA;    data := make([]byte, 32)&#xA;    //read, remoteAddr, err := socket.ReadFromUDP(data)&#xA;    read, _, err := socket.ReadFromUDP(data)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;Err &amp;gt;&amp;gt;&amp;gt; TimeRead&amp;quot;,err)&#xA;        continue&#xA;    }&#xA;    //fmt.Println(read, remoteAddr)&#xA;    cmd := exec.Command(&amp;quot;date&amp;quot;,&amp;quot;-s&amp;quot;,string(data[0:read]))&#xA;    err = cmd.Run()&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;Err &amp;gt;&amp;gt;&amp;gt; TimeRead&amp;quot;,err)&#xA;    }&#xA;    fmt.Println(&amp;quot;LOG &amp;gt;&amp;gt;&amp;gt; TimeRead&amp;quot;,time.Now().String())&#xA;    }&#xA;    ch &amp;lt;- &amp;quot;LOG &amp;gt;&amp;gt;&amp;gt; TimeRead Down&amp;quot;&#xA;    defer socket.Close()&#xA;}&#xA;&#xA;func Command(ch chan string) {&#xA;    ch &amp;lt;- &amp;quot;LOG &amp;gt;&amp;gt;&amp;gt; Command Start&amp;quot;&#xA;    socket, err := net.ListenUDP(&amp;quot;udp4&amp;quot;,&amp;amp;net.UDPAddr{&#xA;    IP: net.IPv4(0,0,0,0),&#xA;    Port: 9999,&#xA;    })&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;Err &amp;gt;&amp;gt;&amp;gt; Command&amp;quot;,err)&#xA;    }&#xA;    for {&#xA;    data := make([]byte, 32)&#xA;    //read, remoteAddr, err := socket.ReadFromUDP(data)&#xA;    read, _, err := socket.ReadFromUDP(data)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;Err &amp;gt;&amp;gt;&amp;gt; Command&amp;quot;,err)&#xA;        continue&#xA;    }&#xA;    //fmt.Println(read, remoteAddr)&#xA;    ch &amp;lt;- string(data[0:read])&#xA;    }&#xA;    ch &amp;lt;- &amp;quot;LOG &amp;gt;&amp;gt;&amp;gt; Command Down&amp;quot;&#xA;    defer socket.Close()&#xA;}&#xA;&#xA;func main() {&#xA;    timeread := make(chan string)&#xA;    command := make(chan string)&#xA;    go TimeRead(timeread)&#xA;    go Command(command)&#xA;    for {&#xA;    select {&#xA;        case x := &amp;lt;- timeread:&#xA;        fmt.Println(x)&#xA;        case y := &amp;lt;- command:&#xA;        fmt.Println(y)&#xA;    }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;//////////////////////////////////////////////////////////////////////////////////////////////////&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import &amp;quot;fmt&amp;quot;&#xA;import &amp;quot;net&amp;quot;&#xA;import &amp;quot;time&amp;quot;&#xA;&#xA;func TimeWrite() {&#xA;    socket, err := net.DialUDP(&amp;quot;udp4&amp;quot;, nil, &amp;amp;net.UDPAddr{&#xA;    IP: net.IPv4(192,168,24,255),&#xA;    Port: 8888,&#xA;    })&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;Err&amp;quot;,err)&#xA;    }&#xA;    defer socket.Close()&#xA;&#xA;    for {&#xA;    senddata := []byte(time.Now().Format(&amp;quot;01/02/2006 15:04:05.999999999&amp;quot;))&#xA;    _, err = socket.Write(senddata)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;Err&amp;quot;, err)&#xA;    }&#xA;    time.Sleep(time.Second * 5)&#xA;    }&#xA;}&#xA;&#xA;func Command() {&#xA;    socket, err := net.DialUDP(&amp;quot;udp4&amp;quot;, nil, &amp;amp;net.UDPAddr{&#xA;    IP: net.IPv4(192,168,24,255),&#xA;    Port: 9999,&#xA;    })&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;Err&amp;quot;,err)&#xA;    }&#xA;    defer socket.Close()&#xA;&#xA;    for {&#xA;    senddata := []byte(&amp;quot;reboot&amp;quot;)&#xA;    _, err = socket.Write(senddata)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;Err&amp;quot;, err)&#xA;    }&#xA;    time.Sleep(time.Second * 5)&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;   go TimeWrite()&#xA;   go Command()&#xA;   time.Sleep(time.Second * 99999999)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-导出内容到-Excel</title>
      <link>http://www.nljb.net/default/Golang-%E5%AF%BC%E5%87%BA%E5%86%85%E5%AE%B9%E5%88%B0-Excel/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;encoding/csv&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    f, err := os.Create(&amp;quot;haha2.xls&amp;quot;)&#xA;    if err != nil {&#xA;    panic(err)&#xA;    }&#xA;    defer f.Close()&#xA;&#xA;    f.WriteString(&amp;quot;\xEF\xBB\xBF&amp;quot;) // 写入UTF-8 BOM&#xA;&#xA;    w := csv.NewWriter(f)&#xA;    w.Write([]string{&amp;quot;编号&amp;quot;,&amp;quot;姓名&amp;quot;,&amp;quot;年龄&amp;quot;})&#xA;    w.Write([]string{&amp;quot;1&amp;quot;,&amp;quot;张三&amp;quot;,&amp;quot;23&amp;quot;})&#xA;    w.Write([]string{&amp;quot;2&amp;quot;,&amp;quot;李四&amp;quot;,&amp;quot;24&amp;quot;})&#xA;    w.Write([]string{&amp;quot;3&amp;quot;,&amp;quot;王五&amp;quot;,&amp;quot;25&amp;quot;})&#xA;    w.Write([]string{&amp;quot;4&amp;quot;,&amp;quot;赵六&amp;quot;,&amp;quot;26&amp;quot;})&#xA;    w.Flush()&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-字符串操作处理包-Strings</title>
      <link>http://www.nljb.net/default/Golang-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%A4%84%E7%90%86%E5%8C%85-Strings/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;&amp;quot;fmt&amp;quot;&#xA;&amp;quot;strings&amp;quot;&#xA;//&amp;quot;unicode/utf8&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    fmt.Println(&amp;quot;查找子串是否在指定的字符串中&amp;quot;)&#xA;    fmt.Println(&amp;quot; Contains 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.Contains(&amp;quot;seafood&amp;quot;, &amp;quot;foo&amp;quot;)) //true&#xA;    fmt.Println(strings.Contains(&amp;quot;seafood&amp;quot;, &amp;quot;bar&amp;quot;)) //false&#xA;    fmt.Println(strings.Contains(&amp;quot;seafood&amp;quot;, &amp;quot;&amp;quot;)) //true&#xA;    fmt.Println(strings.Contains(&amp;quot;&amp;quot;, &amp;quot;&amp;quot;)) //true 这里要特别注意&#xA;    fmt.Println(strings.Contains(&amp;quot;我是中国人&amp;quot;, &amp;quot;我&amp;quot;)) //true&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; ContainsAny 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.ContainsAny(&amp;quot;team&amp;quot;, &amp;quot;i&amp;quot;)) // false&#xA;    fmt.Println(strings.ContainsAny(&amp;quot;failure&amp;quot;, &amp;quot;u &amp;amp; i&amp;quot;)) // true&#xA;    fmt.Println(strings.ContainsAny(&amp;quot;foo&amp;quot;, &amp;quot;&amp;quot;)) // false&#xA;    fmt.Println(strings.ContainsAny(&amp;quot;&amp;quot;, &amp;quot;&amp;quot;)) // false&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; ContainsRune 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.ContainsRune(&amp;quot;我是中国&amp;quot;, &#39;我&#39;)) // true 注意第二个参数，用的是字符&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Count 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.Count(&amp;quot;cheese&amp;quot;, &amp;quot;e&amp;quot;)) // 3 &#xA;    fmt.Println(strings.Count(&amp;quot;five&amp;quot;, &amp;quot;&amp;quot;)) // before &amp;amp; after each rune result: 5 , 源码中有实现&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; EqualFold 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.EqualFold(&amp;quot;Go&amp;quot;, &amp;quot;go&amp;quot;)) //大小写忽略 &#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Fields 函数的用法&amp;quot;)&#xA;    fmt.Println(&amp;quot;Fields are: %q&amp;quot;, strings.Fields(&amp;quot; foo bar baz &amp;quot;)) //[&amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;baz&amp;quot;] 返回一个列表&#xA;&#xA;    //相当于用函数做为参数，支持匿名函数&#xA;    for _, record := range []string{&amp;quot; aaa*1892*122&amp;quot;, &amp;quot;aaa\taa\t&amp;quot;, &amp;quot;124|939|22&amp;quot;} {&#xA;    fmt.Println(strings.FieldsFunc(record, func(ch rune) bool {&#xA;    switch {&#xA;    case ch &amp;gt; &#39;5&#39;:&#xA;    return true&#xA;    }&#xA;    return false&#xA;    }))&#xA;    }&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; HasPrefix 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.HasPrefix(&amp;quot;NLT_abc&amp;quot;, &amp;quot;NLT&amp;quot;)) //前缀是以NLT开头的&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; HasSuffix 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.HasSuffix(&amp;quot;NLT_abc&amp;quot;, &amp;quot;abc&amp;quot;)) //后缀是以NLT开头的&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Index 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.Index(&amp;quot;NLT_abc&amp;quot;, &amp;quot;abc&amp;quot;)) // 返回第一个匹配字符的位置，这里是4&#xA;    fmt.Println(strings.Index(&amp;quot;NLT_abc&amp;quot;, &amp;quot;aaa&amp;quot;)) // 在存在返回 -1&#xA;    fmt.Println(strings.Index(&amp;quot;我是中国人&amp;quot;, &amp;quot;中&amp;quot;)) // 在存在返回 6&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; IndexAny 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.IndexAny(&amp;quot;我是中国人&amp;quot;, &amp;quot;中&amp;quot;)) // 在存在返回 6&#xA;    fmt.Println(strings.IndexAny(&amp;quot;我是中国人&amp;quot;, &amp;quot;和&amp;quot;)) // 在存在返回 -1&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Index 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.IndexRune(&amp;quot;NLT_abc&amp;quot;, &#39;b&#39;)) // 返回第一个匹配字符的位置，这里是4&#xA;    fmt.Println(strings.IndexRune(&amp;quot;NLT_abc&amp;quot;, &#39;s&#39;)) // 在存在返回 -1&#xA;    fmt.Println(strings.IndexRune(&amp;quot;我是中国人&amp;quot;, &#39;中&#39;)) // 在存在返回 6&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Join 函数的用法&amp;quot;)&#xA;    s := []string{&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;}&#xA;    fmt.Println(strings.Join(s, &amp;quot;, &amp;quot;)) // 返回字符串：foo, bar, baz &#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; LastIndex 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.LastIndex(&amp;quot;go gopher&amp;quot;, &amp;quot;go&amp;quot;)) // 3&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; LastIndexAny 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.LastIndexAny(&amp;quot;go gopher&amp;quot;, &amp;quot;go&amp;quot;)) // 4&#xA;    fmt.Println(strings.LastIndexAny(&amp;quot;我是中国人&amp;quot;, &amp;quot;中&amp;quot;)) // 6&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Map 函数的用法&amp;quot;)&#xA;    rot13 := func(r rune) rune {&#xA;    switch {&#xA;    case r &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; r &amp;lt;= &#39;Z&#39;:&#xA;    return &#39;A&#39; + (r-&#39;A&#39;+13)%26&#xA;    case r &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; r &amp;lt;= &#39;z&#39;:&#xA;    return &#39;a&#39; + (r-&#39;a&#39;+13)%26&#xA;    }&#xA;    return r&#xA;    }&#xA;    fmt.Println(strings.Map(rot13, &amp;quot;&#39;Twas brillig and the slithy gopher...&amp;quot;))&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Repeat 函数的用法&amp;quot;)&#xA;    fmt.Println(&amp;quot;ba&amp;quot; + strings.Repeat(&amp;quot;na&amp;quot;, 2)) //banana &#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Replace 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.Replace(&amp;quot;oink oink oink&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;ky&amp;quot;, 2))&#xA;    fmt.Println(strings.Replace(&amp;quot;oink oink oink&amp;quot;, &amp;quot;oink&amp;quot;, &amp;quot;moo&amp;quot;, -1))&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Split 函数的用法&amp;quot;)&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(&amp;quot;a,b,c&amp;quot;, &amp;quot;,&amp;quot;))&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(&amp;quot;a man a plan a canal panama&amp;quot;, &amp;quot;a &amp;quot;))&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(&amp;quot; xyz &amp;quot;, &amp;quot;&amp;quot;))&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(&amp;quot;&amp;quot;, &amp;quot;Bernardo O&#39;Higgins&amp;quot;))&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; SplitAfter 函数的用法&amp;quot;)&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitAfter(&amp;quot;/home/m_ta/src&amp;quot;, &amp;quot;/&amp;quot;)) //[&amp;quot;/&amp;quot; &amp;quot;home/&amp;quot; &amp;quot;m_ta/&amp;quot; &amp;quot;src&amp;quot;]&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; SplitAfterN 函数的用法&amp;quot;)&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitAfterN(&amp;quot;/home/m_ta/src&amp;quot;, &amp;quot;/&amp;quot;, 2)) //[&amp;quot;/&amp;quot; &amp;quot;home/m_ta/src&amp;quot;]&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitAfterN(&amp;quot;#home#m_ta#src&amp;quot;, &amp;quot;#&amp;quot;, -1)) //[&amp;quot;/&amp;quot; &amp;quot;home/&amp;quot; &amp;quot;m_ta/&amp;quot; &amp;quot;src&amp;quot;]&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; SplitN 函数的用法&amp;quot;)&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitN(&amp;quot;/home/m_ta/src&amp;quot;, &amp;quot;/&amp;quot;, 1))&#xA;&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitN(&amp;quot;/home/m_ta/src&amp;quot;, &amp;quot;/&amp;quot;, 2)) //[&amp;quot;/&amp;quot; &amp;quot;home/&amp;quot; &amp;quot;m_ta/&amp;quot; &amp;quot;src&amp;quot;]&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitN(&amp;quot;/home/m_ta/src&amp;quot;, &amp;quot;/&amp;quot;, -1)) //[&amp;quot;&amp;quot; &amp;quot;home&amp;quot; &amp;quot;m_ta&amp;quot; &amp;quot;src&amp;quot;]&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitN(&amp;quot;home,m_ta,src&amp;quot;, &amp;quot;,&amp;quot;, 2)) //[&amp;quot;/&amp;quot; &amp;quot;home/&amp;quot; &amp;quot;m_ta/&amp;quot; &amp;quot;src&amp;quot;]&#xA;&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitN(&amp;quot;#home#m_ta#src&amp;quot;, &amp;quot;#&amp;quot;, -1)) //[&amp;quot;/&amp;quot; &amp;quot;home/&amp;quot; &amp;quot;m_ta/&amp;quot; &amp;quot;src&amp;quot;]&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Title 函数的用法&amp;quot;) //这个函数，还真不知道有什么用&#xA;    fmt.Println(strings.Title(&amp;quot;her royal highness&amp;quot;))&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; ToLower 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.ToLower(&amp;quot;Gopher&amp;quot;)) //gopher &#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; ToLowerSpecial 函数的用法&amp;quot;)&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; ToTitle 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.ToTitle(&amp;quot;loud noises&amp;quot;))&#xA;    fmt.Println(strings.ToTitle(&amp;quot;loud 中国&amp;quot;))&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Replace 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.Replace(&amp;quot;ABAACEDF&amp;quot;, &amp;quot;A&amp;quot;, &amp;quot;a&amp;quot;, 2)) // aBaACEDF&#xA;    //第四个参数小于0，表示所有的都替换， 可以看下golang的文档&#xA;    fmt.Println(strings.Replace(&amp;quot;ABAACEDF&amp;quot;, &amp;quot;A&amp;quot;, &amp;quot;a&amp;quot;, -1)) // aBaaCEDF&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; ToUpper 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.ToUpper(&amp;quot;Gopher&amp;quot;)) //GOPHER&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Trim 函数的用法&amp;quot;)&#xA;    fmt.Printf(&amp;quot;[%q]&amp;quot;, strings.Trim(&amp;quot; !!! Achtung !!! &amp;quot;, &amp;quot;! &amp;quot;)) // [&amp;quot;Achtung&amp;quot;]&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; TrimLeft 函数的用法&amp;quot;)&#xA;    fmt.Printf(&amp;quot;[%q]&amp;quot;, strings.TrimLeft(&amp;quot; !!! Achtung !!! &amp;quot;, &amp;quot;! &amp;quot;)) // [&amp;quot;Achtung !!! &amp;quot;]&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; TrimSpace 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.TrimSpace(&amp;quot; \t\n a lone gopher \n\t\r\n&amp;quot;)) // a lone gopher&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;清理&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 删除字符串前后的逗号&#xA;arr := strings.Trim(val,&amp;quot;,&amp;quot;)   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;搜索&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 返回s中第一次出现sep的位置，如果没有返回-1.&#xA;func  Index(s,  sep string)  int&#xA;&#xA;fmt.Println(strings.Index(&amp;quot;chicken&amp;quot;,&amp;quot;ken&amp;quot;))&#xA;fmt.Println(strings.Index(&amp;quot;chicken&amp;quot;,&amp;quot;dmr&amp;quot;))&#xA;&#xA;func  LastIndex(s,  sep string)  int&#xA;// 返回在s中最后一次出现sep的位置，不存在返回-1&#xA;&#xA;func  Count(s,  sep string)  int&#xA;// 统计sep在s中出现的次数，非重叠的，比如s=“eeee”，sep=”ee”,结果返回&#xA;&#xA;fmt.Println(strings.Count(&amp;quot;cheese&amp;quot;,&amp;quot;e&amp;quot;))&#xA;fmt.Println(strings.Count(&amp;quot;five&amp;quot;,&amp;quot;&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;包含&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func  Contains(s,  substr string)  bool&#xA;// 如果substr在s中，返回true&#xA;&#xA;fmt.Println(strings.Contains(&amp;quot;seafood&amp;quot;,&amp;quot;foo&amp;quot;))&#xA;fmt.Println(strings.Contains(&amp;quot;seafood&amp;quot;,&amp;quot;bar&amp;quot;))&#xA;fmt.Println(strings.Contains(&amp;quot;seafood&amp;quot;,&amp;quot;&amp;quot;))&#xA;fmt.Println(strings.Contains(&amp;quot;&amp;quot;,&amp;quot;&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;连接&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func  Join(a []string,  sep string)  string&#xA;// 连接字符串，以sep作为分隔符&#xA;&#xA;s := []string{&amp;quot;foo&amp;quot;,&amp;quot;bar&amp;quot;,&amp;quot;baz&amp;quot;}&#xA;fmt.Println(strings.Join(s,&amp;quot;, &amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;分割&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func  Split(s,  sep string)  []string&#xA;// 分割字符串，sep为空字串时，与上一篇讲到的一样，相当于每个字符之间的间隔&#xA;// s中没有sep，返回值里只有一个元素s&#xA;&#xA;fmt.Printf(&amp;quot;%q\n&amp;quot;,strings.Split(&amp;quot;a,b,c&amp;quot;,&amp;quot;,&amp;quot;))&#xA;fmt.Printf(&amp;quot;%q\n&amp;quot;,strings.Split(&amp;quot;a man a plan a canal panama&amp;quot;,&amp;quot;a &amp;quot;))&#xA;fmt.Printf(&amp;quot;%q\n&amp;quot;,strings.Split(&amp;quot; xyz &amp;quot;,&amp;quot;&amp;quot;))&#xA;fmt.Printf(&amp;quot;%q\n&amp;quot;,strings.Split(&amp;quot;&amp;quot;,&amp;quot;Bernardo O&#39;Higgins&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package strings&#xA;    import &amp;quot;strings&amp;quot;&#xA;&#xA;    Package strings implements simple functions to manipulate strings.&#xA;&#xA;FUNCTIONS&#xA;&#xA;func Contains(s, substr string) bool&#xA;    Contains returns true if substr is within s.&#xA;&#xA;func ContainsAny(s, chars string) bool&#xA;    ContainsAny returns true if any Unicode code points in chars are within&#xA;    s.&#xA;&#xA;func ContainsRune(s string, r rune) bool&#xA;    ContainsRune returns true if the Unicode code point r is within s.&#xA;&#xA;func Count(s, sep string) int&#xA;    Count counts the number of non-overlapping instances of sep in s.&#xA;&#xA;func EqualFold(s, t string) bool&#xA;    EqualFold reports whether s and t, interpreted as UTF-8 strings, are&#xA;    equal under Unicode case-folding.&#xA;&#xA;func Fields(s string) []string&#xA;    Fields splits the string s around each instance of one or more&#xA;    consecutive white space characters, returning an array of substrings of&#xA;    s or an empty list if s contains only white space.&#xA;&#xA;func FieldsFunc(s string, f func(rune) bool) []string&#xA;    FieldsFunc splits the string s at each run of Unicode code points c&#xA;    satisfying f(c) and returns an array of slices of s. If all code points&#xA;    in s satisfy f(c) or the string is empty, an empty slice is returned.&#xA;&#xA;func HasPrefix(s, prefix string) bool&#xA;    HasPrefix tests whether the string s begins with prefix.&#xA;&#xA;func HasSuffix(s, suffix string) bool&#xA;    HasSuffix tests whether the string s ends with suffix.&#xA;&#xA;func Index(s, sep string) int&#xA;    Index returns the index of the first instance of sep in s, or -1 if sep&#xA;    is not present in s.&#xA;&#xA;func IndexAny(s, chars string) int&#xA;    IndexAny returns the index of the first instance of any Unicode code&#xA;    point from chars in s, or -1 if no Unicode code point from chars is&#xA;    present in s.&#xA;&#xA;func IndexFunc(s string, f func(rune) bool) int&#xA;    IndexFunc returns the index into s of the first Unicode code point&#xA;    satisfying f(c), or -1 if none do.&#xA;&#xA;func IndexRune(s string, r rune) int&#xA;    IndexRune returns the index of the first instance of the Unicode code&#xA;    point r, or -1 if rune is not present in s.&#xA;&#xA;func Join(a []string, sep string) string&#xA;    Join concatenates the elements of a to create a single string. The&#xA;    separator string sep is placed between elements in the resulting string.&#xA;&#xA;func LastIndex(s, sep string) int&#xA;    LastIndex returns the index of the last instance of sep in s, or -1 if&#xA;    sep is not present in s.&#xA;&#xA;func LastIndexAny(s, chars string) int&#xA;    LastIndexAny returns the index of the last instance of any Unicode code&#xA;    point from chars in s, or -1 if no Unicode code point from chars is&#xA;    present in s.&#xA;&#xA;func LastIndexFunc(s string, f func(rune) bool) int&#xA;    LastIndexFunc returns the index into s of the last Unicode code point&#xA;    satisfying f(c), or -1 if none do.&#xA;&#xA;func Map(mapping func(rune) rune, s string) string&#xA;    Map returns a copy of the string s with all its characters modified&#xA;    according to the mapping function. If mapping returns a negative value,&#xA;    the character is dropped from the string with no replacement.&#xA;&#xA;func Repeat(s string, count int) string&#xA;    Repeat returns a new string consisting of count copies of the string s.&#xA;&#xA;func Replace(s, old, new string, n int) string&#xA;    Replace returns a copy of the string s with the first n non-overlapping&#xA;    instances of old replaced by new. If n &amp;lt; 0, there is no limit on the&#xA;    number of replacements.&#xA;&#xA;func Split(s, sep string) []string&#xA;    Split slices s into all substrings separated by sep and returns a slice&#xA;    of the substrings between those separators. If sep is empty, Split&#xA;    splits after each UTF-8 sequence. It is equivalent to SplitN with a&#xA;    count of -1.&#xA;&#xA;func SplitAfter(s, sep string) []string&#xA;    SplitAfter slices s into all substrings after each instance of sep and&#xA;    returns a slice of those substrings. If sep is empty, SplitAfter splits&#xA;    after each UTF-8 sequence. It is equivalent to SplitAfterN with a count&#xA;    of -1.&#xA;&#xA;func SplitAfterN(s, sep string, n int) []string&#xA;    SplitAfterN slices s into substrings after each instance of sep and&#xA;    returns a slice of those substrings. If sep is empty, SplitAfterN splits&#xA;    after each UTF-8 sequence. The count determines the number of substrings&#xA;    to return:&#xA;&#xA;    n &amp;gt; 0: at most n substrings; the last substring will be the unsplit remainder.&#xA;    n == 0: the result is nil (zero substrings)&#xA;    n &amp;lt; 0: all substrings&#xA;&#xA;func SplitN(s, sep string, n int) []string&#xA;    SplitN slices s into substrings separated by sep and returns a slice of&#xA;    the substrings between those separators. If sep is empty, SplitN splits&#xA;    after each UTF-8 sequence. The count determines the number of substrings&#xA;    to return:&#xA;&#xA;    n &amp;gt; 0: at most n substrings; the last substring will be the unsplit remainder.&#xA;    n == 0: the result is nil (zero substrings)&#xA;    n &amp;lt; 0: all substrings&#xA;&#xA;func Title(s string) string&#xA;    Title returns a copy of the string s with all Unicode letters that begin&#xA;    words mapped to their title case.&#xA;&#xA;func ToLower(s string) string&#xA;    ToLower returns a copy of the string s with all Unicode letters mapped&#xA;    to their lower case.&#xA;&#xA;func ToLowerSpecial(_case unicode.SpecialCase, s string) string&#xA;    ToLowerSpecial returns a copy of the string s with all Unicode letters&#xA;    mapped to their lower case, giving priority to the special casing rules.&#xA;&#xA;func ToTitle(s string) string&#xA;    ToTitle returns a copy of the string s with all Unicode letters mapped&#xA;    to their title case.&#xA;&#xA;func ToTitleSpecial(_case unicode.SpecialCase, s string) string&#xA;    ToTitleSpecial returns a copy of the string s with all Unicode letters&#xA;    mapped to their title case, giving priority to the special casing rules.&#xA;&#xA;func ToUpper(s string) string&#xA;    ToUpper returns a copy of the string s with all Unicode letters mapped&#xA;    to their upper case.&#xA;&#xA;func ToUpperSpecial(_case unicode.SpecialCase, s string) string&#xA;    ToUpperSpecial returns a copy of the string s with all Unicode letters&#xA;    mapped to their upper case, giving priority to the special casing rules.&#xA;&#xA;func Trim(s string, cutset string) string&#xA;    Trim returns a slice of the string s with all leading and trailing&#xA;    Unicode code points contained in cutset removed.&#xA;&#xA;func TrimFunc(s string, f func(rune) bool) string&#xA;    TrimFunc returns a slice of the string s with all leading and trailing&#xA;    Unicode code points c satisfying f(c) removed.&#xA;&#xA;func TrimLeft(s string, cutset string) string&#xA;    TrimLeft returns a slice of the string s with all leading Unicode code&#xA;    points contained in cutset removed.&#xA;&#xA;func TrimLeftFunc(s string, f func(rune) bool) string&#xA;    TrimLeftFunc returns a slice of the string s with all leading Unicode&#xA;    code points c satisfying f(c) removed.&#xA;&#xA;func TrimRight(s string, cutset string) string&#xA;    TrimRight returns a slice of the string s, with all trailing Unicode&#xA;    code points contained in cutset removed.&#xA;&#xA;func TrimRightFunc(s string, f func(rune) bool) string&#xA;    TrimRightFunc returns a slice of the string s with all trailing Unicode&#xA;    code points c satisfying f(c) removed.&#xA;&#xA;func TrimSpace(s string) string&#xA;    TrimSpace returns a slice of the string s, with all leading and trailing&#xA;    white space removed, as defined by Unicode.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-压缩-解压-Tar.Gz</title>
      <link>http://www.nljb.net/default/Golang-%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B-Tar.Gz/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;golang处理压缩包,我最常用的就是tar.gz了,所以今天写了一个测试一下.代码放这里以后浏览.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//压缩文件&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;archive/tar&amp;quot;&#xA;    &amp;quot;compress/gzip&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    // file write&#xA;    fw, err := os.Create(&amp;quot;tar/lin_golang_src.tar.gz&amp;quot;)&#xA;    if err != nil {&#xA;    panic(err)&#xA;    }&#xA;    defer fw.Close()&#xA;&#xA;    // gzip write&#xA;    gw := gzip.NewWriter(fw)&#xA;    defer gw.Close()&#xA;&#xA;    // tar write&#xA;    tw := tar.NewWriter(gw)&#xA;    defer tw.Close()&#xA;&#xA;    // 打开文件夹&#xA;    dir, err := os.Open(&amp;quot;file/&amp;quot;)&#xA;    if err != nil {&#xA;    panic(nil)&#xA;    }&#xA;    defer dir.Close()&#xA;&#xA;    // 读取文件列表&#xA;    fis, err := dir.Readdir(0)&#xA;    if err != nil {&#xA;    panic(err)&#xA;    }&#xA;&#xA;    // 遍历文件列表&#xA;    for _, fi := range fis {&#xA;    // 逃过文件夹, 我这里就不递归了&#xA;    if fi.IsDir() {&#xA;        continue&#xA;    }&#xA;&#xA;    // 打印文件名称&#xA;    fmt.Println(fi.Name())&#xA;&#xA;    // 打开文件&#xA;    fr, err := os.Open(dir.Name() + &amp;quot;/&amp;quot; + fi.Name())&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;    defer fr.Close()&#xA;&#xA;    // 信息头&#xA;    h := new(tar.Header)&#xA;    h.Name = fi.Name()&#xA;    h.Size = fi.Size()&#xA;    h.Mode = int64(fi.Mode())&#xA;    h.ModTime = fi.ModTime()&#xA;&#xA;    // 写信息头&#xA;    err = tw.WriteHeader(h)&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;&#xA;    // 写文件&#xA;    _, err = io.Copy(tw, fr)&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;    }&#xA;&#xA;    fmt.Println(&amp;quot;tar.gz ok&amp;quot;)&#xA;}&#xA;解压文件&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    // &amp;quot;time&amp;quot;&#xA;    &amp;quot;archive/tar&amp;quot;&#xA;    &amp;quot;compress/gzip&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    // file read&#xA;    fr, err := os.Open(&amp;quot;tar/lin_golang_src.tar.gz&amp;quot;)&#xA;    if err != nil {&#xA;    panic(err)&#xA;    }&#xA;    defer fr.Close()&#xA;&#xA;    // gzip read&#xA;    gr, err := gzip.NewReader(fr)&#xA;    if err != nil {&#xA;    panic(err)&#xA;    }&#xA;    defer gr.Close()&#xA;&#xA;    // tar read&#xA;    tr := tar.NewReader(gr)&#xA;&#xA;    // 读取文件&#xA;    for {&#xA;    h, err := tr.Next()&#xA;    if err == io.EOF {&#xA;        break&#xA;    }&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;&#xA;    // 显示文件&#xA;    fmt.Println(h.Name)&#xA;&#xA;    // 打开文件&#xA;    fw, err := os.OpenFile(&amp;quot;file2/&amp;quot; + h.Name, os.O_CREATE | os.O_WRONLY, 0644/*os.FileMode(h.Mode)*/)&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;    defer fw.Close()&#xA;&#xA;    // 写文件&#xA;    _, err = io.Copy(fw, tr)&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;&#xA;    }&#xA;&#xA;    fmt.Println(&amp;quot;un tar.gz ok&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;呼呼,以后打包下载东西的时候可以使用了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.dotcoo.com/golang-tar-gzip&#34;&gt;http://www.dotcoo.com/golang-tar-gzip&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 解压Tar文件&#xA;func Untar(file,pathstring) error {&#xA;    // 打开文件&#xA;    f,err:=os.Open(file)&#xA;    iferr!= nil {&#xA;    returnerr&#xA;    }&#xA;    deferf.Close()&#xA;    // 读取GZIP&#xA;    gr,err:=gzip.NewReader(f)&#xA;    iferr!= nil {&#xA;    returnerr&#xA;    }&#xA;    defergr.Close()&#xA;    // 读取TAR&#xA;    tr:=tar.NewReader(gr)&#xA;    for {&#xA;    hdr,err:=tr.Next()&#xA;    iferr==io.EOF{&#xA;        break&#xA;    } else iferr!= nil {&#xA;        returnerr&#xA;    }&#xA;    ifhdr.FileInfo().IsDir() {&#xA;        os.MkdirAll(path+string(os.PathSeparator)+hdr.Name,hdr.FileInfo().Mode())&#xA;    } else {&#xA;        fw,err:=os.OpenFile(path+string(os.PathSeparator)+hdr.Name,os.O_CREATE|os.O_WRONLY|os.O_TRUNC,hdr.FileInfo().Mode())&#xA;        iferr!= nil {&#xA;        returnerr&#xA;        }&#xA;        deferfw.Close()&#xA;        _,err=io.Copy(fw,tr)&#xA;        iferr!= nil {&#xA;        returnerr&#xA;        }&#xA;    }&#xA;    }&#xA;    return nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-判断文件是否存在</title>
      <link>http://www.nljb.net/default/Golang-%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;golang判断文件是否存在有点怪异&lt;/p&gt;&#xA;&#xA;&lt;p&gt;是判断在操作文件时返回的错误信息来判断的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不能直接根据路径判断,感觉怪异.呵呵&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main     &#xA;import (&#xA;     &amp;quot;fmt&amp;quot;&#xA;     &amp;quot;os&amp;quot; &#xA;)&#xA;&#xA;func main() {&#xA;&#xA;     f, err := os.Open(&amp;quot;dotcoo.com.txt&amp;quot;)&#xA;     if err != nil &amp;amp;&amp;amp; os.IsNotExist(err) {&#xA;     fmt.Printf(&amp;quot;file not exist!\n&amp;quot;)&#xA;     return&#xA;     }&#xA;     fmt.Printf(&amp;quot;file exist!\n&amp;quot;)&#xA;     defer f.Close()&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-创建守护进程</title>
      <link>http://www.nljb.net/default/Golang-%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;os/exec&amp;quot;&#xA;    &amp;quot;path/filepath&amp;quot;&#xA;)&#xA;&#xA;if os.Getppid()!=1{&#xA;&#xA;    //判断当其是否是子进程，当父进程return之后，子进程会被 系统1 号进程接管&#xA;    filePath,_:=filepath.Abs(os.Args[0])  //将命令行参数中执行文件路径转换成可用路径&#xA;    cmd:=exec.Command(filePath,os.Args[1:]...)//将其他命令传入生成出的进程&#xA;    cmd.Stdin=os.Stdin //给新进程设置文件描述符，可以重定向到文件中&#xA;    cmd.Stdout=os.Stdout&#xA;    cmd.Stderr=os.Stderr&#xA;    cmd.Start() //开始执行新进程，不等待新进程退出&#xA;    return&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样可以创建守护进程，并且可以接受信号量&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另一种方式&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if os.Getppid()!=1{   &#xA;    args:=append([]string{filePath},os.Args[1:]...)&#xA;    os.StartProcess(filePath,args,&amp;amp;os.ProcAttr{Files:[]*os.File{os.Stdin,os.Stdout,os.Stderr}})&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;也可以创建守护进程，文档上说startProcess是更底层的接口，cmd是高级的接口&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其实还可以更低层&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pid, _, sysErr := syscall.RawSyscall(syscall.SYS_FORK, 0, 0, 0)&#xA;    if sysErr != 0 {&#xA;    Utils.LogErr(sysErr)&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;go源码中其实就是这么生成新进程的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;直接调用系统函数fork来生成新进程，只是这样不知道为什么总是注册不了信号量处理函数&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-内置的类型和函数</title>
      <link>http://www.nljb.net/default/Golang-%E5%86%85%E7%BD%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%87%BD%E6%95%B0/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;具体见&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http://golang.org/pkg/builtin/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;内置类型&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;值类型：&#xA;bool&#xA;int(32 or 64), int8, int16, int32, int64&#xA;uint(32 or 64), uint8(byte), uint16, uint32, uint64&#xA;float32, float64&#xA;string&#xA;complex64, complex128&#xA;array    -- 固定长度的数组&#xA;&#xA;引用类型：(指针类型)&#xA;slice   -- 序列数组(最常用)&#xA;map        -- 映射&#xA;chan    -- 管道&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;内置函数&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;append  -- 把东西增加到slice里面,返回修改后的slice&#xA;close   -- 关闭channel&#xA;delete    -- 从map中删除key对应的value&#xA;panic    -- 停止常规的goroutine&#xA;recover -- 允许程序定义goroutine的panic动作&#xA;imag    -- 返回complex的实部&#xA;real    -- 返回complex的虚部&#xA;make    -- 返回Type本身(只能应用于slice, map, channel)&#xA;new        -- 返回指向Type的指针&#xA;cap        -- 容量，容积capacity&#xA;copy    -- 复制slice，返回复制的数目&#xA;len        -- 返回长度&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;内置接口&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type error interface {&#xA;    //只要实现了Error()函数，返回值为String的都实现了err接口&#xA;    Error()    String&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-上传-and-接收-文件</title>
      <link>http://www.nljb.net/default/Golang-%E4%B8%8A%E4%BC%A0-and-%E6%8E%A5%E6%94%B6-%E6%96%87%E4%BB%B6/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;)&#xA;&#xA;// 获取大小的借口&#xA;type Sizer interface {&#xA;    Size() int64&#xA;}&#xA;&#xA;// hello world, the web server&#xA;func HelloServer(w http.ResponseWriter, r *http.Request) {&#xA;    if &amp;quot;POST&amp;quot; == r.Method {&#xA;    file, _, err := r.FormFile(&amp;quot;userfile&amp;quot;)&#xA;    if err != nil {&#xA;        http.Error(w, err.Error(), 500)&#xA;        return&#xA;    }&#xA;    defer file.Close()&#xA;    f,err:=os.Create(&amp;quot;filenametosaveas&amp;quot;)&#xA;    defer f.Close()&#xA;    io.Copy(f,file)&#xA;fmt.Fprintf(w, &amp;quot;上传文件的大小为: %d&amp;quot;, file.(Sizer).Size())&#xA;    return&#xA;    }&#xA;&#xA;    // 上传页面&#xA;    w.Header().Add(&amp;quot;Content-Type&amp;quot;, &amp;quot;text/html&amp;quot;)&#xA;    w.WriteHeader(200)&#xA;    html := `&#xA;&amp;lt;form enctype=&amp;quot;multipart/form-data&amp;quot; action=&amp;quot;/hello&amp;quot; method=&amp;quot;POST&amp;quot;&amp;gt;&#xA;    Send this file: &amp;lt;input name=&amp;quot;userfile&amp;quot; type=&amp;quot;file&amp;quot; /&amp;gt;&#xA;    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Send File&amp;quot; /&amp;gt;&#xA;&amp;lt;/form&amp;gt;&#xA;`&#xA;    io.WriteString(w, html)&#xA;}&#xA;&#xA;func main() {&#xA;    http.HandleFunc(&amp;quot;/hello&amp;quot;, HelloServer)&#xA;    err := http.ListenAndServe(&amp;quot;:12345&amp;quot;, nil)&#xA;    if err != nil {&#xA;    log.Fatal(&amp;quot;ListenAndServe: &amp;quot;, err)&#xA;    }&#xA;}&#xA;&#xA;客户端上传文件代码：&#xA; func Upload() (err error) {&#xA;    // Create buffer&#xA;    buf := new(bytes.Buffer) // caveat IMO dont use this for large files, \&#xA;    // create a tmpfile and assemble your multipart from there (not tested)&#xA;    w := multipart.NewWriter(buf)&#xA;    // Create file field&#xA;    fw, err := w.CreateFormFile(&amp;quot;file&amp;quot;, &amp;quot;helloworld.go&amp;quot;) //这里的file很重要，必须和服务器端的FormFile一致&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;c&amp;quot;)&#xA;    return err&#xA;    }&#xA;    fd, err := os.Open(&amp;quot;helloworld.go&amp;quot;)&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;d&amp;quot;)&#xA;    return err&#xA;    }&#xA;    defer fd.Close()&#xA;    // Write file field from file to upload&#xA;    _, err = io.Copy(fw, fd)&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;e&amp;quot;)&#xA;    return err&#xA;    }&#xA;    // Important if you do not close the multipart writer you will not have a&#xA;    // terminating boundry&#xA;    w.Close()&#xA;    req, err := http.NewRequest(&amp;quot;POST&amp;quot;,&amp;quot;http://192.168.2.127/configure.go?portId=2&amp;quot;, buf)&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;f&amp;quot;)&#xA;    return err&#xA;    }&#xA;    req.Header.Set(&amp;quot;Content-Type&amp;quot;, w.FormDataContentType())&#xA;      var client http.Client&#xA;    res, err := client.Do(req)&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;g&amp;quot;)&#xA;    return err&#xA;    }&#xA;    io.Copy(os.Stderr, res.Body) // Replace this with Status.Code check&#xA;    fmt.Println(&amp;quot;h&amp;quot;)&#xA;    return err&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;处理文件上传&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你想处理一个由用户上传的文件，比如你正在建设一个类似Instagram的网站，你需要存储用户拍摄的照片。这种需求该如何实现呢？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;要使表单能够上传文件，首先第一步就是要添加form的&lt;code&gt;enctype&lt;/code&gt;属性，&lt;code&gt;enctype&lt;/code&gt;属性有如下三种情况:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;application/x-www-form-urlencoded   表示在发送前编码所有字符（默认）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;multipart/form-data 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;text/plain 空格转换为 &amp;ldquo;+&amp;rdquo; 加号，但不对特殊字符编码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以，表单的html代码应该类似于:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;&#xA;&amp;lt;head&amp;gt;&#xA;&amp;lt;title&amp;gt;上传文件&amp;lt;/title&amp;gt;&#xA;&amp;lt;/head&amp;gt;&#xA;&amp;lt;body&amp;gt;&#xA;&amp;lt;form enctype=&amp;quot;multipart/form-data&amp;quot; action=&amp;quot;http://127.0.0.1:9090/upload&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;&#xA; &amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;uploadfile&amp;quot; /&amp;gt;&#xA; &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;token&amp;quot; value=&amp;quot;map[site:map[title:NLJB tagline:NLJB author:map[name:nljb email:nljb@nljb.net github:https://github.com/nulijiabei] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://www.nljb.net posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:] imgs:map[imgtag:&amp;amp;lt;img src=&amp;amp;#34;%s&amp;amp;#34; alt=&amp;amp;#34;&amp;amp;#34; width=&amp;amp;#34;600&amp;amp;#34;&amp;amp;gt; urlperfix:{{urls.media}}/ localdir:media/]]] data:map[title:NLJB tagline:NLJB author:map[name:nljb email:nljb@nljb.net github:https://github.com/nulijiabei] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://www.nljb.net posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:] imgs:map[imgtag:&amp;amp;lt;img src=&amp;amp;#34;%s&amp;amp;#34; alt=&amp;amp;#34;&amp;amp;#34; width=&amp;amp;#34;600&amp;amp;#34;&amp;amp;gt; urlperfix:{{urls.media}}/ localdir:media/]]] layouts:map[default:map[_content:0x108d3040] page:map[layout:default _content:0x108d3200] post:map[layout:default _content:0x108d3540]] theme:map[stylesheets:map[default:[bootstrap.min.css style.css] widgets:map[google_prettify:twitter-bootstrap.css]] javascripts:map[default:[]] manifest:map[author:Jacob Thornton and Mark Otto website:http://twitter.github.com/bootstrap]] urls:map[media:/assets/media theme:/assets/twitter theme_media:/assets/twitter/media theme_javascripts:/assets/twitter/javascripts theme_stylesheets:/assets/twitter/stylesheets base_path:/] db:map[pages:map[about.md:map[title:About Me description:&amp;amp;lt;nil&amp;amp;gt; _content:0x108e8360 id:about.md layout:page permalink:pretty url:/about] archive.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0x108e83e0 id:archive.html layout:page permalink:pretty title:Archive url:/archive] categories.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0x108e8460 id:categories.html layout:page permalink:pretty title:Categories url:/categories] index.html:map[title:努力加贝 description:&amp;amp;lt;nil&amp;amp;gt; _content:0x108e85a0 id:index.html layout:page permalink:pretty url:/] pages.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0x108e8620 id:pages.html layout:page permalink:pretty title:Pages url:/pages] tags.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0x108e86a0 id:tags.html layout:page permalink:pretty title:Tags url:/tags]] navigation:[archive.html tags.html categories.html pages.html about.md] posts:map[dictionary:map[posts/Bash-语法参数.md:map[title:Bash-语法参数 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c280 layout:post tags:[system] id:posts/Bash-语法参数.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Bash-%E8%AF%AD%E6%B3%95%E5%8F%82%E6%95%B0/] posts/Golang-too_many_open_files-解决方法.md:map[title:Golang-too_many_open_files-解决方法 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108ca9e0 layout:post tags:[golang] id:posts/Golang-too_many_open_files-解决方法.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-too_many_open_files-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/] posts/Golang-判断文件是否存在.md:map[title:Golang-判断文件是否存在 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090cb20 layout:post tags:[golang] id:posts/Golang-判断文件是否存在.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/] posts/Golang-反射篇.md:map[tags:[] id:posts/Golang-反射篇.md _date:2014-07-10 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E5%8F%8D%E5%B0%84%E7%AF%87/ title:Golang-反射篇 date:2014-07-10 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090cf00 layout:post] posts/Golang-语言文件操作.md:map[title:Golang-语言文件操作 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108d3b40 layout:post tags:[golang] id:posts/Golang-语言文件操作.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/] posts/Libev-初识.md:map[tags:[c++] id:posts/Libev-初识.md _date:2014-07-18 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Libev-%E5%88%9D%E8%AF%86/ title:Libev-初识 date:2014-07-18 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090cb00 layout:post] posts/Linux-ALSA-配置.md:map[tags:[system] id:posts/Linux-ALSA-配置.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Linux-ALSA-%E9%85%8D%E7%BD%AE/ title:Linux ALSA 配置 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090cee0 layout:post] posts/ulimit.md:map[tags:[system] id:posts/ulimit.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/ulimit/ title:ulimit date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c320 layout:post] posts/命名规范-Java.md:map[tags:[java] id:posts/命名规范-Java.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83-Java/ title:命名规范-Java date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108d3500 layout:post] posts/通过代码了解-Golang-interface.md:map[tags:[golang] id:posts/通过代码了解-Golang-interface.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E4%BA%86%E8%A7%A3-Golang-interface/ title:通过代码了解-Golang-interface date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x109a14a0 layout:post] posts/3G-网卡适配.md:map[tags:[system] id:posts/3G-网卡适配.md _date:2014-07-10 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/3G-%E7%BD%91%E5%8D%A1%E9%80%82%E9%85%8D/ title:3G-网卡适配 date:2014-07-10 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c020 layout:post] posts/Go-Ping.md:map[tags:[golang] id:posts/Go-Ping.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Go-Ping/ title:Go-Ping date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e85c0 layout:post] posts/OpenVPN-时间错误会造成VPN无法正常连接.md:map[tags:[system] id:posts/OpenVPN-时间错误会造成VPN无法正常连接.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/OpenVPN-%E6%97%B6%E9%97%B4%E9%94%99%E8%AF%AF%E4%BC%9A%E9%80%A0%E6%88%90VPN%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%BF%9E%E6%8E%A5/ title:OpenVPN-时间错误会造成VPN无法正常连接 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10951560 layout:post] posts/x-go-binding.md:map[title:x-go-binding date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c860 layout:post tags:[golang] id:posts/x-go-binding.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/x-go-binding/] posts/内存系统打包方式.md:map[tags:[system] id:posts/内存系统打包方式.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F/ title:内存系统打包方式 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8280 layout:post] posts/求两个矩阵相交面积.md:map[tags:[golang] id:posts/求两个矩阵相交面积.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/%E6%B1%82%E4%B8%A4%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%BA%A4%E9%9D%A2%E7%A7%AF/ title:求两个矩阵相交面积 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108caa80 layout:post] posts/HTTP-Client-Transport.md:map[tags:[golang] id:posts/HTTP-Client-Transport.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/HTTP-Client-Transport/ title:HTTP-Client-Transport date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c340 layout:post] posts/Linux-启动时显示详细启动过程.md:map[title:Linux-启动时显示详细启动过程 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108ca060 layout:post tags:[system] id:posts/Linux-启动时显示详细启动过程.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Linux-%E5%90%AF%E5%8A%A8%E6%97%B6%E6%98%BE%E7%A4%BA%E8%AF%A6%E7%BB%86%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/] posts/Linux-驱动加载.md:map[title:Linux-驱动加载 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10896c20 layout:post tags:[system] id:posts/Linux-驱动加载.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Linux-%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD/] posts/系统分隔符-Windows-and-Linux.md:map[title:系统分隔符-Windows-and-Linux date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10896f80 layout:post tags:[system] id:posts/系统分隔符-Windows-and-Linux.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/%E7%B3%BB%E7%BB%9F%E5%88%86%E9%9A%94%E7%AC%A6-Windows-and-Linux/] posts/Golang-读取文件信息-FileInfo-and-MD5.md:map[title:Golang-读取文件信息-FileInfo-and-MD5 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108ca2a0 layout:post tags:[golang] id:posts/Golang-读取文件信息-FileInfo-and-MD5.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF-FileInfo-and-MD5/] posts/MBR-引导区文件.md:map[title:MBR-引导区文件 date:2014-07-10 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x109513a0 layout:post tags:[system] id:posts/MBR-引导区文件.md _date:2014-07-10 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/MBR-%E5%BC%95%E5%AF%BC%E5%8C%BA%E6%96%87%E4%BB%B6/] posts/Golang-内置的类型和函数.md:map[tags:[golang] id:posts/Golang-内置的类型和函数.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E5%86%85%E7%BD%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%87%BD%E6%95%B0/ title:Golang-内置的类型和函数 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c460 layout:post] posts/Golang-设置系统时间.md:map[tags:[golang] id:posts/Golang-设置系统时间.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/ title:Golang-设置系统时间 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108d3740 layout:post] posts/Shell-删除文件中某一行方法.md:map[tags:[system] id:posts/Shell-删除文件中某一行方法.md _date:2014-07-10 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Shell-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9F%90%E4%B8%80%E8%A1%8C%E6%96%B9%E6%B3%95/ title:Shell-删除文件中某一行方法 date:2014-07-10 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x109a16c0 layout:post] posts/old_passwords.md:map[tags:[system] id:posts/old_passwords.md _date:2014-07-10 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/old_passwords/ title:old_passwords date:2014-07-10 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10951940 layout:post] posts/命名规范-Golang.md:map[tags:[golang] id:posts/命名规范-Golang.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83-Golang/ title:命名规范-Golang date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8e00 layout:post] posts/在Golang中获取系统的磁盘内存占用.md:map[title:在Golang中获取系统的磁盘内存占用 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108d3ac0 layout:post tags:[golang] id:posts/在Golang中获取系统的磁盘内存占用.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/%E5%9C%A8Golang%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A3%81%E7%9B%98%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/] posts/Error-in-service-module.md:map[tags:[system] id:posts/Error-in-service-module.md _date:2014-07-09 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Error-in-service-module/ title:Error-in-service-module date:2014-07-09 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e82c0 layout:post] posts/Golang-传递-小抄.md:map[tags:[golang] id:posts/Golang-传递-小抄.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E4%BC%A0%E9%80%92-%E5%B0%8F%E6%8A%84/ title:Golang 传递 小抄 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10896e00 layout:post] posts/Linux-内核升级-内核编译步骤.md:map[title:Linux-内核升级-内核编译步骤 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108d3c20 layout:post tags:[system] id:posts/Linux-内核升级-内核编译步骤.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Linux-%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4/] posts/Linux-系统时区修改.md:map[title:Linux-系统时区修改 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108ca500 layout:post tags:[system] id:posts/Linux-系统时区修改.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Linux-%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%8C%BA%E4%BF%AE%E6%94%B9/] posts/Linux下Shell脚本输出带颜色文字.md:map[tags:[system] id:posts/Linux下Shell脚本输出带颜色文字.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Linux%E4%B8%8BShell%E8%84%9A%E6%9C%AC%E8%BE%93%E5%87%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%E6%96%87%E5%AD%97/ title:Linux下Shell脚本输出带颜色文字 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10951140 layout:post] posts/SSH--C-压缩传输.md:map[title:SSH--C-压缩传输 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x109a1320 layout:post tags:[system] id:posts/SSH--C-压缩传输.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/SSH--C-%E5%8E%8B%E7%BC%A9%E4%BC%A0%E8%BE%93/] posts/对于WIFI密码中带有英文字符或特殊字符.md:map[tags:[system] id:posts/对于WIFI密码中带有英文字符或特殊字符.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/%E5%AF%B9%E4%BA%8EWIFI%E5%AF%86%E7%A0%81%E4%B8%AD%E5%B8%A6%E6%9C%89%E8%8B%B1%E6%96%87%E5%AD%97%E7%AC%A6%E6%88%96%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/ title:对于WIFI密码中带有英文字符或特殊字符 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108ca120 layout:post] posts/Golang-Get-exit-code.md:map[title:Golang-Get-exit-code date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8b00 layout:post tags:[golang] id:posts/Golang-Get-exit-code.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-Get-exit-code/] posts/Golang-int-转-string.md:map[tags:[golang] id:posts/Golang-int-转-string.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-int-%E8%BD%AC-string/ title:Golang-int-转-string date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108ca400 layout:post] posts/Golang-上传-and-接收-文件.md:map[title:Golang-上传-and-接收-文件 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108caf80 layout:post tags:[golang] id:posts/Golang-上传-and-接收-文件.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E4%B8%8A%E4%BC%A0-and-%E6%8E%A5%E6%94%B6-%E6%96%87%E4%BB%B6/] posts/Linux-修改MAC地址方法.md:map[tags:[system] id:posts/Linux-修改MAC地址方法.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Linux-%E4%BF%AE%E6%94%B9MAC%E5%9C%B0%E5%9D%80%E6%96%B9%E6%B3%95/ title:Linux-修改MAC地址方法 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108d3700 layout:post] posts/SDL-在屏幕上输出一张图片.md:map[title:SDL-在屏幕上输出一张图片 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x109a10c0 layout:post tags:[ffmpeg] id:posts/SDL-在屏幕上输出一张图片.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/SDL-%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E8%BE%93%E5%87%BA%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87/] posts/Systemd-FAQ-简体中文.md:map[tags:[system] id:posts/Systemd-FAQ-简体中文.md _date:2014-07-08 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Systemd-FAQ-%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87/ title:Systemd-FAQ-简体中文 date:2014-07-08 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x109a18e0 layout:post] posts/一个简单的播放器.md:map[tags:[ffmpeg] id:posts/一个简单的播放器.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%92%AD%E6%94%BE%E5%99%A8/ title:一个简单的播放器 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090cc80 layout:post] posts/静态方法跟实例方法.md:map[tags:[笔记] id:posts/静态方法跟实例方法.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%B7%9F%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/ title:静态方法跟实例方法 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x109a1700 layout:post] posts/Golang-Go语言断点续传.md:map[title:Golang Go语言断点续传 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8f60 layout:post tags:[golang] id:posts/Golang-Go语言断点续传.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-Go%E8%AF%AD%E8%A8%80%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/] posts/Golang-udp-服务端-and-客户端.md:map[title:Golang-udp-服务端-and-客户端 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108cac60 layout:post tags:[] id:posts/Golang-udp-服务端-and-客户端.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-udp-%E6%9C%8D%E5%8A%A1%E7%AB%AF-and-%E5%AE%A2%E6%88%B7%E7%AB%AF/] posts/Golang-字符串操作处理包-Strings.md:map[title:Golang-字符串操作处理包-Strings date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c3e0 layout:post tags:[golang] id:posts/Golang-字符串操作处理包-Strings.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%A4%84%E7%90%86%E5%8C%85-Strings/] posts/Golang-绘图技术-image-draw-包介绍.md:map[tags:[golang] id:posts/Golang-绘图技术-image-draw-包介绍.md _date:2014-07-09 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E7%BB%98%E5%9B%BE%E6%8A%80%E6%9C%AF-image-draw-%E5%8C%85%E4%BB%8B%E7%BB%8D/ title:Golang-绘图技术-image-draw-包介绍 date:2014-07-09 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108d33a0 layout:post] posts/Linux-下强制Copy文件.md:map[tags:[system] id:posts/Linux-下强制Copy文件.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Linux-%E4%B8%8B%E5%BC%BA%E5%88%B6Copy%E6%96%87%E4%BB%B6/ title:Linux-下强制Copy文件 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8860 layout:post] posts/Linux-下隐藏鼠标的方法.md:map[tags:[system] id:posts/Linux-下隐藏鼠标的方法.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Linux-%E4%B8%8B%E9%9A%90%E8%97%8F%E9%BC%A0%E6%A0%87%E7%9A%84%E6%96%B9%E6%B3%95/ title:Linux-下隐藏鼠标的方法 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108d3280 layout:post] posts/Linux-通过-proc-查看硬件信息.md:map[tags:[system] id:posts/Linux-通过-proc-查看硬件信息.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Linux-%E9%80%9A%E8%BF%87-proc-%E6%9F%A5%E7%9C%8B%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/ title:Linux-通过-proc-查看硬件信息 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108caa20 layout:post] posts/Python-auto_network.md:map[title:Python-auto_network date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10951d40 layout:post tags:[python] id:posts/Python-auto_network.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Python-auto_network/] posts/adb常用命令.md:map[title:adb常用命令 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10951400 layout:post tags:[android] id:posts/adb常用命令.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/] posts/Golang-strconv.md:map[title:Golang-strconv date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108ca6e0 layout:post tags:[golang] id:posts/Golang-strconv.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-strconv/] posts/Golang-创建守护进程.md:map[tags:[golang] id:posts/Golang-创建守护进程.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/ title:Golang-创建守护进程 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c940 layout:post] posts/Golang-导出内容到-Excel.md:map[tags:[golang] id:posts/Golang-导出内容到-Excel.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E5%AF%BC%E5%87%BA%E5%86%85%E5%AE%B9%E5%88%B0-Excel/ title:Golang-导出内容到-Excel date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090cc00 layout:post] posts/Linux-下设置屏幕分辨率方法.md:map[title:Linux-下设置屏幕分辨率方法 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8e20 layout:post tags:[system] id:posts/Linux-下设置屏幕分辨率方法.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Linux-%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87%E6%96%B9%E6%B3%95/] posts/PXE-引导纯内存OpenSUSE方案.md:map[title:PXE引导纯内存OpenSUSE方案 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10951740 layout:post tags:[system] id:posts/PXE-引导纯内存OpenSUSE方案.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/PXE%E5%BC%95%E5%AF%BC%E7%BA%AF%E5%86%85%E5%AD%98OpenSUSE%E6%96%B9%E6%A1%88/] posts/SSH-远程登录慢的原因.md:map[tags:[system] id:posts/SSH-远程登录慢的原因.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/SSH-%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0/ title:SSH-远程登录慢的原因 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x109a1500 layout:post] posts/命名规范-Bash.md:map[tags:[system] id:posts/命名规范-Bash.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83-Bash/ title:命名规范-Bash date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8920 layout:post] posts/Golang-GoSerial.md:map[title:Golang-GoSerial date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8d40 layout:post tags:[golang] id:posts/Golang-GoSerial.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-GoSerial/] posts/Golang-Screenshot.md:map[title:Golang-Screenshot date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108d35c0 layout:post tags:[golang] id:posts/Golang-Screenshot.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-Screenshot/] posts/Golang-正则-regexp.md:map[tags:[golang] id:posts/Golang-正则-regexp.md _date:2014-07-10 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E6%AD%A3%E5%88%99-regexp/ title:Golang-正则-regexp date:2014-07-10 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8900 layout:post] posts/exec.Command-status.ExitStatus.md:map[title:exec.Command-status.ExitStatus date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10951660 layout:post tags:[golang] id:posts/exec.Command-status.ExitStatus.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/exec.Command-status.ExitStatus/] posts/Golang-cmd.Process.md:map[title:Golang-cmd.Process date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108d3dc0 layout:post tags:[golang] id:posts/Golang-cmd.Process.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-cmd.Process/] posts/Golang-文件操作.md:map[tags:[golang] id:posts/Golang-文件操作.md _date:2014-07-15 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/ title:Golang-文件操作 date:2014-07-15 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8020 layout:post] posts/Golang-绘图基础-不同的输出源.md:map[tags:[golang] id:posts/Golang-绘图基础-不同的输出源.md _date:2014-07-09 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80-%E4%B8%8D%E5%90%8C%E7%9A%84%E8%BE%93%E5%87%BA%E6%BA%90/ title:Golang-绘图基础-不同的输出源 date:2014-07-09 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8d80 layout:post] posts/Python-New-Danoo_Auto_Network.md:map[tags:[python] id:posts/Python-New-Danoo_Auto_Network.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Python-New-Danoo_Auto_Network/ title:Python-New-Danoo_Auto_Network date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10951920 layout:post] posts/Tinycore-Linux.md:map[title:Tinycore-Linux date:2014-07-10 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x109a1b20 layout:post tags:[system] id:posts/Tinycore-Linux.md _date:2014-07-10 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Tinycore-Linux/] posts/Xorg.md:map[tags:[system] id:posts/Xorg.md _date:2014-07-15 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Xorg/ title:Xorg date:2014-07-15 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10951120 layout:post] posts/把Go程序变小的办法.md:map[tags:[golang] id:posts/把Go程序变小的办法.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/%E6%8A%8AGo%E7%A8%8B%E5%BA%8F%E5%8F%98%E5%B0%8F%E7%9A%84%E5%8A%9E%E6%B3%95/ title:把Go程序变小的办法 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108ca5a0 layout:post] posts/Golang-绘图基础-绘制简单图形.md:map[title:Golang-绘图基础-绘制简单图形 date:2014-07-09 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108d3020 layout:post tags:[golang] id:posts/Golang-绘图基础-绘制简单图形.md _date:2014-07-09 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80-%E7%BB%98%E5%88%B6%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2/] posts/Jsoncpp的使用.md:map[tags:[笔记] id:posts/Jsoncpp的使用.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Jsoncpp%E7%9A%84%E4%BD%BF%E7%94%A8/ title:Jsoncpp的使用 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c760 layout:post] posts/Linux-下添加路由的方法.md:map[title:Linux-下添加路由的方法 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8b60 layout:post tags:[system] id:posts/Linux-下添加路由的方法.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Linux-%E4%B8%8B%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1%E7%9A%84%E6%96%B9%E6%B3%95/] posts/Python-New-danoo_3g_dog.py-and-danoo_3g_dial.py.md:map[tags:[python] id:posts/Python-New-danoo_3g_dog.py-and-danoo_3g_dial.py.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Python-New-danoo_3g_dog.py-and-danoo_3g_dial.py/ title:Python-New-danoo_3g_dog.py-and-danoo_3g_dial.py date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10951ae0 layout:post] posts/udev-mount-umount.md:map[tags:[system] id:posts/udev-mount-umount.md _date:2014-07-15 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/udev-mount-umount/ title:udev-mount-umount date:2014-07-15 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10951f40 layout:post] posts/Golang-Time.md:map[title:Golang-Time date:2014-07-15 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108d39e0 layout:post tags:[system] id:posts/Golang-Time.md _date:2014-07-15 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-Time/] posts/Golang-使用命令行参数.md:map[tags:[golang] id:posts/Golang-使用命令行参数.md _date:2014-07-15 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/ title:Golang-使用命令行参数 date:2014-07-15 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c200 layout:post] posts/Golang-字体-FreeType-go.md:map[title:Golang-字体-FreeType-go date:2014-07-09 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c0e0 layout:post tags:[] id:posts/Golang-字体-FreeType-go.md _date:2014-07-09 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E5%AD%97%E4%BD%93-FreeType-go/] posts/Golang-标准库解读-基本的IO接口.md:map[tags:[golang] id:posts/Golang-标准库解读-基本的IO接口.md _date:2014-07-10 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E6%A0%87%E5%87%86%E5%BA%93%E8%A7%A3%E8%AF%BB-%E5%9F%BA%E6%9C%AC%E7%9A%84IO%E6%8E%A5%E5%8F%A3/ title:Golang-标准库解读-基本的IO接口 date:2014-07-10 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8500 layout:post] posts/Linux-date-命令使用技巧.md:map[title:Linux-date-命令使用技巧 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8420 layout:post tags:[system] id:posts/Linux-date-命令使用技巧.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Linux-date-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/] posts/网线八根线的作用.md:map[tags:[system] id:posts/网线八根线的作用.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/%E7%BD%91%E7%BA%BF%E5%85%AB%E6%A0%B9%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8/ title:网线八根线的作用 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x109a1260 layout:post] posts/Connection-close.md:map[title:Connection-close date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c4c0 layout:post tags:[golang] id:posts/Connection-close.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Connection-close/] posts/Golang-http-超时设置方法.md:map[tags:[golang] id:posts/Golang-http-超时设置方法.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-http-%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/ title:Golang http 超时设置方法 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108ca100 layout:post] posts/Date-命令设置系统时间的方法.md:map[tags:[system] id:posts/Date-命令设置系统时间的方法.md _date:2014-07-10 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Date-%E5%91%BD%E4%BB%A4%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95/ title:Date-命令设置系统时间的方法 date:2014-07-10 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c6a0 layout:post] posts/Golang-Raster-字体颜色.md:map[tags:[golang] id:posts/Golang-Raster-字体颜色.md _date:2014-07-09 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-Raster-%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2/ title:Golang-Raster-字体颜色 date:2014-07-09 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108d3220 layout:post] posts/Golang-官方图片库.md:map[tags:[golang] id:posts/Golang-官方图片库.md _date:2014-07-09 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E5%AE%98%E6%96%B9%E5%9B%BE%E7%89%87%E5%BA%93/ title:Golang-官方图片库 date:2014-07-09 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c720 layout:post] posts/Golang-实现图片缩放.md:map[title:Golang-实现图片缩放 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090c9a0 layout:post tags:[golang] id:posts/Golang-实现图片缩放.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE/] posts/Golang-纳秒级别-局域网-广播-时间同步.md:map[title:Golang-纳秒级别-局域网-广播-时间同步 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e8b40 layout:post tags:[golang] id:posts/Golang-纳秒级别-局域网-广播-时间同步.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E7%BA%B3%E7%A7%92%E7%BA%A7%E5%88%AB-%E5%B1%80%E5%9F%9F%E7%BD%91-%E5%B9%BF%E6%92%AD-%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/] posts/Golang-读取字符串流-ICCID.md:map[title:Golang-读取字符串流-ICCID date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108d3f60 layout:post tags:[golang] id:posts/Golang-读取字符串流-ICCID.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E8%AF%BB%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81-ICCID/] posts/Linux-通过文件修改密码.md:map[tags:[system] id:posts/Linux-通过文件修改密码.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Linux-%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/ title:Linux-通过文件修改密码 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108cade0 layout:post] posts/Python-danoo_3g_dog.py-and-danoo_3g_dial.py.md:map[title:Python-danoo_3g_dog.py-and-danoo_3g_dial.py date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10951f00 layout:post tags:[python] id:posts/Python-danoo_3g_dog.py-and-danoo_3g_dial.py.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Python-danoo_3g_dog.py-and-danoo_3g_dial.py/] posts/用sshpass实现ssh的自动登陆.md:map[tags:[system] id:posts/用sshpass实现ssh的自动登陆.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/%E7%94%A8sshpass%E5%AE%9E%E7%8E%B0ssh%E7%9A%84%E8%87%AA%E5%8A%A8%E7%99%BB%E9%99%86/ title:用sshpass实现ssh的自动登陆 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108caee0 layout:post] posts/Go-ioutil-翻译.md:map[tags:[golang] id:posts/Go-ioutil-翻译.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Go-ioutil-%E7%BF%BB%E8%AF%91/ title:Go-ioutil-翻译 date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108e88a0 layout:post] posts/Golang-压缩-解压-Tar.Gz.md:map[title:Golang-压缩-解压-Tar.Gz date:2014-07-04 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x1090cd00 layout:post tags:[golang] id:posts/Golang-压缩-解压-Tar.Gz.md _date:2014-07-04 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang-%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B-Tar.Gz/] posts/Golang之路-定时任务.md:map[tags:[golang] id:posts/Golang之路-定时任务.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/Golang%E4%B9%8B%E8%B7%AF-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/ title:Golang之路-定时任务 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x108ca5c0 layout:post] posts/socket.cpp-监听解码.md:map[tags:[笔记] id:posts/socket.cpp-监听解码.md _date:2014-07-03 00:00:00 +0000 UTC permalink:/:categories/:title/ url:/default/socket.cpp-%E7%9B%91%E5%90%AC%E8%A7%A3%E7%A0%81/ title:socket.cpp-监听解码 date:2014-07-03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[default] _content:0x10951c40 layout:post]] tags:map[golang:0x109a17c0 python:0x109a1d40 system:0x109a1da0 笔记:0x109a1f20 c++:0x10996500 java:0x10996720 ffmpeg:0x10996cc0 android:0x10996ea0] categories:map[default:0x109a1800] chronological:[posts/Libev-初识.md posts/udev-mount-umount.md posts/Xorg.md posts/Golang-文件操作.md posts/Golang-使用命令行参数.md posts/Golang-Time.md posts/old_passwords.md posts/Tinycore-Linux.md posts/Shell-删除文件中某一行方法.md posts/MBR-引导区文件.md posts/Golang-正则-regexp.md posts/Golang-标准库解读-基本的IO接口.md posts/Golang-反射篇.md posts/Date-命令设置系统时间的方法.md posts/3G-网卡适配.md posts/Golang-绘图技术-image-draw-包介绍.md posts/Golang-绘图基础-绘制简单图形.md posts/Golang-绘图基础-不同的输出源.md posts/Golang-官方图片库.md posts/Golang-字体-FreeType-go.md posts/Golang-Raster-字体颜色.md posts/Error-in-service-module.md posts/Systemd-FAQ-简体中文.md posts/通过代码了解-Golang-interface.md posts/网线八根线的作用.md posts/系统分隔符-Windows-and-Linux.md posts/用sshpass实现ssh的自动登陆.md posts/对于WIFI密码中带有英文字符或特殊字符.md posts/在Golang中获取系统的磁盘内存占用.md posts/命名规范-Java.md posts/命名规范-Golang.md posts/命名规范-Bash.md posts/ulimit.md posts/exec.Command-status.ExitStatus.md posts/SSH-远程登录慢的原因.md posts/SSH--C-压缩传输.md posts/Python-danoo_3g_dog.py-and-danoo_3g_dial.py.md posts/Python-auto_network.md posts/Python-New-danoo_3g_dog.py-and-danoo_3g_dial.py.md posts/Python-New-Danoo_Auto_Network.md posts/OpenVPN-时间错误会造成VPN无法正常连接.md posts/Linux下Shell脚本输出带颜色文字.md posts/Linux-驱动加载.md posts/Linux-通过文件修改密码.md posts/Linux-通过-proc-查看硬件信息.md posts/Linux-系统时区修改.md posts/Linux-内核升级-内核编译步骤.md posts/Linux-修改MAC地址方法.md posts/Linux-下隐藏鼠标的方法.md posts/Linux-下添加路由的方法.md posts/Linux-下强制Copy文件.md posts/Linux-date-命令使用技巧.md posts/Linux-ALSA-配置.md posts/HTTP-Client-Transport.md posts/Golang-读取文件信息-FileInfo-and-MD5.md posts/Golang-读取字符串流-ICCID.md posts/Golang-语言文件操作.md posts/Golang-纳秒级别-局域网-广播-时间同步.md posts/Golang-导出内容到-Excel.md posts/Golang-字符串操作处理包-Strings.md posts/Golang-压缩-解压-Tar.Gz.md posts/Golang-判断文件是否存在.md posts/Golang-创建守护进程.md posts/Golang-内置的类型和函数.md posts/Golang-上传-and-接收-文件.md posts/Golang-udp-服务端-and-客户端.md posts/Golang-too_many_open_files-解决方法.md posts/Golang-strconv.md posts/Golang-int-转-string.md posts/Golang-cmd.Process.md posts/Golang-GoSerial.md posts/Golang-Get-exit-code.md posts/Go-ioutil-翻译.md posts/Connection-close.md posts/Bash-语法参数.md posts/静态方法跟实例方法.md posts/求两个矩阵相交面积.md posts/把Go程序变小的办法.md posts/内存系统打包方式.md posts/一个简单的播放器.md posts/x-go-binding.md posts/socket.cpp-监听解码.md posts/adb常用命令.md posts/SDL-在屏幕上输出一张图片.md posts/PXE-引导纯内存OpenSUSE方案.md posts/Linux-启动时显示详细启动过程.md posts/Linux-下设置屏幕分辨率方法.md posts/Jsoncpp的使用.md posts/Golang之路-定时任务.md posts/Golang-设置系统时间.md posts/Golang-实现图片缩放.md posts/Golang-传递-小抄.md posts/Golang-http-超时设置方法.md posts/Golang-Screenshot.md posts/Golang-Go语言断点续传.md posts/Go-Ping.md] collated:[0x109a1860]]]]&amp;quot;/&amp;gt;&#xA; &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;upload&amp;quot; /&amp;gt;&#xA;&amp;lt;/form&amp;gt;&#xA;&amp;lt;/body&amp;gt;&#xA;&amp;lt;/html&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在服务器端，我们增加一个handlerFunc:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http.HandleFunc(&amp;quot;/upload&amp;quot;, upload)&#xA;&#xA;// 处理/upload 逻辑&#xA;func upload(w http.ResponseWriter, r *http.Request) {&#xA;    fmt.Println(&amp;quot;method:&amp;quot;, r.Method) //获取请求的方法&#xA;    if r.Method == &amp;quot;GET&amp;quot; {&#xA;        crutime := time.Now().Unix()&#xA;        h := md5.New()&#xA;        io.WriteString(h, strconv.FormatInt(crutime, 10))&#xA;        token := fmt.Sprintf(&amp;quot;%x&amp;quot;, h.Sum(nil))&#xA;        t, _ := template.ParseFiles(&amp;quot;upload.gtpl&amp;quot;)&#xA;        t.Execute(w, token)&#xA;    } else {&#xA;        r.ParseMultipartForm(32 &amp;lt;&amp;lt; 20)&#xA;        file, handler, err := r.FormFile(&amp;quot;uploadfile&amp;quot;)&#xA;        if err != nil {&#xA;            fmt.Println(err)&#xA;            return&#xA;        }&#xA;        defer file.Close()&#xA;        fmt.Fprintf(w, &amp;quot;%v&amp;quot;, handler.Header)&#xA;        f, err := os.OpenFile(&amp;quot;./test/&amp;quot;+handler.Filename, os.O_WRONLY|os.O_CREATE, 0666)&#xA;        if err != nil {&#xA;            fmt.Println(err)&#xA;            return&#xA;        }&#xA;        defer f.Close()&#xA;        io.Copy(f, file)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过上面的代码可以看到，处理文件上传我们需要调用&lt;code&gt;r.ParseMultipartForm&lt;/code&gt;，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;里面的参数表示&lt;code&gt;maxMemory&lt;/code&gt;，调用&lt;code&gt;ParseMultipartForm&lt;/code&gt;之后，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;上传的文件存储在&lt;code&gt;maxMemory&lt;/code&gt;大小的内存里面，如果文件大小超过了&lt;code&gt;maxMemory&lt;/code&gt;，那么剩下的部分将存储在系统的临时文件中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们可以通过&lt;code&gt;r.FormFile&lt;/code&gt;获取上面的文件句柄，然后实例中使用了&lt;code&gt;io.Copy&lt;/code&gt;来存储文件。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获取其他非文件字段信息的时候就不需要调用&lt;code&gt;r.ParseForm&lt;/code&gt;，因为在需要的时候Go自动会去调用。而且&lt;code&gt;ParseMultipartForm&lt;/code&gt;调用一次之后，后面再次调用不会再有效果。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过上面的实例我们可以看到我们上传文件主要三步处理：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1. 表单中增加enctype=&amp;quot;multipart/form-data&amp;quot;&#xA;2. 服务端调用`r.ParseMultipartForm`,把上传的文件存储在内存和临时文件中&#xA;3. 使用`r.FormFile`获取文件句柄，然后对文件进行存储等处理。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;文件handler是multipart.FileHeader,里面存储了如下结构信息&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type FileHeader struct {&#xA;Filename string&#xA;Header   textproto.MIMEHeader&#xA;// contains filtered or unexported fields&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们通过上面的实例代码打印出来上传文件的信息如下&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;![](images/4.5.upload2.png?raw=true)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打印文件上传后服务器端接受的信息&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;客户端上传文件&#34; href=&#34;#客户端上传文件&#34;&gt;&lt;/a&gt;客户端上传文件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;我们上面的例子演示了如何通过表单上传文件，然后在服务器端处理文件，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其实Go支持模拟客户端表单功能支持文件上传，详细用法请看如下示例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;&amp;quot;bytes&amp;quot;&#xA;&amp;quot;fmt&amp;quot;&#xA;&amp;quot;io&amp;quot;&#xA;&amp;quot;io/ioutil&amp;quot;&#xA;&amp;quot;mime/multipart&amp;quot;&#xA;&amp;quot;net/http&amp;quot;&#xA;&amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func postFile(filename string, targetUrl string) error {&#xA;    bodyBuf := &amp;amp;bytes.Buffer{}&#xA;    bodyWriter := multipart.NewWriter(bodyBuf)&#xA;&#xA;    //关键的一步操作&#xA;    fileWriter, err := bodyWriter.CreateFormFile(&amp;quot;uploadfile&amp;quot;, filename)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;error writing to buffer&amp;quot;)&#xA;        return err&#xA;    }&#xA;&#xA;    //打开文件句柄操作&#xA;    fh, err := os.Open(filename)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;error opening file&amp;quot;)&#xA;        return err&#xA;    }&#xA;&#xA;    //iocopy&#xA;    _, err = io.Copy(fileWriter, fh)&#xA;    if err != nil {&#xA;        return err&#xA;    }&#xA;&#xA;    contentType := bodyWriter.FormDataContentType()&#xA;    bodyWriter.Close()&#xA;&#xA;    resp, err := http.Post(targetUrl, contentType, bodyBuf)&#xA;    if err != nil {&#xA;        return err&#xA;    }&#xA;    defer resp.Body.Close()&#xA;    resp_body, err := ioutil.ReadAll(resp.Body)&#xA;    if err != nil {&#xA;        return err&#xA;    }&#xA;    fmt.Println(resp.Status)&#xA;    fmt.Println(string(resp_body))&#xA;    return nil&#xA;}&#xA;&#xA;// sample usage&#xA;func main() {&#xA;    target_url := &amp;quot;http://localhost:9090/upload&amp;quot;&#xA;    filename := &amp;quot;./astaxie.pdf&amp;quot;&#xA;    postFile(filename, target_url)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面的例子详细展示了客户端如何向服务器上传一个文件的例子，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;客户端通过multipart.Write把文件的文本流写入一个缓存中，然后调用http的Post方法把缓存传到服务器。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你还有其他普通字段例如username之类的需要同时写入，那么可以调用multipart的WriteField方法写很多其他类似的字段。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-udp-服务端-and-客户端</title>
      <link>http://www.nljb.net/default/Golang-udp-%E6%9C%8D%E5%8A%A1%E7%AB%AF-and-%E5%AE%A2%E6%88%B7%E7%AB%AF/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;其实udp没有什么服务端和客户端的概念了,只是一个发一个收而已,只是这样叫方便能识别和理解.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;服务端:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-udp-服务端-and-客户端/1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;客户端:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-udp-服务端-and-客户端/2.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-too_many_open_files-解决方法</title>
      <link>http://www.nljb.net/default/Golang-too_many_open_files-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;这是系统资源限制，通常单进程不能超过 1024，我使用cgo来设置，代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;/*&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;sys/time.h&amp;gt;&#xA;#include &amp;lt;sys/resource.h&amp;gt;&#xA;&#xA;int rlimit_init() {&#xA;    printf(&amp;quot;setting rlimit\n&amp;quot;);&#xA;&#xA;    struct rlimit limit;&#xA;&#xA;    if (getrlimit(RLIMIT_NOFILE, &amp;amp;limit) == -1) {&#xA;    printf(&amp;quot;getrlimit error\n&amp;quot;);&#xA;    return 1;&#xA;    }&#xA;&#xA;    limit.rlim_cur = limit.rlim_max = 50000;&#xA;&#xA;    if (setrlimit(RLIMIT_NOFILE, &amp;amp;limit) == -1) {&#xA;    printf(&amp;quot;setrlimit error\n&amp;quot;);&#xA;    return 1;&#xA;    }&#xA;&#xA;    printf(&amp;quot;set limit ok\n&amp;quot;);&#xA;    return 0;&#xA;}&#xA;*/&#xA;import &amp;quot;C&amp;quot;&#xA;&#xA;func main() {&#xA;    C.rlimit_init()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;或者使用 syscall 包&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var rlim syscall.Rlimit&#xA;err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &amp;amp;rlim)&#xA;if err != nil {&#xA;    fmt.Println(&amp;quot;get rlimit error: &amp;quot; + err.Error())&#xA;    os.Exit(1)&#xA;}&#xA;rlim.Cur = 50000&#xA;rlim.Max = 50000&#xA;err = syscall.Setrlimit(syscall.RLIMIT_NOFILE, &amp;amp;rlim)&#xA;if err != nil {&#xA;    fmt.Println(&amp;quot;set rlimit error: &amp;quot; + err.Error())&#xA;    os.Exit(1)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用 go build 编译后，需要以 root 权限运行。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-strconv</title>
      <link>http://www.nljb.net/default/Golang-strconv/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;a:=strconv.FormatFloat(10.100,&#39;f&#39;,-1,32) 输出:10.1&#xA;&#xA;a := strconv.FormatFloat(10.101, &#39;f&#39;, -1, 64) 输出:10.101&#xA;&#xA;a := strconv.FormatFloat(10.010, &#39;f&#39;, -1, 64) 输出：10.01&#xA;&#xA;a:=strconv.FormatFloat(10.1,&#39;f&#39;,2,64) 输出:10.10&#xA;&#xA;f 参数可以时e,E,g,G&#xA;-1 代表输出的精度小数点后的位数&#xA;如果是&amp;lt;0的值，则返回最少的位数来表示该数，如果是大于0的则返回对应位数的值&#xA;64 为float的类型，go中float分为32和64位，因此就需要传入32或者64&#xA;&#xA;golang strconv.ParseInt 是将字符串转换为数字的函数,功能灰常之强大,看的我口水直流.&#xA;&#xA;func ParseInt(s string, base int, bitSize int) (i int64, err error)&#xA;&#xA;参数1 数字的字符串形式&#xA;&#xA;参数2 数字字符串的进制 比如二进制 八进制 十进制 十六进制&#xA;&#xA;参数3 返回结果的bit大小 也就是int8 int16 int32 int64&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;strconv&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    i, err := strconv.ParseInt(&amp;quot;123&amp;quot;, 10, 32)&#xA;    if err != nil {&#xA;    panic(err)&#xA;    }&#xA;    println(i)&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-int-转-string</title>
      <link>http://www.nljb.net/default/Golang-int-%E8%BD%AC-string/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;go语言中int类型和string类型都是属于基本数据类型&lt;/p&gt;&#xA;&#xA;&lt;p&gt;两种类型的转化都非常简单&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面为大家提供两种int类型转化成string类型的方法！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;go语言的类型转化都在strconv package里面，详情请参考：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http://golang.org/pkg/strconv&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;下面附上转化代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main  &#xA;&#xA;import (  &#xA;    &amp;quot;fmt&amp;quot;  &#xA;    &amp;quot;strconv&amp;quot;  &#xA;)  &#xA;&#xA;var i int = 10  &#xA;&#xA;func main() {  &#xA;    // 通过Itoa方法转换  &#xA;    str1 := strconv.Itoa(i)  &#xA;&#xA;    // 通过Sprintf方法转换  &#xA;    str2 := fmt.Sprintf(&amp;quot;%d&amp;quot;, i)  &#xA;&#xA;    // 打印str1  &#xA;    fmt.Println(str1)  &#xA;    // 打印str2  &#xA;    fmt.Println(str2)  &#xA;}  &#xA;&#xA;%d代表Integer&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-cmd.Process</title>
      <link>http://www.nljb.net/default/Golang-cmd.Process/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;d := flag.Bool(&amp;quot;d&amp;quot;, false, &amp;quot;Whether or not to launch in the background(like a daemon)&amp;quot;)&#xA;if *d {&#xA;    cmd := exec.Command(os.Args[0],&#xA;    &amp;quot;-close-fds&amp;quot;,&#xA;    &amp;quot;-addr&amp;quot;, *addr,&#xA;    &amp;quot;-call&amp;quot;, *call,&#xA;    )&#xA;    serr, err := cmd.StderrPipe()&#xA;    if err != nil {&#xA;    log.Fatalln(err)&#xA;    }&#xA;    err = cmd.Start()&#xA;    if err != nil {&#xA;    log.Fatalln(err)&#xA;    }&#xA;    s, err := ioutil.ReadAll(serr)&#xA;    s = bytes.TrimSpace(s)&#xA;    if bytes.HasPrefix(s, []byte(&amp;quot;addr: &amp;quot;)) {&#xA;    fmt.Println(string(s))&#xA;    cmd.Process.Release()&#xA;    } else {&#xA;    log.Printf(&amp;quot;unexpected response from MarGo: `%s` error: `%v`\n&amp;quot;, s, err)&#xA;    cmd.Process.Kill()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/* ivan(a.t)mysqlab.net */&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;syscall&amp;quot;&#xA;)&#xA;&#xA;func daemon(nochdir, noclose int) int {&#xA;    var ret, ret2 uintptr&#xA;    var err uintptr&#xA;&#xA;    darwin := syscall.OS == &amp;quot;darwin&amp;quot;&#xA;&#xA;    // already a daemon&#xA;    if syscall.Getppid() == 1 {&#xA;    return 0&#xA;    }&#xA;&#xA;    // fork off the parent process&#xA;    ret, ret2, err = syscall.RawSyscall(syscall.SYS_FORK, 0, 0, 0)&#xA;    if err != 0 {&#xA;    return -1&#xA;    }&#xA;&#xA;    // failure&#xA;    if ret2 &amp;lt; 0 {&#xA;    os.Exit(-1)&#xA;    }&#xA;&#xA;    // handle exception for darwin&#xA;    if darwin &amp;amp;&amp;amp; ret2 == 1 {&#xA;    ret = 0&#xA;    }&#xA;&#xA;    // if we got a good PID, then we call exit the parent process.&#xA;    if ret &amp;gt; 0 {&#xA;    os.Exit(0)&#xA;    }&#xA;&#xA;    /* Change the file mode mask */&#xA;    _ = syscall.Umask(0)&#xA;&#xA;    // create a new SID for the child process&#xA;    s_ret, s_errno := syscall.Setsid()&#xA;    if s_errno != 0 {&#xA;    log.Printf(&amp;quot;Error: syscall.Setsid errno: %d&amp;quot;, s_errno)&#xA;    }&#xA;    if s_ret &amp;lt; 0 {&#xA;    return -1&#xA;    }&#xA;&#xA;    if nochdir == 0 {&#xA;    os.Chdir(&amp;quot;/&amp;quot;)&#xA;    }&#xA;&#xA;    if noclose == 0 {&#xA;    f, e := os.OpenFile(&amp;quot;/dev/null&amp;quot;, os.O_RDWR, 0)&#xA;    if e == nil {&#xA;        fd := f.Fd()&#xA;        syscall.Dup2(fd, os.Stdin.Fd())&#xA;        syscall.Dup2(fd, os.Stdout.Fd())&#xA;        syscall.Dup2(fd, os.Stderr.Fd())&#xA;    }&#xA;    }&#xA;&#xA;    return 0&#xA;}&#xA;&#xA;// usage example: daemon(0, 0)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/DisposaBoy/MarGo&#34;&gt;https://github.com/DisposaBoy/MarGo&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.mysqlab.net/blog/2011/12/daemon-function-for-go-language/&#34;&gt;http://www.mysqlab.net/blog/2011/12/daemon-function-for-go-language/&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-GoSerial</title>
      <link>http://www.nljb.net/default/Golang-GoSerial/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-GoSerial/e824b899a9014c08f85495470a7b02087af4f4e1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/tarm/goserial&#34;&gt;https://github.com/tarm/goserial&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;需要预先通过go get github.com/tarm/goserial获取git地址&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后通过,下载&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/tarm/goserial /root/go/src/pkg/github.com/tarm/goserial&#xA;&#xA;package main&#xA;&#xA;import &amp;quot;fmt&amp;quot;&#xA;import &amp;quot;github.com/tarm/goserial&amp;quot;&#xA;&#xA;func main(){&#xA;&#xA;    c := &amp;amp;serial.Config{Name: &amp;quot;/dev/ttyUSB0&amp;quot;, Baud: 115200}&#xA;    s, err := serial.OpenPort(c)&#xA;    if err != nil {&#xA;    fmt.Println(err)&#xA;    }&#xA;    n, err := s.Write([]byte(&amp;quot;ATZ+CSQ\r&amp;quot;))&#xA;    if err != nil {&#xA;    fmt.Println(err)&#xA;    }&#xA;    buf := make([]byte, 2048)&#xA;    n, err = s.Read(buf)&#xA;    if err != nil {&#xA;    fmt.Println(err)&#xA;    }&#xA;    fmt.Printf(&amp;quot;%q&amp;quot;, buf[:n])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后 go build 编译即可，需要安装GCC&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-Get-exit-code</title>
      <link>http://www.nljb.net/default/Golang-Get-exit-code/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import &amp;quot;os/exec&amp;quot;&#xA;import &amp;quot;log&amp;quot;&#xA;import &amp;quot;syscall&amp;quot;&#xA;&#xA;func main() {&#xA;    cmd := exec.Command(&amp;quot;git&amp;quot;, &amp;quot;blub&amp;quot;)&#xA;&#xA;    if err := cmd.Start(); err != nil {&#xA;    log.Fatalf(&amp;quot;cmd.Start: %v&amp;quot;)&#xA;    }&#xA;&#xA;    if err := cmd.Wait(); err != nil {&#xA;    if exiterr, ok := err.(*exec.ExitError); ok {&#xA;        // The program has exited with an exit code != 0&#xA;&#xA;        // There is no plattform independent way to retrieve&#xA;        // the exit code, but the following will work on Unix&#xA;        if status, ok := exiterr.Sys().(syscall.WaitStatus); ok {&#xA;        log.Printf(&amp;quot;Exit Status: %d&amp;quot;, status.ExitStatus())&#xA;        }&#xA;    } else {&#xA;        log.Fatalf(&amp;quot;cmd.Wait: %v&amp;quot;, err)&#xA;    }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go-ioutil-翻译</title>
      <link>http://www.nljb.net/default/Go-ioutil-%E7%BF%BB%E8%AF%91/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;ioutil包&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import &amp;quot;io/ioutil&amp;quot;&#xA;ioutil包含有一些公用的I/O工具函数。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;变量&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var Discard io.Writer = devNull(0)&#xA;Discard是一个io.Writer，对其进行的所有Write呼叫都会成功但不会做任何实际的操作。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;func NopCloser&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func NopCloser(r io.Reader) io.ReadCloser&#xA;NopCloser返回一个包装r参数而来的ReadCloser接口，该接口仅提供Close方法。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;func ReadAll&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ReadAll(r io.Reader) ([]byte, error)&#xA;ReadAll从r读取直到遇到error或EOF并返回读取的数据。 成功的调用返回的err为nil，而不是EOF。因为ReadAll定义为从资源读取数据直到EOF，它不会将从r读取的EOF视为应该报告的错误。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;func ReadDir&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ReadDir(dirname string) ([]os.FileInfo, error)&#xA;ReadDir接受dirname指定的目录，并返回一个有序的、子目录信息的列表。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;func ReadFile&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ReadFile(filename string) ([]byte, error)&#xA;ReadFile从filename指定的文件中读取数据并返回文件的内容。 成功的调用返回的err为nil，而不是EOF。因为ReadFile定义为从资源读取数据直到EOF，它不会将从r读取的EOF视为应该报告的错误。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;func TempDir&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func TempDir(dir, prefix string) (name string, err error)&#xA;TempDir在指定的目录里创建一个新的、使用prfix作为前缀的临时文件夹，并返回文件夹的路径。 如果dir是空字符串，TempDir使用默认用于临时文件的目录（参见os.TempDir函数）。 如果多个程序调用该函数的话，将会创建不同的临时目录（因此是线程安全的）。调用本函数的程序有责任在不需要临时文件夹时摧毁它。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;func TempFile&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func TempFile(dir, prefix string) (f *os.File, err error)&#xA;TempFile在dir目录下创建一个新的、使用prefix为前缀的临时文件，并以读写模式打开该文件并返回os.File指针。 如果dir是空字符串，TempFile使用默认用于临时文件的目录（参见os.TempDir函数）。 如果多个程序调用该函数的话，将会创建不同的临时文件（因此是线程安全的）。调用本函数的程序有责任在不需要临时文件时摧毁它。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;func WriteFile&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func WriteFile(filename string, data []byte, perm os.FileMode) error&#xA;WriteFile向filename指定的文件中写入数据。如果文件不存在将按给出的权限创建该文件，否则本函数会在写入数据之前截断文件（即清空之）。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Connection-close</title>
      <link>http://www.nljb.net/default/Connection-close/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;Set(&amp;quot;Connection&amp;quot;, &amp;quot;close&amp;quot;) &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Bash-语法参数</title>
      <link>http://www.nljb.net/default/Bash-%E8%AF%AD%E6%B3%95%E5%8F%82%E6%95%B0/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;[ -a FILE ] 如果 FILE 存在则为真。&#xA;[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。&#xA;[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。&#xA;[ -d FILE ] 如果 FILE 存在且是一个目录则为真。&#xA;[ -e FILE ] 如果 FILE 存在则为真。&#xA;[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。&#xA;[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。&#xA;[ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。&#xA;[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。&#xA;[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。&#xA;[ -r FILE ] 如果 FILE 存在且是可读的则为真。&#xA;[ -s FILE ] 如果 FILE 存在且大小不为0则为真。&#xA;[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。&#xA;[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。&#xA;[ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。&#xA;[ -x FILE ] 如果 FILE 存在且是可执行的则为真。&#xA;[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。&#xA;[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。&#xA;[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。&#xA;[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。&#xA;[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。&#xA;[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1FILE2 does not则为真。&#xA;exists and [ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。&#xA;[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。&#xA;[ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。&#xA;[ -z STRING ] “STRING” 的长度为零则为真。&#xA;[ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。&#xA;[ STRING1 == STRING2 ] 如果2个字符串相同。 “=” may be used instead of “==” for strict POSIX compliance则为真。&#xA;[ STRING1 != STRING2 ] 如果字符串不相等则为真。&#xA;[ STRING1 &amp;lt; STRING2 ] 如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。&#xA;[ STRING1 &amp;gt; STRING2 ] 如果 “STRING1” sorts after “STRING2” lexicographically in the current locale则为真。&#xA;[ ARG1 OP ARG2 ] “OP” is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if “ARG1” is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to “ARG2”, respectively. “ARG1” and “ARG2” are integers. 表达式可以借以下操作符组合起来，以降序列出：listed in decreasing order of precedence: 表 7.2. 组合表达式操作 效果&#xA;[ ! EXPR ] 如果 EXPR 是false则为真。&#xA;[ ( EXPR ) ] 返回 EXPR的值。这样可以用来忽略正常的操作符优先级。&#xA;[ EXPR1 -a EXPR2 ] 如果 EXPR1 and EXPR2 全真则为真。&#xA;[ EXPR1 -o EXPR2 ] 如果 EXPR1 或者 EXPR2 为真则为真。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;比较字符写法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-eq 等于&#xA;-ne 不等于&#xA;-gt 大于&#xA;-lt 小于&#xA;-le 小于等于&#xA;-ge 大于等于&#xA;-z 空串&#xA;* = 两个字符相等&#xA;* != 两个字符不等&#xA;* -n 非空串&#xA;&#xA;从大到小排序是:ls -S  /&#xA;从小到大排就加个-r:  ls -Sr  /&#xA;包括隐藏文件就是：ls -aSr  /&#xA;ls -l 是长格式显示&#xA;ls -a 是包含隐藏文件&#xA;所以一般使用ls -la &#xA;&#xA;不可以，sort是处理数据流的，一般以行为单位，把每行按某种条件排列&#xA;如字母顺序、数字大小&#xA;它可以排列从文件内读取的数据&#xA;ls | sort 这个命令排列的也仅是文件名而已&#xA;ls -tr&#xA;-r 对目录反向排序。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>静态方法跟实例方法</title>
      <link>http://www.nljb.net/default/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%B7%9F%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;静态是类的，实例是对象的．&#xA;oo的观点就是静态成员就是类所有对象所具备的特点，而实例成员是每个对象自有的实现，是不一样的．&#xA;比如说每个人都有头发，眼睛，耳朵，名字，性别，年龄，身高等等．&#xA;这些都是静态的，但是每个人的这些属性是不一样的，这些不同的属性就是实例化．&#xA;所以可以说静态方法不需要依赖类当中的属性，静态方法本身就可以封闭的完成一个功能，而实例的方法更多会用到类中的属性．&#xA;静态方法在它一启动的时候就实例化了，因而静态内存是连续的，而且静态内存是有限制的；&#xA;而实例方法是在程序运行中生成内存的，实例申请的是离散的空间．静态方法大多用的数据连接上．&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>求两个矩阵相交面积</title>
      <link>http://www.nljb.net/default/%E6%B1%82%E4%B8%A4%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%BA%A4%E9%9D%A2%E7%A7%AF/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;public class Rectangle&#xA;    {&#xA;        public int x1;&#xA;        public int y1;&#xA;        public int x2;&#xA;        public int y2;&#xA;        public Rectangle(int x1, int y1, int x2, int y2)&#xA;        {&#xA;        this.x1 = x1;&#xA;        this.y1 = y1;&#xA;        this.x2 = x2;&#xA;        this.y2 = y2;&#xA;        }&#xA;    }&#xA;&#xA;    static int RectangleArea(Rectangle r1, Rectangle r2)&#xA;    {&#xA;        int maxx = Math.Max(r1.x1, r2.x1);&#xA;        int minx = Math.Min(r1.x2, r2.x2);&#xA;        int maxy = Math.Max(r1.y1, r2.y1);&#xA;        int miny = Math.Min(r1.y2, r2.y2);&#xA;&#xA;        if (minx&amp;gt;maxx &amp;amp;&amp;amp; miny &amp;gt; maxy )&#xA;        {&#xA;        return (maxx - minx) * (maxy - miny);&#xA;        }&#xA;        else&#xA;        {&#xA;        return 0;&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>把Go程序变小的办法</title>
      <link>http://www.nljb.net/default/%E6%8A%8AGo%E7%A8%8B%E5%BA%8F%E5%8F%98%E5%B0%8F%E7%9A%84%E5%8A%9E%E6%B3%95/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;把Go程序变小的办法是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go build -ldflags “-s -w” (go install类似)&#xA;&#xA;-s去掉符号表（然后panic时候的stack trace就没有任何文件名/行号信息了，这个等价于普通C/C++程序被strip的效果）&#xA;&#xA;-w去掉DWARF调试信息，得到的程序就不能用gdb调试了。&#xA;&#xA;&#xA;比如，server.go是一个简单的http server，用了net/http包。&#xA;&#xA;$ go build server.go&#xA;$ ls -l server&#xA;-rwxr-xr-x 1 minux staff 4507004 2012-10-25 14:16 server&#xA;$ go build -ldflags “-s -w” server.go &#xA;$ ls -l server&#xA;-rwxr-xr-x 1 minux staff 2839932 2012-10-25 14:16 server&#xA;&#xA;&#xA;-s和-w也可以分开使用，一般来说如果不打算用gdb调试，-w基本没啥损失。&#xA;&#xA;-s的损失就有点大了。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>内存系统打包方式</title>
      <link>http://www.nljb.net/default/%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;一、解压方法：&#xA;&#xA;###################################################&#xA;&#xA;cp initrd-2.6.24.img /home/kernel/initrd.gz　&#xA;cd /home/kernel/&#xA;gunzip -dc initrd | cpio –idmv&#xA;&#xA;###################################################&#xA;&#xA;cd /tmp &#xA;mkdir initrd &#xA;cp /boot/initrd-2.6.18-8.el5xen.img /tmp/initrd/initrd-2.6.18-8.el5xen.img.gz &#xA;cd initrd &#xA;gunzip initrd-2.6.18-8.el5xen.img.gz &#xA;cpio -ivdI initrd-2.6.18-8.el5xen.img&#xA;&#xA;########################################################&#xA;&#xA;压缩方法&#xA;find . | cpio -ocv &amp;gt;../initrd.img&#xA;find  .  -print | cpio -covB &amp;gt; [file|device] 将数据备份到文件或设备上&#xA;然后使用&#xA;gzip 压缩生成后的文件&#xA;&#xA;########################################################&#xA;&#xA;解压cpio文件 &#xA;cpio -idmv &amp;lt; filename.cpio&#xA;同样可以解压img文件：&#xA;cpio -idmv &amp;lt; filename.img&#xA;cpio备份命令&#xA;备份：cpio -covB &amp;gt; [file|device] 将数据备份到文件或设备上&#xA;还原：cpio -icduv &amp;lt; [file|device} 将数据还原到系统中&#xA;常用参数：&#xA;-o ：将数据copy到文件或设备上&#xA;-i ：将数据从文件或设备上还原到系统中&#xA;-t ：查看cpio建立的文件或设备内容&#xA;-c ：一种比较新的portable format方式存储&#xA;-v ：在屏幕上显示备份过程中的文件名&#xA;-B ：让预设的blocks可以增加到5120bytes，默认是512bytes，这样可以使备份速度加快&#xA;-d ：自动建立目录，这样还原时才不会出现找不到路径的问题&#xA;-u ：更新，用较新的文件覆盖旧的文件&#xA;cpio常与find 配合使用&#xA;&#xA;###############################################################################&#xA;&#xA;二、文件目录结构树：&#xA;.&#xA;|-- bin&#xA;| |-- insmod 加载内核驱动&#xA;| |-- lvm&#xA;| |-- modprobe -&amp;gt; /sbin/nash 加载内核驱动&#xA;| `-- nash 用于处理根目录下的/init脚本&#xA;|-- dev 设备文件&#xA;| |-- console&#xA;| |-- mapper&#xA;| |-- null&#xA;| |-- ptmx&#xA;| |-- ram -&amp;gt; ram1&#xA;| |-- ram0&#xA;| |-- ram1&#xA;| |-- rtc&#xA;| |-- systty&#xA;| |-- tty&#xA;| |-- tty0&#xA;| |-- tty1&#xA;| |-- tty10&#xA;| |-- tty11&#xA;| |-- tty12&#xA;| |-- tty2&#xA;| |-- tty3&#xA;| |-- tty4&#xA;| |-- tty5&#xA;| |-- tty6&#xA;| |-- tty7&#xA;| |-- tty8&#xA;| |-- tty9&#xA;| |-- ttyS0&#xA;| |-- ttyS1&#xA;| |-- ttyS2&#xA;| |-- ttyS3&#xA;| `-- zero&#xA;|-- etc&#xA;| `-- lvm&#xA;| `-- lvm.conf&#xA;|-- init nash的启动脚本文件,整个系统初始化入口&#xA;|-- initrd-2.6.18-8.el5xen.img gunzip解压后的cpio文件&#xA;|-- lib&#xA;| |-- cciss.ko&#xA;| |-- dm-mirror.ko&#xA;| |-- dm-mod.ko&#xA;| |-- dm-snapshot.ko&#xA;| |-- dm-zero.ko&#xA;| |-- ehci-hcd.ko&#xA;| |-- ext3.ko&#xA;| |-- jbd.ko&#xA;| |-- ohci-hcd.ko&#xA;| |-- scsi_mod.ko&#xA;| |-- sd_mod.ko&#xA;| `-- uhci-hcd.ko&#xA;|-- proc&#xA;|-- sbin -&amp;gt; bin&#xA;|-- sys&#xA;`-- sysroot&#xA;三、init文件内容：&#xA;&#xA;#!/bin/nash&#xA;#挂接进程文件系统&#xA;mount -t proc /proc /proc&#xA;# 不输出nash调试信息，由/proc/cmdline决定,cat /proc/cmdline我的启动参数 &#xA;# 输出ro root=/dev/hda3 vga=791 splash=silent，如果该命令行中带了quiet参 &#xA;# 数，则不输出nash提示信息。 &#xA;setquiet&#xA;#这里的提示位置好像不对，应该放在前面挂接之前&#xA;echo Mounting proc filesystem&#xA;#挂接sys文件系统 &#xA;echo Mounting sysfs filesystem&#xA;mount -t sysfs /sys /sys&#xA;&#xA;#创建/dev临时目录 &#xA;echo Creating /dev&#xA;# &#xA;mount -o mode=0755 -t tmpfs /dev /dev&#xA;#新建伪终端目录&#xA;mkdir /dev/pts&#xA;mount -t devpts -o gid=5,mode=620 /dev/pts /dev/pts&#xA;# 新建共享内存目录&#xA;mkdir /dev/shm&#xA;mkdir /dev/mapper&#xA;# 创建设备文件（这些设备文件在切换到硬盘后，由/etc/rc.sysinit中start_udev &#xA;# 重新创建）&#xA;echo Creating initial device nodes&#xA;mknod /dev/null c 1 3&#xA;mknod /dev/zero c 1 5&#xA;mknod /dev/systty c 4 0&#xA;mknod /dev/tty c 5 0&#xA;mknod /dev/console c 5 1&#xA;mknod /dev/ptmx c 5 2&#xA;mknod /dev/rtc c 10 135&#xA;mknod /dev/tty0 c 4 0&#xA;mknod /dev/tty1 c 4 1&#xA;mknod /dev/tty2 c 4 2&#xA;mknod /dev/tty3 c 4 3&#xA;mknod /dev/tty4 c 4 4&#xA;mknod /dev/tty5 c 4 5&#xA;mknod /dev/tty6 c 4 6&#xA;mknod /dev/tty7 c 4 7&#xA;mknod /dev/tty8 c 4 8&#xA;mknod /dev/tty9 c 4 9&#xA;mknod /dev/tty10 c 4 10&#xA;mknod /dev/tty11 c 4 11&#xA;mknod /dev/tty12 c 4 12&#xA;mknod /dev/ttyS0 c 4 64&#xA;mknod /dev/ttyS1 c 4 65&#xA;mknod /dev/ttyS2 c 4 66&#xA;mknod /dev/ttyS3 c 4 67&#xA;&#xA;#设置热插拔&#xA;echo Setting up hotplug.&#xA;hotplug&#xA;&#xA;#创建块设备&#xA;echo Creating block device nodes.&#xA;mkblkdevs&#xA;&#xA;#Load 模块&#xA;echo &amp;quot;Loading uhci-hcd.ko module&amp;quot;&#xA;insmod /lib/uhci-hcd.ko &#xA;echo &amp;quot;Loading ohci-hcd.ko module&amp;quot;&#xA;insmod /lib/ohci-hcd.ko &#xA;echo &amp;quot;Loading ehci-hcd.ko module&amp;quot;&#xA;insmod /lib/ehci-hcd.ko &#xA;mount -t usbfs /proc/bus/usb /proc/bus/usb&#xA;echo &amp;quot;Loading jbd.ko module&amp;quot;&#xA;insmod /lib/jbd.ko &#xA;echo &amp;quot;Loading ext3.ko module&amp;quot;&#xA;insmod /lib/ext3.ko &#xA;echo &amp;quot;Loading scsi_mod.ko module&amp;quot;&#xA;insmod /lib/scsi_mod.ko &#xA;echo &amp;quot;Loading sd_mod.ko module&amp;quot;&#xA;insmod /lib/sd_mod.ko &#xA;echo &amp;quot;Loading cciss.ko module&amp;quot;&#xA;insmod /lib/cciss.ko &#xA;echo &amp;quot;Loading dm-mod.ko module&amp;quot;&#xA;insmod /lib/dm-mod.ko &#xA;echo &amp;quot;Loading dm-mirror.ko module&amp;quot;&#xA;insmod /lib/dm-mirror.ko &#xA;echo &amp;quot;Loading dm-zero.ko module&amp;quot;&#xA;insmod /lib/dm-zero.ko &#xA;echo &amp;quot;Loading dm-snapshot.ko module&amp;quot;&#xA;insmod /lib/dm-snapshot.ko &#xA;echo Waiting for driver initialization.&#xA;stabilized --hash --interval 250 /proc/scsi/scsi&#xA;#Creates a device inode for the device&#xA;# mapper control inode #as /dev/mapper/control.&#xA;#If it already exists with the correct major/minor, &#xA;#it will not be recreated.&#xA;echo Making device-mapper control node&#xA;mkdmnod&#xA;mkblkdevs&#xA;&#xA;#检测逻辑卷&#xA;echo Scanning logical volumes&#xA;lvm vgscan --ignorelockingfailure&#xA;#激活逻辑卷&#xA;echo Activating logical volumes&#xA;lvm vgchange -ay --ignorelockingfailure VolGroup00&#xA;resume /dev/VolGroup00/LogVol01&#xA;&#xA;#创建根设备&#xA;echo Creating root device.&#xA;mkrootdev -t ext3 -o defaults,ro /dev/VolGroup00/LogVol00&#xA;#挂接根设备&#xA;echo Mounting root filesystem.&#xA;mount /sysroot&#xA;echo Setting up other filesystems.&#xA;setuproot&#xA;&#xA;#切换根目录到设备/dev/root目录，&#xA;#运行完该命令根目录&amp;quot;/&amp;quot;-&amp;gt;&amp;quot;/dev/VolGroup00/LogVol00&amp;quot; &#xA;echo Switching to new root and running init.&#xA;switchroot&#xA;&#xA;###########################################################################&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>一个简单的播放器</title>
      <link>http://www.nljb.net/default/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%92%AD%E6%94%BE%E5%99%A8/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 简单了解，写了一个播放器&#xA;#include&amp;lt;iostream&amp;gt;&#xA;extern &amp;quot;C&amp;quot; {&#xA;#include &amp;lt;libavcodec/avcodec.h&amp;gt;&#xA;#include &amp;lt;libavformat/avformat.h&amp;gt;&#xA;#include &amp;lt;libswscale/swscale.h&amp;gt;&#xA;#include &amp;lt;SDL/SDL.h&amp;gt;&#xA;#include &amp;lt;SDL/SDL_image.h&amp;gt;&#xA;#include &amp;lt;SDL/SDL_thread.h&amp;gt;&#xA;}&#xA;&#xA;using namespace std;&#xA;&#xA;int main(int argc, char* argv[]) {&#xA;&#xA;    // 注册了所有的文件格式和编解码的库，它们将被自动的使用在被打开的合适格式的文件上&#xA;    av_register_all();&#xA;&#xA;    // AVFormatContext是FFMpeg格式转换过程中实现输入和输出功能、保存相关数据的主要结构。&#xA;    // 每一个输入和输出文件，都在如下定义的指针数组全局变量中有对应的实体。&#xA;    AVFormatContext *pFormatCtx;&#xA;&#xA;    // 其中负责申请一个AVFormatContext结构的内存,并进行简单初始化&#xA;    // avformat_free_context()可以用来释放该结构里的所有东西以及该结构本身&#xA;    // 也是就说使用 avformat_alloc_context()分配的结构,需要使用avformat_free_context()来释放&#xA;    // 有些版本中函数名可能为: av_alloc_format_context();&#xA;    pFormatCtx = avformat_alloc_context();&#xA;&#xA;    // 视频文件&#xA;    char filepath[] = &amp;quot;kaoya.mp4&amp;quot;;&#xA;&#xA;    // avformat_open_input 解析文件头&#xA;    // Open an input stream and read the header&#xA;    if (avformat_open_input(&amp;amp;pFormatCtx, filepath, NULL, NULL) != 0) {&#xA;    printf(&amp;quot;Can&#39;t open the file\n&amp;quot;);&#xA;    return -1;&#xA;    }&#xA;&#xA;    // 调用 avformat_find_stream_info 解析文件中的流并得到流中一些必须的信息&#xA;    // Retrieve stream information&#xA;    if (avformat_find_stream_info(pFormatCtx, NULL) &amp;lt; 0) {&#xA;    printf(&amp;quot;Couldn&#39;t find stream information.\n&amp;quot;);&#xA;    return -1;&#xA;    }&#xA;&#xA;    // output file information&#xA;    cout &amp;lt;&amp;lt; &amp;quot;文件信息----------------------------------&amp;quot; &amp;lt;&amp;lt; endl;&#xA;    av_dump_format(pFormatCtx, 0, filepath, 0);&#xA;    cout &amp;lt;&amp;lt; &amp;quot;--------------------------------------------&amp;quot; &amp;lt;&amp;lt; endl;&#xA;&#xA;    // --------------------------------------------------------- //&#xA;&#xA;    //Find the first video stream&#xA;    int i, videoIndex = -1;&#xA;&#xA;    // 视音频流的个数&#xA;    for (i = 0; i &amp;lt; pFormatCtx-&amp;gt;nb_streams; i++) {&#xA;    if (pFormatCtx-&amp;gt;streams[i]-&amp;gt;codec-&amp;gt;codec_type == AVMEDIA_TYPE_VIDEO) {&#xA;        videoIndex = i;&#xA;        break;&#xA;    }&#xA;    }&#xA;&#xA;    // 不存在则返回&#xA;    if (videoIndex == -1)&#xA;    return -1;&#xA;&#xA;    // --------------------------------------------------------- //&#xA;&#xA;    // 这是一个描述编解码器上下文的数据结构，包含了众多编解码器需要的参数信息&#xA;    AVCodecContext *pCodecCtx;&#xA;&#xA;    // AVCodec是存储编解码器信息的结构体&#xA;    AVCodec *pCodec;&#xA;&#xA;    // Get a pointer to the codec context for the video stream&#xA;    // 流中关于编解码器的信息就是被我们叫做&amp;quot;codec context&amp;quot;（编解码器上下文）&#xA;    // 的东西。这里面包含了流中所使用的关于编解码器的所有信息&#xA;    pCodecCtx = pFormatCtx-&amp;gt;streams[videoIndex]-&amp;gt;codec;&#xA;&#xA;    //Find the decoder for the video stream&#xA;    pCodec = avcodec_find_decoder(pCodecCtx-&amp;gt;codec_id);&#xA;    if (pCodec == NULL) {&#xA;    printf(&amp;quot;Unsupported codec!\n&amp;quot;);&#xA;    return -1;&#xA;    }&#xA;&#xA;    //Open codec&#xA;    if (avcodec_open2(pCodecCtx, pCodec, NULL) &amp;lt; 0) {&#xA;    printf(&amp;quot;Could not open codec.\n&amp;quot;);&#xA;    return -1;&#xA;    }&#xA;&#xA;    //allocate video frame and set its fileds to default value&#xA;    AVFrame *pFrame, *pFrameYUV;&#xA;    pFrame = av_frame_alloc();&#xA;    pFrameYUV = av_frame_alloc();&#xA;&#xA;    //即使我们申请了一帧的内存，当转换的时候，我们仍然需要一个地方来放置原始&#xA;    //的数据。我们使用avpicture_get_size 来获得我们需要的大小， 然后手工申请&#xA;    //内存空间：&#xA;    uint8_t *out_buffer;&#xA;    int numBytes;&#xA;    numBytes = avpicture_get_size(PIX_FMT_YUV420P, pCodecCtx-&amp;gt;width,&#xA;        pCodecCtx-&amp;gt;height);&#xA;&#xA;    //av_malloc 是ffmpeg 的malloc，用来实现一个简单的malloc 的包装，这样来保&#xA;    //证内存地址是对齐的（4 字节对齐或者2 字节对齐）。它并不能保 护你不被内&#xA;    //存泄漏，重复释放或者其它malloc 的问题所困扰。&#xA;    out_buffer = (uint8_t *) av_malloc(numBytes * sizeof(uint8_t));&#xA;&#xA;    //Assign appropriate parts of buffer to image planes in pFrameYUV&#xA;    //Note that pFrameYUV is an AVFrame, but AVFrame is a superset of AVPicture&#xA;    avpicture_fill((AVPicture*) pFrameYUV, out_buffer, PIX_FMT_YUV420P,&#xA;        pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height);&#xA;&#xA;    //----------------SDL--------------------------------------//&#xA;&#xA;    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {&#xA;    printf(&amp;quot;Could not initialize SDL -%s\n&amp;quot;, SDL_GetError());&#xA;    exit(1);&#xA;    }&#xA;&#xA;    SDL_Surface *screen;&#xA;    screen = SDL_SetVideoMode(pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, 24, 0);&#xA;    if (!screen) {&#xA;    fprintf(stderr, &amp;quot;SDL: could not set video mode - exiting\n&amp;quot;);&#xA;    exit(1);&#xA;    }&#xA;&#xA;    SDL_Overlay *bmp;&#xA;    // Allocate a place to put our YUV image on that screen&#xA;    bmp = SDL_CreateYUVOverlay(pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height,&#xA;    SDL_YV12_OVERLAY, screen);&#xA;&#xA;    SDL_Rect rect;&#xA;    rect.x = 0, rect.y = 0;&#xA;    rect.w = pCodecCtx-&amp;gt;width;&#xA;    rect.h = pCodecCtx-&amp;gt;height;&#xA;&#xA;    //*************************************************************//&#xA;&#xA;    //通过读取包来读取整个视频流，然后把它解码成帧，最后转换格式并且保存&#xA;    int frameFinished;&#xA;&#xA;    AVPacket packet;&#xA;    av_new_packet(&amp;amp;packet, numBytes);&#xA;&#xA;    int ret;&#xA;    // Convert the image into YUV format that SDL uses&#xA;    static struct SwsContext *img_convert_ctx;&#xA;    img_convert_ctx = sws_getContext(pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height,&#xA;        pCodecCtx-&amp;gt;pix_fmt, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height,&#xA;        PIX_FMT_YUV420P,&#xA;        SWS_BICUBIC, NULL, NULL, NULL);&#xA;&#xA;    // Read the next frame of a stream&#xA;    while (av_read_frame(pFormatCtx, &amp;amp;packet) &amp;gt;= 0) {&#xA;&#xA;    // Is this a packet from the video stream?&#xA;    if (packet.stream_index == videoIndex) {&#xA;&#xA;        // decode video frame of size packet.size from packet.data into picture&#xA;        ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;amp;frameFinished,&#xA;            &amp;amp;packet);&#xA;&#xA;        // Did we get a video frame?&#xA;        if (ret &amp;gt;= 0) {&#xA;&#xA;        // Convert the image from its native format to YUV&#xA;        if (frameFinished) {&#xA;&#xA;            SDL_LockYUVOverlay(bmp);&#xA;&#xA;            AVPicture pict;&#xA;            pict.data[0] = bmp-&amp;gt;pixels[0];&#xA;            pict.data[1] = bmp-&amp;gt;pixels[2];&#xA;            pict.data[2] = bmp-&amp;gt;pixels[1];&#xA;&#xA;            pict.linesize[0] = bmp-&amp;gt;pitches[0];&#xA;            pict.linesize[1] = bmp-&amp;gt;pitches[2];&#xA;            pict.linesize[2] = bmp-&amp;gt;pitches[1];&#xA;&#xA;            sws_scale(img_convert_ctx,&#xA;                (const uint8_t* const *) pFrame-&amp;gt;data,&#xA;                pFrame-&amp;gt;linesize, 0, pCodecCtx-&amp;gt;height, pict.data,&#xA;                pict.linesize);&#xA;&#xA;            SDL_UnlockYUVOverlay(bmp);&#xA;&#xA;            SDL_DisplayYUVOverlay(bmp, &amp;amp;rect);&#xA;&#xA;        }&#xA;        }&#xA;    }&#xA;&#xA;    av_free_packet(&amp;amp;packet);&#xA;&#xA;    SDL_Event event;&#xA;    SDL_PollEvent(&amp;amp;event);&#xA;    switch (event.type) {&#xA;    case SDL_QUIT:&#xA;        SDL_Quit();&#xA;        exit(0);&#xA;        break;&#xA;    default:&#xA;        break;&#xA;    }&#xA;    }&#xA;&#xA;    av_frame_free(&amp;amp;pFrame);&#xA;    av_frame_free(&amp;amp;pFrameYUV);&#xA;    avcodec_close(pCodecCtx);&#xA;    avformat_close_input(&amp;amp;pFormatCtx);&#xA;&#xA;    return 0;&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>x-go-binding</title>
      <link>http://www.nljb.net/default/x-go-binding/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;code.google.com/p/x-go-binding/xgb&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    conn, err := xgb.Dial(&amp;quot;:0&amp;quot;)&#xA;    if err != nil {&#xA;    panic(err)&#xA;    }&#xA;&#xA;    // X Windows Width Height&#xA;    fmt.Println(conn.DefaultScreen().WidthInPixels)&#xA;    fmt.Println(conn.DefaultScreen().HeightInPixels)&#xA;&#xA;    // Depth 8 16 24&#xA;    fmt.Println(conn.DefaultScreen().RootDepth)&#xA;&#xA;    fmt.Println(conn.DefaultScreen().Root)&#xA;    fmt.Println(conn.DefaultScreen().DefaultColormap)&#xA;    fmt.Println(conn.DefaultScreen().WhitePixel)&#xA;    fmt.Println(conn.DefaultScreen().BlackPixel)&#xA;    fmt.Println(conn.DefaultScreen().CurrentInputMasks)&#xA;    fmt.Println(conn.DefaultScreen().WidthInMillimeters)&#xA;    fmt.Println(conn.DefaultScreen().HeightInMillimeters)&#xA;    fmt.Println(conn.DefaultScreen().MinInstalledMaps)&#xA;    fmt.Println(conn.DefaultScreen().MaxInstalledMaps)&#xA;    fmt.Println(conn.DefaultScreen().RootVisual)&#xA;    fmt.Println(conn.DefaultScreen().BackingStores)&#xA;    fmt.Println(conn.DefaultScreen().SaveUnders)&#xA;    fmt.Println(conn.DefaultScreen().AllowedDepthsLen)&#xA;    fmt.Println(conn.DefaultScreen().AllowedDepths)&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>socket.cpp-监听解码</title>
      <link>http://www.nljb.net/default/socket.cpp-%E7%9B%91%E5%90%AC%E8%A7%A3%E7%A0%81/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;sys/socket.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;netinet/in.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;#include &amp;lt;json/json.h&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;// 常量&#xA;#define SERVPORT 4444&#xA;#define BACKLOG 10&#xA;#define MAXSIZE 1024&#xA;&#xA;int main() {&#xA;&#xA;    // 声明&#xA;    int sockfd, client_fd;&#xA;    struct sockaddr_in my_addr;&#xA;    struct sockaddr_in remote_addr;&#xA;&#xA;    // 创建&#xA;    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {&#xA;    perror(&amp;quot;socket create failed!&amp;quot;);&#xA;    exit(1);&#xA;    }&#xA;&#xA;    // 绑定端口地址&#xA;    my_addr.sin_family = AF_INET;&#xA;    my_addr.sin_port = htons(SERVPORT);&#xA;    my_addr.sin_addr.s_addr = INADDR_ANY;&#xA;    bzero(&amp;amp;(my_addr.sin_zero), 8);&#xA;&#xA;    // 捆绑&#xA;    if (bind(sockfd, (struct sockaddr*) &amp;amp;my_addr, sizeof(struct sockaddr))&#xA;        == -1) {&#xA;    perror(&amp;quot;bind error!&amp;quot;);&#xA;    exit(1);&#xA;    }&#xA;&#xA;    // 监听端口&#xA;    if (listen(sockfd, BACKLOG) == -1) {&#xA;    perror(&amp;quot;listen error&amp;quot;);&#xA;    exit(1);&#xA;    }&#xA;&#xA;    // 接受连接&#xA;    int sin_size = sizeof(struct sockaddr_in);&#xA;    if ((client_fd = accept(sockfd, (struct sockaddr *) &amp;amp;remote_addr,&#xA;        (socklen_t *) &amp;amp;sin_size)) == -1) {&#xA;    perror(&amp;quot;accept error!&amp;quot;);&#xA;    exit(1);&#xA;    }&#xA;&#xA;    // 变量&#xA;    string json_str;&#xA;    char buf[MAXSIZE];&#xA;&#xA;    // 处理&#xA;    while (1) {&#xA;&#xA;    // 归零&#xA;    bzero(buf, MAXSIZE);&#xA;&#xA;    // 接受client发送的请示信息&#xA;    if (recv(client_fd, buf, MAXSIZE, 0) == 0)&#xA;        continue;&#xA;&#xA;    buf[strlen(buf) - 1] = &#39; &#39;;&#xA;    buf[strlen(buf) - 2] = &#39;\0&#39;;&#xA;&#xA;    if (strcmp(buf, &amp;quot;QUIT&amp;quot;) == 0) {&#xA;        printf(&amp;quot;%s\n&amp;quot;, &amp;quot;bye!&amp;quot;);&#xA;        close(sockfd);&#xA;        exit(0);&#xA;    }&#xA;&#xA;    // (Char[]-&amp;gt;String)&#xA;    json_str.insert(0, buf);&#xA;&#xA;    // 解析(Json-&amp;gt;Value)&#xA;    Json::Reader reader;&#xA;    Json::Value root;&#xA;    if (!reader.parse(json_str, root, false)) {&#xA;        cout &amp;lt;&amp;lt; &amp;quot;parse error&amp;quot; &amp;lt;&amp;lt; endl;&#xA;        exit(1);&#xA;    }&#xA;&#xA;    // 获取&#xA;    cout &amp;lt;&amp;lt; &amp;quot;Name:&amp;quot; &amp;lt;&amp;lt; root[&amp;quot;name&amp;quot;].asString() &amp;lt;&amp;lt; endl;&#xA;&#xA;    // 写入(Value-&amp;gt;Json)&#xA;    Json::FastWriter writer;&#xA;    json_str = writer.write(root);&#xA;    cout &amp;lt;&amp;lt; json_str &amp;lt;&amp;lt; endl;&#xA;&#xA;    }&#xA;&#xA;    // 返回&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>adb常用命令</title>
      <link>http://www.nljb.net/default/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;adb devices //列出所有的连接设备&#xA;adb connect &amp;lt;host&amp;gt;[:&amp;lt;port&amp;gt;] //通过tcp/ip连接，5555是默认端口&#xA;设备命令：&#xA;adb push &amp;lt;local&amp;gt; &amp;lt;remote&amp;gt;  //拷贝文件/目录到设备&#xA;adb pull &amp;lt;remote&amp;gt; [&amp;lt;local&amp;gt;] //从设备拷贝文件/目录&#xA;adb sync [&amp;lt;directory&amp;gt;] //只有发生改变时从主机拷贝到设备&#xA;adb shell  //运行远端shell交互&#xA;adb shell &amp;lt;command&amp;gt; //运行远端shell 命令&#xA;adb emu &amp;lt;command&amp;gt; //运行仿真控制台命令&#xA;adb logcat [&amp;lt;filter-spec&amp;gt;] //浏览设备日志&#xA;adb forward &amp;lt;local&amp;gt; &amp;lt;remote&amp;gt; //转发套接字连接&#xA;adb install [-l] [-r] [-s] &amp;lt;file&amp;gt; //拷贝文件包到设备并安装&#xA;adb uninstall [-k] &amp;lt;package&amp;gt; //卸载程序包，-k意味着保留数据和缓存&#xA;adb bugreport //返回所有的bugreport信息&#xA;adb help&#xA;adb version&#xA;脚本：&#xA;adb wait-for-device //阻塞直到设备上线&#xA;adb start-server&#xA;adb kill-server&#xA;adb get-state //列印offline|bootloader|device信息&#xA;adb get-serialno&#xA;adb status-window //连续列印设备状态&#xA;adb remount //重装载/system分区&#xA;adb reboot [bootloader|recomry]&#xA;adb reboot-bootloader&#xA;adb root&#xA;adb usb&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>SDL-在屏幕上输出一张图片</title>
      <link>http://www.nljb.net/default/SDL-%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E8%BE%93%E5%87%BA%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;这篇教程讲述SDL风格的Hello World。&#xA;假设你已经安装好了SDL库，下面我们制作一个简陋的图片（640*480像素的图片，并命名为hello.bmp），应用SDL把它加载并显示到屏幕上。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//文件名：hello.c，以下内容可以全部复制到源文件中。&#xA;//包含SDL函数和数据类型&#xA;#include &amp;quot;SDL/SDL.h&amp;quot;&#xA;&#xA;/*&#xA;在源文件的开头，包含SDL的头文件，这样，我们就可以使用SDL的函数和数据类型。&#xA;如果有人（比如说使用Visual Studio的）打算这样包含SDL的头文件：#include &amp;quot;SDL.h&amp;quot;。&#xA;如果编译器向你报错说找不到“SDL/SDL.h”的头文件，那么是因为你包含的头文件路径错了，或者说，你没有把SDL.h放到正确的路径下。&#xA;    */&#xA;&#xA;int main( int argc, char* args[] )&#xA;{&#xA;    //The images&#xA;    SDL_Surface* hello = NULL;&#xA;    SDL_Surface* screen = NULL;&#xA;&#xA;/*&#xA;在main()函数的前部，声明两个SDL_Surface的指针。一个SDL_Surface就是一个图片，在这个程序中，我们打算处理两个图片。&#xA;画面指针 “hello”是我们准备加载和显示的图片，“screen”是屏幕上显示出来的范围。&#xA;不论你打算用指针去做什么，始终要记得初始化指针。&#xA;当然，使用SDL的时候，你必须像上面那样声明main函数，不能用void main()或者其他类似的声明。&#xA;    */&#xA;&#xA;    //启动SDL&#xA;    SDL_Init( SDL_INIT_EVERYTHING );&#xA;&#xA;    //建立屏幕&#xA;    screen = SDL_SetVideoMode( 640, 480, 32, SDL_SWSURFACE );&#xA;&#xA;    //加载图片&#xA;    hello = SDL_LoadBMP( &amp;quot;hello.bmp&amp;quot; );&#xA;&#xA;/*&#xA;mian()函数里调用的第一个函数是SDL_Init()，目的是调用SDL_Init()来初始化所有的SDL子系统，这样我们才能开始使用SDL的图形函数。&#xA;下一个函数是SDL_SetVideoMode()，调用它来设置一个640像素宽，480像素高的窗口，每个像素32位。&#xA;最后一个参数(SDL_SWSURFACE)用来在软件存储中建立一个画面。&#xA;当执行完SDL_SetVideoMode()以后，会返回一个我们能够使用的指针，指向窗口画面， 窗口建立以后，我们调用SDL_LoadBMP()来载入图片。&#xA;SDL_LoadBMP()函数接受一个位图文件的路径作为参数，并返回一个指针，该指针指向已经载入的画面。当载入图片发生错误时，该函数返回一个空指针&#xA;*/&#xA;&#xA;    //把图片放置到屏幕上&#xA;    SDL_BlitSurface( hello, NULL, screen, NULL );&#xA;&#xA;    //刷新屏幕&#xA;    SDL_Flip( screen );&#xA;&#xA;    //暂停，等待&#xA;    SDL_Delay( 2000 );&#xA;&#xA;/*&#xA;现在，我们已经建立了一个窗口，并加载了图片，我们准备把加载的图片放置到屏幕上面。这个是通过SDL_BlitSurface()函数实现的。&#xA;SDL_BlitSurface()的第一个参数是源画面的指针（源画面位置），第三个参数是目的画面的指针（目的画面的位置）。&#xA;SDL_BlitSurface()函数把源画面粘贴到目的画面上。这样，就能够把加载的图片放置到屏幕上显示出来。稍后的教程里会介绍其他参数的作用。&#xA;现在我们的图片已经放置到屏幕上了，我们需要用SDL_Flip()函数来刷新屏幕，这样我们才能看到它。&#xA;如果你没有调用SDL_Flip()函数，那你只能看到一个还没有刷新的黑黑的屏幕。&#xA;到这里，图片已经放置到屏幕上，并显示出来了，我们必须让显示出来的窗口能够停留，不会一闪而过，消失不见。&#xA;调用SDL_Delay()函数，让窗口保持稳定。这里，我们让窗口延时2000毫秒（2秒）。&#xA;在接下来的教程的第四课里，你会学到更好的办法，来让窗口停留在一个地方。&#xA;*/&#xA;&#xA;    //释放掉内存中加载的图片&#xA;    SDL_FreeSurface( hello );&#xA;&#xA;    //退出 SDL&#xA;    SDL_Quit();&#xA;&#xA;    return 0;&#xA;}&#xA;&#xA;/*&#xA;接下来，我们在程序里将不再使用加载的图片，我们需要把它从内存中释放掉。&#xA;你不能够简单的使用delete释放内存，而是需要调用SDL_FreeSurface()函数把它从内存中释放掉。&#xA;在程序结束时，我们调用SDL_Quit()来关闭SDL程序。你也许或疑惑，为什么我们从来没有释放屏幕画面的内存？别担心，SDL_Quit()会为你释放掉它。&#xA;祝贺你！成功的运行你第一个图形程序。&#xA;*/&#xA;&#xA;/*&#xA;使用wxDev-C++编译的连接器命令为：-lmingw32 -lSDLmain  -lSDL&#xA;测试编译运行OK！在解释的文字两端加了注视符号，所以这些内容可以全部复制到源程序里。&#xA;*/&#xA;&#xA;SDL程序编译出错的解决办法&#xA;&#xA;如果你的编译器向你报错没有找到&#39;SDL/SDL.h&#39;，意味着你忘记了设置头文件。你的编译器或者是IDE应该能都找到SDL的头文件，所以要确认SDL的头文件正确的配置到include文件夹内。如果你使用Visual Studio而编译器报错：&#39;SDL/SDL.h&#39;: No such file or directory，查看源文件顶端的代码，确认是使用的#include &amp;quot;SDL.h&amp;quot;.&#xA;&#xA;如果你的程序能够编译，但是连接器会报错找不到库文件，那么确认你的编译器或者IDE能够找到SDL的库文件。如果你的编译器报错没有定义引用一大堆SDL的函数，请确认你在连接器里连接了SDL。&#xA;&#xA;    如果你的连接器报错是关于指针入口的，那么确认mian函数的声明方式是否正确，在你的源码里，只能有一个main函数。&#xA;&#xA;    如果程序编译、链接、生成都正常，但是当你运行的时候报错，没有找到SDL.dll，确认一下是否将SDL.dll放置到了和编译执行相同的目录下。使用Visual Studio，需要把dll文件放置到与vcproj文件相同的目录下。如果使用Windows系统，可以把dll文件放到system32目录下。&#xA;&#xA;如果你的程序可以运行，但是没有显示图片，或者窗口一闪而过，你可以看到stderr.txt文件的内容为：&#xA;Fatal signal: Segmentation Fault (SDL Parachute Deployed)&#xA;&#xA;这是因为程序试图访问不允许访问的内存。可能是当调用SDL_BlitSurface()时，试图访问NULL。这意味着你需要确认位图文件和程序在同一个目录内。使用Visual Studio需要把位图文件和vcproj文件放在同一个目录内。&#xA;&#xA;也有可能在你使用Visual Studio时显示这样的错误：&amp;quot;The application failed to start because the application configuration is incorrect. Reinstalling the application may fix this problem.&amp;quot;（程序无法启动，重新安装来解决此问题）&#xA;&#xA;这是因为没有安装升级服务包。不要忘记采用最新版本的编译器或者IDE时，安装编译器或IDE的服务升级包，否则Visual Studio编译的程序不会运行。一些Linux的用户运行后可能会显示黑屏，尝试在命令行运行一下程序。&#xA;&#xA;如果你必须建立一个工程来编译SDL程序，记得你需要给你建立的每一个SDL程序建立一个工程。或者，更进一步，你可以重新使用你第一次建立的工程。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>PXE引导纯内存OpenSUSE方案</title>
      <link>http://www.nljb.net/default/PXE%E5%BC%95%E5%AF%BC%E7%BA%AF%E5%86%85%E5%AD%98OpenSUSE%E6%96%B9%E6%A1%88/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// git@github.com:nulijiabei/boot.git&#xA;&#xA;// 注：image为根目录打包镜像,不要超过2G,需要LOOP驱动&#xA;&#xA;echo &amp;quot;#################################&amp;quot;&#xA;&#xA;root=/dev/loop0&#xA;rootdev=/dev/loop0&#xA;&#xA;echo &amp;quot; &amp;quot;&#xA;echo &amp;quot;NEW ROOT IS root=&amp;quot;$root&amp;quot;&amp;quot;&#xA;echo &amp;quot;NEW ROOTDEV IS rootdev=&amp;quot;$rootdev&amp;quot;&amp;quot;&#xA;&#xA;echo &amp;quot;depmod&amp;quot;&#xA;/sbin/depmod -a&#xA;&#xA;echo &amp;quot;modprobe&amp;quot;&#xA;/sbin/modprobe loop&#xA;&#xA;echo &amp;quot;ls&amp;quot;&#xA;ls -l /dev/loop0&#xA;&#xA;echo &amp;quot;mount&amp;quot;&#xA;/bin/mount /dev/sda1 /disk&#xA;sleep 5&#xA;&#xA;echo &amp;quot;CP&amp;quot;&#xA;/bin/cp -av /disk/image /image &amp;amp;&amp;amp; ls -l /image&#xA;sleep 5&#xA;&#xA;echo &amp;quot;umount&amp;quot;&#xA;/bin/umount /disk&#xA;sleep 5&#xA;&#xA;echo &amp;quot;losetup&amp;quot;&#xA;/sbin/losetup /dev/loop0 /image&#xA;sleep 5&#xA;&#xA;echo &amp;quot;mount&amp;quot;&#xA;/bin/mount /dev/loop0 /root&#xA;sleep 5&#xA;&#xA;echo &amp;quot;ls&amp;quot;&#xA;ls -l /root&#xA;&#xA;echo &amp;quot;#################################&amp;quot;&#xA;&#xA;&#xA;// 配置项&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;保证工作目录(777)权限&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;安装 vsftpd&#xA;安装 tftp&#xA;安装 dhcp&#xA;安装 dhcp-server&#xA;安装 yast2-tftp-server&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;在 /etc/vsftpd.conf 增加&#xA;&#xA;write_enable=NO&#xA;dirmessage_enable=YES&#xA;nopriv_user=ftpsecure&#xA;local_enable=YES&#xA;anonymous_enable=YES&#xA;anon_world_readable_only=YES&#xA;syslog_enable=NO&#xA;connect_from_port_20=YES&#xA;ascii_upload_enable=YES&#xA;pam_service_name=vsftpd&#xA;ssl_enable=NO&#xA;pasv_min_port=30000&#xA;pasv_max_port=30100&#xA;listen=YES&#xA;anon_mkdir_write_enable=NO&#xA;anon_root=/srv/tftpboot&#xA;anon_upload_enable=NO&#xA;chroot_local_user=NO&#xA;ftpd_banner=Welcome message&#xA;idle_session_timeout=900&#xA;local_root=/srv/tftpboot&#xA;log_ftp_protocol=NO&#xA;max_clients=10&#xA;max_per_ip=3&#xA;pasv_enable=YES&#xA;ssl_sslv2=NO&#xA;ssl_sslv3=NO&#xA;ssl_tlsv1=YES&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;配置 /etc/dhcpd.conf&#xA;&#xA;# dhcpd.conf&#xA;option domain-name-servers 202.106.0.20;&#xA;&#xA;ddns-update-style interim;&#xA;&#xA;ignore client-updates;&#xA;&#xA;allow booting;&#xA;allow bootp;&#xA;filename &amp;quot;pxelinux.0&amp;quot;;&#xA;&#xA;default-lease-time 1800;&#xA;max-lease-time 7200;&#xA;&#xA;subnet 192.168.0.0 netmask 255.255.255.0 {&#xA;    option broadcast-address 192.168.0.255;&#xA;    server-name &amp;quot;install-server&amp;quot;;&#xA;    range 192.168.0.10 192.168.0.224;&#xA;    option routers 192.168.0.1;&#xA;}&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;配置 /etc/sysconfig/dhcpd&#xA;&#xA;DHCPD_INTERFACE=&amp;quot;eth0&amp;quot;&#xA;DHCPD6_INTERFACE=&amp;quot;eth0&amp;quot;&#xA;DHCPD_IFUP_RESTART=&amp;quot;&amp;quot;&#xA;DHCPD6_IFUP_RESTART=&amp;quot;&amp;quot;&#xA;DHCPD_RUN_CHROOTED=&amp;quot;yes&amp;quot;&#xA;DHCPD6_RUN_CHROOTED=&amp;quot;yes&amp;quot;&#xA;DHCPD_CONF_INCLUDE_FILES=&amp;quot;&amp;quot;&#xA;DHCPD6_CONF_INCLUDE_FILES=&amp;quot;&amp;quot;&#xA;DHCPD_RUN_AS=&amp;quot;dhcpd&amp;quot;&#xA;DHCPD6_RUN_AS=&amp;quot;dhcpd&amp;quot;&#xA;DHCPD_OTHER_ARGS=&amp;quot;&amp;quot;&#xA;DHCPD6_OTHER_ARGS=&amp;quot;&amp;quot;&#xA;DHCPD_BINARY=&amp;quot;&amp;quot;&#xA;DHCPD6_BINARY=&amp;quot;&amp;quot;&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;配置 /etc/xinetd.d/tftp&#xA;&#xA;service tftp&#xA;{&#xA;    socket_type     = dgram&#xA;    protocol        = udp&#xA;    wait            = yes&#xA;    flags           = IPv4&#xA;    user            = root&#xA;    server          = /usr/sbin/in.tftpd&#xA;    server_args     =  -s /srv/tftpboot&#xA;    disable         = no&#xA;}&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;配置 Yast 中 TFTP&#xA;&#xA;Enable&#xA;/srv/tftpboot&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;配置 /srv/tftpboot 及镜像&#xA;&#xA;目录:&#xA;pxelinux.0&#xA;pxelinux.cfg/default&#xA;danoo/vmlinuz&#xA;danoo/tinycore.gz&#xA;&#xA;文件 pxelinux.cfg/default&#xA;&#xA;default linux&#xA;prompt 1&#xA;timeout 60&#xA;&#xA;label linux&#xA;kernel danoo/vmlinuz&#xA;append ip=dhcp initrd=danoo/tinycore.gz&#xA;&#xA;&#xA;// --------------------------------------------- //&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-启动时显示详细启动过程</title>
      <link>http://www.nljb.net/default/Linux-%E5%90%AF%E5%8A%A8%E6%97%B6%E6%98%BE%E7%A4%BA%E8%AF%A6%E7%BB%86%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;*. 修改/boot/grub/menu.lst，修改kernel&amp;hellip;那行，将后面的quiet 去掉&lt;/p&gt;&#xA;&#xA;&lt;p&gt;*. 若想显示更信息，还可将splash=silent改为splash=verbose&lt;/p&gt;&#xA;&#xA;&lt;p&gt;*. 例如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;kernel /boot/vmlinuz-2.6.31.14-0.8-desktop root=/dev/disk/by-id/ata-WDC_WD10EALS-00Z8A0_WD-WCATR4066961-part2 resume=/dev/disk/by-id/ata-WDC_WD10EALS-00Z8A0_WD-WCATR4066961-part1 splash=silent quiet showopts vga=0x31a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;*. 改为：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;kernel /boot/vmlinuz-2.6.31.14-0.8-desktop root=/dev/disk/by-id/ata-WDC_WD10EALS-00Z8A0_WD-WCATR4066961-part2 resume=/dev/disk/by-id/ata-WDC_WD10EALS-00Z8A0_WD-WCATR4066961-part1 splash=verbose showopts vga=0x31a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-下设置屏幕分辨率方法</title>
      <link>http://www.nljb.net/default/Linux-%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Linxu下设置屏幕分辨率方法&#xA;设置分辨率方法&#xA;通常情况下在Linux下屏幕分辨的设置方法有两种：&#xA;一种是通过图形界面的方式进行设置，但是功能比较单一，不支持自定义设置。&#xA;另一种是通过命令的形式进行设置，正常情况下可以通过xrandr命令进行设置。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;xrandr 命令行可以很方便地切换双屏，常用方式如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;查询当前显示设备状态&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --same-as LVDS –auto&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打开外接显示器(最高分辨率)，与笔记本液晶屏幕显示同样内容（克隆）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --same-as LVDS --mode  1024x768&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打开外接显示器(分辨率为1024x768)，与笔记本液晶屏幕显示同样内容（克隆）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --right-of LVDS --auto&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打开外接显示器(最高分辨率)，设置为右侧扩展屏幕&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --off&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;关闭外接显示器&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --auto --output LVDS --off&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打开外接显示器，同时关闭笔记本液晶屏幕（只用外接显示器工作）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --off --output LVDS --auto&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;关闭外接显示器，同时打开笔记本液晶屏幕 (只用笔记本液晶屏)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;（最后两种情况请小心操作，不要误把两个屏幕都关掉了。。。。）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;分辨率强制设置方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当外接显示设备无法正常识别时，可以通过手动指定的方式进行设置，设置方法如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1、用cvt命令获取给定分辨率的xrandr所需参数。例如：获取1440x900如下所示。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#cvt 1440 900&#xA;结果如下：&#xA;# 1440x900 59.89 Hz (CVT 1.30MA) hsync: 55.93 kHz; pclk: 106.50 MHz&#xA;Modeline &amp;quot;1440x900_60.00&amp;quot; 106.50  1440 1528 1672 1904  900 903 909 934 -hsync +vsync&#xA;Modeline后面的值在下边要用。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2、执行xrandr命令查看显示设备对于命名信息。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#xrandr&#xA;得到显示器名称，如：VGA1、笔记本为LVDS1等，以此类推，不一定都一样。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3、用xrandr创建一个新的显示模式。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#xrandr --newmode &amp;quot;1440x900_60.00&amp;quot;  106.50  1440 15281672 1904  900 903 909 934 -hsync +vsync&#xA;参数就是cvt结果中Modeline后面的那一堆，根据自己的参数调整。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;4、查看新添加的显示模式。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#xrandr&#xA;就可以看到新加的那个设置。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;5、用xrandr添加一个新的显示模式。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#sudo xrandr --addmode VGA1 &amp;quot;1440x900_60.00&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;6、使用新添加的显示模式。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#xrandr --output VGA1 --mode 1440x900_60.00 --same-as LVDS1&#xA;打开外接显示器,分辨率设为1440x900，--same-as LVDS代表显示和LVDS1显示内容一样（即：镜面屏幕）。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意事项：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1. 在使用1440x900_60.00参数时，要写全，必须一致。&#xA;2. VGA1、LVDS1、HDMI-0等可以根据xrandr或者xrandr -q命令查询。&#xA;3. 通过xrandr命令配置的效果不能够在关机后保存，要保留效果，可以将相关的配置命令写在脚步中，在系统启动时执行。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一个简单的示例如见附录“一种保存xrandr配置方法”。附录：一种保存xrandr配置方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1、创建一个自启动脚本，添加如下代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;xrandr--newmode &amp;quot;1440x900_60.00&amp;quot;  106.50  1440 1528 16721904  900 903 909 934 -hsync +vsync;&#xA;xrandr--addmode VGA1 &amp;quot;1440x900_60.00&amp;quot;;&#xA;xrandr--output LVDS1 --mode 1366x768&#xA;xrandr--output VGA1 --mode 1440x900_60.00;&#xA;xrandr--output VGA1 --right-of LVDS1;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2、增加该脚本可执行权限，如命名为xrandr-config.sh。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#chmod a+x ./xrandr-config.sh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3、将该脚本设为开机启动，方法有两种：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   第一种方法：在/etc/rc.d/rc.local中追加入上述脚本执行命令，如：&#xA;1）打开rc.local文件。&#xA;    #vim/etc/rc.d/rc.local&#xA;2）在rc.local中添加如下内容。&#xA;    /root/xrandr-config.sh&#xA;第二种方法：可通过图形化的界面来设置，方法如下。&#xA;开始菜单》控制面板》启动应用程序》添加&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可能存在的缺点：&#xA;    登录进去之后会有“无法应用原保存的显示器配置”的提示（在使用xorg.conf时），不影响正常使用，因为xranr-config.sh文件已配置正确（该项暂未确认）。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;LVDS 1280x800&#xA;VGA 1280x1024&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果上下放：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --auto&#xA;xrandr --output VGA --above LVDS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;那么gnome上下两个面板就分别在VGA顶部和LVDS底部,如果左右放：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --right-of LVDS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;那么gnome的上面面板会延长到占满LVDS+VGA&#xA;而且窗口最大化就会占据LVDS+VGA的整个桌面&#xA;怎么设置能让面板不扩展到另外的显示器呢？&#xA;还要使得窗口最大化时只占满当前显示器&#xA;也就是VGA出来的是一个空屏幕。。。。。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output LVDS --mode 1280x768 --output VGA --mode 1280x1024 \ --above LVDS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;xrandr 介紹&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr指令可以用來改變X環境的桌面大小和螢幕頻率.&#xA;把桌面解析度調成1024×768:&#xA;$ xrandr -s 1024x768&#xA;把螢幕頻率調成75Hz&#xA;$ xrandr -r 75&#xA;列出目前環境支援的解析度和頻率&#xA;$ xrandr -q&#xA;它列出的訊息, 每行的第一個數字可以用來指定給 -s 參數, 假設有一行這麼寫&#xA;20 640 x 480 ( 347mm x 260mm ) 75&#xA;那麼下&#xA;$ xrandr -s 20&#xA;時, 就會把螢幕調成 640×480 大小, 頻率75Hz&#xA;如果有數個X環境同時運作的話, 可以用 -d 參數去調整別的X環境, -d 後面加的是像 :0 :1 :2 這樣, 例如:&#xA;$ xrandr -s 800x600 -d :0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Jsoncpp的使用</title>
      <link>http://www.nljb.net/default/Jsoncpp%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;*. 下载jsoncpp源码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;C++要使用JSON来解析数据，一般采用jsoncpp. &#xA;网站：http://sourceforge.net/projects/jsoncpp/&#xA;我下载的时候最新版本是 jsoncpp-src-0.5.0.tar.gz&#xA;这里有一个拷贝（http://dl.iteye.com/topics/download/4cb5ff91-e210-3e0b-9496-fd31a787a6c7）&#xA;解压到一个目录，然后编译成对应机器可用的lib。然后引入它的json.h头文件就可以使用了。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;*. 下载编译jsoncpp的python编译工具并配置环境变量到临时console&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;关键是这个lib怎么编译出来，下面说一下步骤：&#xA;编译jsconcpp要使用scons，scons又是一个牛叉的工具，功能和GNU make一样，又比make简单多了。scons是python工具，需要先安装好python。&#xA;下载 scons，解压就可以使用了。&#xA;scons下载地址：http://sourceforge.net/projects/scons/files/scons/2.3.0/ 本文附件中也有一个拷贝&#xA;在要编译jsoncpp的console中导出scons的环境变量临时用一下即可。不必配置到开机启动的环境变量中。&#xA;$export MYSCONS=your_extract_path&#xA;$export MYSCONS_LIB_DIR=$MYSCONS/engine&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;*. 编译jsoncpp lib&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ cd jsoncpp-src-0.5.0&#xA;$ python $MYSCONS/script/scons platform=linux-gcc&#xA;一切正常的话，可以在 jsoncpp-src-0.5.0/libs/linux-gcc-x.x 下看到一个动态文件库（so）和一个静态文件库（a）。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;*. 将jsoncpp库拷贝到系统库下方便使用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ cd jsoncpp-src-0.5.0/libs/linux-gcc-4.7&#xA;$ mv libjson_linux-gcc-4.7_libmt.so libjson.so&#xA;$sudo cp libjson.so /usr/lib&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;*. 代码演示&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;cassert&amp;gt;&#xA;#include &amp;quot;json/json.h&amp;quot;&#xA;using namespace std;&#xA;&#xA;int main()&#xA;{&#xA;    string json_str = &amp;quot;{\&amp;quot;name\&amp;quot;:\&amp;quot;zzg\&amp;quot;,\&amp;quot;age\&amp;quot;:100}&amp;quot;;&#xA;&#xA;    Json::Reader reader;&#xA;    Json::Value root;&#xA;    if (!reader.parse(json_str, root, false))&#xA;    {&#xA;    cout&amp;lt;&amp;lt;&amp;quot;parse error&amp;quot;&amp;lt;&amp;lt;endl;&#xA;    return -1;&#xA;    }&#xA;&#xA;    cout &amp;lt;&amp;lt; &amp;quot;test read:&amp;quot; &amp;lt;&amp;lt; endl;&#xA;    std::string name = root[&amp;quot;name&amp;quot;].asString();&#xA;    int age = root[&amp;quot;age&amp;quot;].asInt();&#xA;&#xA;    std::cout&amp;lt;&amp;lt;name&amp;lt;&amp;lt;std::endl;&#xA;    std::cout&amp;lt;&amp;lt;age&amp;lt;&amp;lt;std::endl;&#xA;&#xA;&#xA;    cout&amp;lt;&amp;lt;&amp;quot;test write:&amp;quot;&amp;lt;&amp;lt;endl;&#xA;    Json::FastWriter writer;&#xA;    json_str = writer.write(root);&#xA;    cout&amp;lt;&amp;lt;json_str&amp;lt;&amp;lt;endl;&#xA;    return 0;&#xA;}&#xA;&#xA;&#xA;&#xA;#include &amp;lt;fstream&amp;gt;&#xA;#include &amp;lt;cassert&amp;gt;&#xA;#include &amp;quot;json/json.h&amp;quot;&#xA;using namespace std;&#xA;&#xA;int main()&#xA;{&#xA;    ifstream ifs;&#xA;    ifs.open(&amp;quot;testjson.json&amp;quot;);&#xA;    assert(ifs.is_open());&#xA;&#xA;    Json::Reader reader;&#xA;    Json::Value root;&#xA;    if (!reader.parse(ifs, root, false))&#xA;    {&#xA;    return -1;&#xA;    }&#xA;&#xA;    std::string name = root[&amp;quot;name&amp;quot;].asString();&#xA;    int age = root[&amp;quot;age&amp;quot;].asInt();&#xA;&#xA;    std::cout&amp;lt;&amp;lt;name&amp;lt;&amp;lt;std::endl;&#xA;    std::cout&amp;lt;&amp;lt;age&amp;lt;&amp;lt;std::endl;&#xA;&#xA;    return 0;&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;    // 原始&#xA;    string json_str = &amp;quot;{\&amp;quot;name\&amp;quot;:\&amp;quot;home\&amp;quot;}&amp;quot;;&#xA;&#xA;    // 解析(Json-&amp;gt;Value)&#xA;    Json::Reader reader;&#xA;    Json::Value root;&#xA;    if (!reader.parse(json_str, root, false)) {&#xA;    exit(1);&#xA;    }&#xA;&#xA;    // 读取&#xA;    string name = root[&amp;quot;name&amp;quot;].asString();&#xA;    cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; std::endl;&#xA;&#xA;    // 写入(Value-&amp;gt;Json)&#xA;    Json::FastWriter writer;&#xA;    json_str = writer.write(root);&#xA;    cout &amp;lt;&amp;lt; json_str &amp;lt;&amp;lt; endl;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之路-定时任务</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E8%B7%AF-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;timer := time.NewTicker(2 * time.Second)&#xA;for {&#xA;    select {&#xA;    case &amp;lt;-timer.C:&#xA;&#xA;        go func() {&#xA;         log.Println(time.Now())&#xA;        }()&#xA;    }&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-设置系统时间</title>
      <link>http://www.nljb.net/default/Golang-%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 接收UDP时间广播，并设置系统时间&#xA;func (sl *Slaver) masTimeSync(ch chan int) {&#xA;    // 开始监听广播时间&#xA;    log.Printf(&amp;quot;time sync listen [%s]&amp;quot;, sl.Node.Port.PortUdpSlaTimeSync)&#xA;    for {&#xA;    (func() {&#xA;        // 监听 mas 发来的同步时间&#xA;        lis, err := socket.NewListen(&amp;quot;&amp;quot;, sl.Node.Port.PortUdpSlaTimeSync, 3).ListenUDP()&#xA;        // 判断监听是否建立成功&#xA;        if err != nil {&#xA;        // 异常抛出&#xA;        log.Fatalln(err)&#xA;        }&#xA;        // 保证监听正常关闭&#xA;        defer lis.Close()&#xA;        // 循环接收&#xA;        for {&#xA;        // 每个时间戳大小不超过32字节&#xA;        data := make([]byte, 32)&#xA;        // 读取时间戳&#xA;        read, addr, err := lis.ReadFromUDP(data)&#xA;        // 检查是否接收错误&#xA;        if err != nil {&#xA;            // 错误时从新接收&#xA;            continue&#xA;        }&#xA;        // 判断是否为注册服务器所发&#xA;        if addr != nil &amp;amp;&amp;amp; strings.HasPrefix(addr.String(), sl.MasAddr) {&#xA;            // 转换远程时间戳&#xA;            l, _ := strconv.ParseInt(fmt.Sprintf(&amp;quot;%s&amp;quot;, data[0:read]), 10, 64)&#xA;            //// 转换时间格式&#xA;            //time := syscall.NsecToTimeval(l)&#xA;            //// 设置系统时间 &amp;quot;Linux Private Settimeofday&amp;quot;&#xA;            //if err := syscall.Settimeofday(&amp;amp;time); err != nil {&#xA;            //  // 异常抛出&#xA;            //  log.Fatalln(err)&#xA;            //}&#xA;            // 设置到系统&#xA;            cmd := exec.Command(&amp;quot;date&amp;quot;, &amp;quot;-s&amp;quot;, time.Unix(0, l).Format(&amp;quot;01/02/2006 15:04:05.999999999&amp;quot;))&#xA;            // 设置&#xA;            cmd.Run()&#xA;        }&#xA;        }&#xA;    })()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-实现图片缩放</title>
      <link>http://www.nljb.net/default/Golang-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;graphics&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;strconv&amp;quot;&#xA;    &amp;quot;strings&amp;quot;&#xA;)&#xA;func main() {&#xA;    http.HandleFunc(&amp;quot;/&amp;quot;, doImageHandler)&#xA;    http.ListenAndServe(&amp;quot;127.0.0.1:6789&amp;quot;, nil)&#xA;}&#xA;&#xA;func doImageHandler(w http.ResponseWriter, r *http.Request) {&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(r.URL.Path, &amp;quot;/&amp;quot;))&#xA;    url := strings.Split(r.URL.Path, &amp;quot;/&amp;quot;)&#xA;    if len(url) != 3 {&#xA;    return&#xA;    }&#xA;    newdx, uerr := strconv.Atoi(url[1])&#xA;    if uerr != nil {&#xA;    log.Fatal(uerr)&#xA;    }&#xA;    src, err := LoadImage(url[2])&#xA;    bound := src.Bounds()&#xA;    dx := bound.Dx()&#xA;    dy := bound.Dy()&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;    // 缩略图的大小&#xA;    dst := image.NewRGBA(image.Rect(0, 0, newdx, newdx*dy/dx))&#xA;    // 产生缩略图,等比例缩放&#xA;    err = graphics.Scale(dst, src)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;    header := w.Header()&#xA;    header.Add(&amp;quot;Content-Type&amp;quot;, &amp;quot;image/jpeg&amp;quot;)&#xA;&#xA;    png.Encode(w, dst)&#xA;}&#xA;&#xA;&#xA;// Load Image decodes an image from a file of image.&#xA;func LoadImage(path string) (img image.Image, err error) {&#xA;    file, err := os.Open(path)&#xA;    if err != nil {&#xA;    return&#xA;    }&#xA;    defer file.Close()&#xA;    img, _, err = image.Decode(file)&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;///////////////////////////////////////////////////////////////////////&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package mas&#xA;&#xA;import (&#xA;    &amp;quot;code.google.com/p/graphics-go/graphics&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    z &amp;quot;github.com/nutzam/zgo&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;)&#xA;&#xA;func (ma *Master) ActiveImage(pobj string) error {&#xA;&#xA;    // 文件绝对路径&#xA;    var path string = pobj&#xA;&#xA;    // 保留源图Image结构&#xA;    var img image.Image&#xA;&#xA;    // 图片类型&#xA;    typef := z.FileType(path)&#xA;&#xA;    // 按照图片格式加载图片&#xA;    switch typef {&#xA;    // JPEG&#xA;    case &amp;quot;jpeg&amp;quot;:&#xA;    // ImageJPEG&#xA;    img = z.ImageJPEG(path)&#xA;    // JPG&#xA;    case &amp;quot;jpg&amp;quot;:&#xA;    // ImageJPEG&#xA;    img = z.ImageJPEG(path)&#xA;    // PNG&#xA;    case &amp;quot;png&amp;quot;:&#xA;    // ImagePNG&#xA;    img = z.ImagePNG(path)&#xA;    }&#xA;&#xA;    // 判断加载原图片是否成功&#xA;    if img == nil {&#xA;    // 返回错误&#xA;    return fmt.Errorf(&amp;quot;active image decode exception ...&amp;quot;)&#xA;    }&#xA;&#xA;    // -------------------------------------------------------- //&#xA;&#xA;    // 获取屏幕数量&#xA;    moniSize := ma.NodeConf.MonitorSize(ma)&#xA;&#xA;    // 获取屏幕分辨率&#xA;    width := ma.NodeConf.Resolution.Width&#xA;    height := ma.NodeConf.Resolution.Height&#xA;&#xA;    // 获取素材平均值&#xA;    widthMoni := img.Bounds().Dx() / moniSize.Col&#xA;    heightMoni := img.Bounds().Dy() / moniSize.Row&#xA;&#xA;    // -------------------------------------------------------- //&#xA;&#xA;    // 遍历屏幕,切割图片&#xA;    for _, monis := range ma.NodeConf.Layout {&#xA;&#xA;    // 遍历节点屏幕&#xA;    for _, moni := range monis {&#xA;&#xA;        // 获取图片&#xA;        row := moni.Display.Row&#xA;        col := moni.Display.Col&#xA;&#xA;        // 生成目标背景图&#xA;        backgroundSrc := z.ImageRGBA(widthMoni, heightMoni)&#xA;&#xA;        // 生成目标图&#xA;        z.ImageDrawRGBA(backgroundSrc, img, (col-1)*widthMoni, (row-1)*heightMoni)&#xA;&#xA;        // 生成最终背景图&#xA;        background := z.ImageRGBA(width, height)&#xA;&#xA;        // 产生最终图&#xA;        graphics.Scale(background, backgroundSrc)&#xA;&#xA;        // 按照图片格式保存图片&#xA;        switch typef {&#xA;        // JPEG&#xA;        case &amp;quot;jpeg&amp;quot;:&#xA;        // ImageEncodeJPEG&#xA;        z.ImageEncodeJPEG(fmt.Sprintf(&amp;quot;%s.pic_result/%d_%d.%s&amp;quot;, path, col, row, typef), background)&#xA;        // JPG&#xA;        case &amp;quot;jpg&amp;quot;:&#xA;        // ImageEncodeJPEG&#xA;        z.ImageEncodeJPEG(fmt.Sprintf(&amp;quot;%s.pic_result/%d_%d.%s&amp;quot;, path, col, row, typef), background)&#xA;        // PNG&#xA;        case &amp;quot;png&amp;quot;:&#xA;        // ImageEncodePNG&#xA;        z.ImageEncodePNG(fmt.Sprintf(&amp;quot;%s.pic_result/%d_%d.%s&amp;quot;, path, col, row, typef), background)&#xA;        }&#xA;&#xA;    }&#xA;&#xA;    }&#xA;&#xA;    // 返回&#xA;    return nil&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;///////////////////////////////////////////////////////////////&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package z&#xA;&#xA;import (&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/draw&amp;quot;&#xA;    &amp;quot;image/jpeg&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;// 读取JPEG图片返回image.Image对象&#xA;func ImageJPEG(ph string) image.Image {&#xA;    // 打开图片文件&#xA;    f, fileErr := os.Open(ph)&#xA;    if fileErr != nil {&#xA;    return nil&#xA;    }&#xA;    // 退出时关闭文件&#xA;    defer f.Close()&#xA;    // 解码&#xA;    j, jErr := jpeg.Decode(f)&#xA;    if jErr != nil {&#xA;    return nil&#xA;    }&#xA;    // 返回解码后的图片&#xA;    return j&#xA;}&#xA;&#xA;// 读取PNG图片返回image.Image对象&#xA;func ImagePNG(ph string) image.Image {&#xA;    // 打开图片文件&#xA;    f, fileErr := os.Open(ph)&#xA;    if fileErr != nil {&#xA;    return nil&#xA;    }&#xA;    // 退出时关闭文件&#xA;    defer f.Close()&#xA;    // 解码&#xA;    p, pErr := png.Decode(f)&#xA;    if pErr != nil {&#xA;    return nil&#xA;    }&#xA;    // 返回解码后的图片&#xA;    return p&#xA;}&#xA;&#xA;// 按照分辨率创建一张空白图片对象&#xA;func ImageRGBA(width, height int) *image.RGBA {&#xA;    // 建立图像,image.Rect(最小X,最小Y,最大X,最小Y)&#xA;    return image.NewRGBA(image.Rect(0, 0, width, height))&#xA;}&#xA;&#xA;// 将图片绘制到图片&#xA;func ImageDrawRGBA(img *image.RGBA, imgcode image.Image, x, y int) {&#xA;    // 绘制图像&#xA;    // image.Point A点的X,Y坐标,轴向右和向下增加{0,0}&#xA;    // image.ZP ZP is the zero Point&#xA;    // image.Pt Pt is shorthand for Point{X, Y}&#xA;    draw.Draw(img, img.Bounds(), imgcode, image.Pt(x, y), draw.Over)&#xA;}&#xA;&#xA;// JPEG将编码生成图片&#xA;// 选择编码参数,质量范围从1到100,更高的是更好 &amp;amp;jpeg.Options{90}&#xA;func ImageEncodeJPEG(ph string, img image.Image) error {&#xA;    // 确保文件父目录存在&#xA;    FcheckParents(ph)&#xA;    // 打开文件等待写入&#xA;    f := FileW(ph)&#xA;    // 保证文件正常关闭&#xA;    defer f.Close()&#xA;    // 写入文件&#xA;    return jpeg.Encode(f, img, &amp;amp;jpeg.Options{100})&#xA;}&#xA;&#xA;// PNG将编码生成图片&#xA;func ImageEncodePNG(ph string, img image.Image) error {&#xA;    // 确保文件父目录存在&#xA;    FcheckParents(ph)&#xA;    // 打开文件等待写入&#xA;    f := FileW(ph)&#xA;    // 保证文件正常关闭&#xA;    defer f.Close()&#xA;    // 写入文件&#xA;    return png.Encode(f, img)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang 传递 小抄</title>
      <link>http://www.nljb.net/default/Golang-%E4%BC%A0%E9%80%92-%E5%B0%8F%E6%8A%84/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;一些学习总结&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1、GoLang里面interface类型式一切类型的基类型，一个函数的参数如果始inteface{}，说明可以接受一切类型，只要这个类型中包含需要的那个方法，调用时候就不会失败；&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func test(i interface{}){&#xA;    i.Get()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2、方法定义中可以制定某个类型（或者指针）是其调用者，方法的返回可以按照名称返回；&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (p *A) test(i int){&#xA;&#xA;}&#xA;&#xA;func test()(p int){&#xA;    p:=1&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3、switch流程可以强制穿透功能；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;4、语意上对并发的支持，用go关键词；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;5、make关键词只能创建channel,数组类型；其它对象的创建用new关键词；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;6、方法内用new关键词创建的对象（指针）可以返回，用&amp;amp;标记也可以返回本地指针；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;7、方法参数如果是数字，除了类型相同外，大小必须明确，否则视为slice类型；数组传参是按照值传递，map、slice按照引用传递；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;8、数组，slice，map结构的遍历用range实现；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;9、不支持指针地址的++操作；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;10、type  A struct{} 、type B A 、type  C struct{A} 三个类型中A和C可以共享方法，B和A不共享方法；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;11、反射（自省）可以获得类型的字段和方法信息，和Python/Java/CSharp类似，没有深入研究；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;12、defer 在方法返回时调用，如果方法中有多个go 方法，会在每个go 方法调用完后被执行；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;13、类型转换，基本类型(string,bytes,int,float）之间的转换通过内置方法实现，struct通过 struct名称(变量名称)，也可以通过reflect及switch实现(接口变量名.(type))；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;14、change/select/chan 类似与Unix中的管道概念，支持读、写操作；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;15、对于复杂类型的格式化输出可以用 %#v ，这个格式化出来的信息比较全面；&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang http 超时设置方法</title>
      <link>http://www.nljb.net/default/Golang-http-%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;c := http.Client{&#xA;    Transport: &amp;amp;http.Transport{&#xA;        Dial: func(netw, addr string) (net.Conn, error) {&#xA;        deadline := time.Now().Add(25 * time.Second)&#xA;        c, err := net.DialTimeout(netw, addr, time.Second*20)&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        c.SetDeadline(deadline)&#xA;        return c, nil&#xA;        },&#xA;    },&#xA;    }&#xA;&#xA;c.Get(&amp;quot;http://www.qq.com&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;//////////////////////////////////////////////&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 上载请求&#xA;func NetUploadJson(addr string, buf interface{}) (*[]byte, *int, error) {&#xA;    // 将需要上传的JSON转为Byte&#xA;    v, _ := json.Marshal(buf)&#xA;    // 上传JSON数据&#xA;    req, e := http.NewRequest(&amp;quot;POST&amp;quot;, addr, bytes.NewReader(v))&#xA;    if e != nil {&#xA;    // 提交异常,返回错误&#xA;    return nil, nil, e&#xA;    }&#xA;    // Body Type&#xA;    req.Header.Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)&#xA;    // 完成后断开连接&#xA;    req.Header.Set(&amp;quot;Connection&amp;quot;, &amp;quot;close&amp;quot;)&#xA;    // -------------------------------------------&#xA;    // 设置 TimeOut&#xA;    DefaultClient := http.Client{&#xA;    Transport: &amp;amp;http.Transport{&#xA;        Dial: func(netw, addr string) (net.Conn, error) {&#xA;        deadline := time.Now().Add(30 * time.Second)&#xA;        c, err := net.DialTimeout(netw, addr, time.Second*30)&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        c.SetDeadline(deadline)&#xA;        return c, nil&#xA;        },&#xA;    },&#xA;    }&#xA;    // -------------------------------------------&#xA;    // 执行&#xA;    resp, ee := DefaultClient.Do(req)&#xA;    if ee != nil {&#xA;    // 提交异常,返回错误&#xA;    return nil, nil, ee&#xA;    }&#xA;    // 保证I/O正常关闭&#xA;    defer resp.Body.Close()&#xA;    // 判断返回状态&#xA;    if resp.StatusCode == http.StatusOK {&#xA;    // 读取返回的数据&#xA;    data, err := ioutil.ReadAll(resp.Body)&#xA;    if err != nil {&#xA;        // 读取异常,返回错误&#xA;        return nil, nil, err&#xA;    }&#xA;    // 将收到的数据与状态返回&#xA;    return &amp;amp;data, &amp;amp;resp.StatusCode, nil&#xA;    } else if resp.StatusCode != http.StatusOK {&#xA;    // 返回异常状态&#xA;    return nil, &amp;amp;resp.StatusCode, nil&#xA;    }&#xA;    // 不会到这里&#xA;    return nil, nil, nil&#xA;}&#xA;&#xA;// 下载文件&#xA;func NetDownloadFile(addr string) (*[]byte, *int, *http.Header, error) {&#xA;    // 上传JSON数据&#xA;    req, e := http.NewRequest(&amp;quot;GET&amp;quot;, addr, nil)&#xA;    if e != nil {&#xA;    // 返回异常&#xA;    return nil, nil, nil, e&#xA;    }&#xA;    // 完成后断开连接&#xA;    req.Header.Set(&amp;quot;Connection&amp;quot;, &amp;quot;close&amp;quot;)&#xA;    // -------------------------------------------&#xA;    // 设置 TimeOut&#xA;    DefaultClient := http.Client{&#xA;    Transport: &amp;amp;http.Transport{&#xA;        Dial: func(netw, addr string) (net.Conn, error) {&#xA;        deadline := time.Now().Add(30 * time.Second)&#xA;        c, err := net.DialTimeout(netw, addr, time.Second*30)&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        c.SetDeadline(deadline)&#xA;        return c, nil&#xA;        },&#xA;    },&#xA;    }&#xA;    // -------------------------------------------&#xA;    // 执行&#xA;    resp, ee := DefaultClient.Do(req)&#xA;    if ee != nil {&#xA;    // 返回异常&#xA;    return nil, nil, nil, ee&#xA;    }&#xA;    // 保证I/O正常关闭&#xA;    defer resp.Body.Close()&#xA;    // 判断请求状态&#xA;    if resp.StatusCode == 200 {&#xA;    data, err := ioutil.ReadAll(resp.Body)&#xA;    if err != nil {&#xA;        // 读取错误,返回异常&#xA;        return nil, nil, nil, err&#xA;    }&#xA;    // 成功，返回数据及状态&#xA;    return &amp;amp;data, &amp;amp;resp.StatusCode, &amp;amp;resp.Header, nil&#xA;    } else {&#xA;    // 失败，返回状态&#xA;    return nil, &amp;amp;resp.StatusCode, nil, nil&#xA;    }&#xA;    // 不会到这里&#xA;    return nil, nil, nil, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-Screenshot</title>
      <link>http://www.nljb.net/default/Golang-Screenshot/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// http://godoc.org/github.com/vova616/screenshot&#xA;&#xA;package screenshot&#xA;import (&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;github.com/BurntSushi/xgb&amp;quot;&#xA;    &amp;quot;github.com/BurntSushi/xgb/xproto&amp;quot;&#xA;)&#xA;func ScreenRect() (image.Rectangle, error) {&#xA;    c, err := xgb.NewConn()&#xA;    if err != nil {&#xA;    return image.Rectangle{}, err&#xA;    }&#xA;    defer c.Close()&#xA;    screen := xproto.Setup(c).DefaultScreen(c)&#xA;    x := screen.WidthInPixels&#xA;    y := screen.HeightInPixels&#xA;    return image.Rect(0, 0, int(x), int(y)), nil&#xA;}&#xA;func CaptureScreen() (*image.RGBA, error) {&#xA;    r, e := ScreenRect()&#xA;    if e != nil {&#xA;    return nil, e&#xA;    }&#xA;    return CaptureRect(r)&#xA;}&#xA;func CaptureRect(rect image.Rectangle) (*image.RGBA, error) {&#xA;    c, err := xgb.NewConn()&#xA;    if err != nil {&#xA;    return nil, err&#xA;    }&#xA;    defer c.Close()&#xA;    screen := xproto.Setup(c).DefaultScreen(c)&#xA;    x, y := rect.Dx(), rect.Dy()&#xA;    xImg, err := xproto.GetImage(c, xproto.ImageFormatZPixmap, xproto.Drawable(screen.Root), int16(rect.Min.X), int16(rect.Min.Y), uint16(x), uint16(y), 0xffffffff).Reply()&#xA;    if err != nil {&#xA;    return nil, err&#xA;    }&#xA;    data := xImg.Data&#xA;    for i := 0; i &amp;lt; len(data); i += 4 {&#xA;    data[i], data[i+2], data[i+3] = data[i+2], data[i], 255&#xA;    }&#xA;    img := &amp;amp;image.RGBA{data, 4 * x, image.Rect(0, 0, x, y)}&#xA;    return img, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang Go语言断点续传</title>
      <link>http://www.nljb.net/default/Golang-Go%E8%AF%AD%E8%A8%80%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;http&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;strconv&amp;quot;&#xA;)&#xA;&#xA;const (&#xA;    UA = &amp;quot;Golang Downloader from Kejibo.com&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    f, err := os.OpenFile(&amp;quot;./file.exe&amp;quot;, os.O_RDWR, 0666)  //其实这里的 O_RDWR应该是 O_RDWR|O_CREATE，也就是文件不存在的情况下就建一个空文件，但是因为windows下还有BUG，如果使用这个O_CREATE，就会直接清空文件，所以这里就不用了这个标志，你自己事先建立好文件。&#xA;    if err != nil { panic(err) }&#xA;    stat, err := f.Stat()   //获取文件状态&#xA;    if err != nil { panic(err) }&#xA;    f.Seek(stat.Size, 0)    //把文件指针指到文件末，当然你说为何不直接用 O_APPEND 模式打开，没错是可以。我这里只是试验。&#xA;    url := &amp;quot;http://dl.google.com/chrome/install/696.57/chrome_installer.exe&amp;quot;&#xA;    var req http.Request&#xA;    req.Method = &amp;quot;GET&amp;quot;&#xA;    req.UserAgent = UA&#xA;    req.Close = true&#xA;    req.URL, err = http.ParseURL(url)&#xA;    if err != nil { panic(err) }&#xA;    header := http.Header{}&#xA;    header.Set(&amp;quot;Range&amp;quot;, &amp;quot;bytes=&amp;quot; + strconv.Itoa64(stat.Size) + &amp;quot;-&amp;quot;)&#xA;    req.Header = header&#xA;    resp, err := http.DefaultClient.Do(&amp;amp;req)&#xA;    if err != nil { panic(err) }&#xA;    written, err := io.Copy(f, resp.Body)&#xA;    if err != nil { panic(err) }&#xA;    println(&amp;quot;written: &amp;quot;, written)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go-Ping</title>
      <link>http://www.nljb.net/default/Go-Ping/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package conn&#xA;&#xA;import (&#xA;&amp;quot;bytes&amp;quot;&#xA;&amp;quot;net&amp;quot;&#xA;&amp;quot;os&amp;quot;&#xA;&amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;const (&#xA;ICMP_ECHO_REQUEST = 8&#xA;ICMP_ECHO_REPLY   = 0&#xA;)&#xA;&#xA;// Ping Request&#xA;func makePingRequest(id, seq, pktlen int, filler []byte) []byte {&#xA;p := make([]byte, pktlen)&#xA;copy(p[8:], bytes.Repeat(filler, (pktlen-8)/len(filler)+1))&#xA;&#xA;p[0] = ICMP_ECHO_REQUEST // type&#xA;p[1] = 0                 // code&#xA;p[2] = 0                 // cksum&#xA;p[3] = 0                 // cksum&#xA;p[4] = uint8(id &amp;gt;&amp;gt; 8)    // id&#xA;p[5] = uint8(id &amp;amp; 0xff)  // id&#xA;p[6] = uint8(seq &amp;gt;&amp;gt; 8)   // sequence&#xA;p[7] = uint8(seq &amp;amp; 0xff) // sequence&#xA;&#xA;// calculate icmp checksum&#xA;cklen := len(p)&#xA;s := uint32(0)&#xA;for i := 0; i &amp;lt; (cklen - 1); i += 2 {&#xA;s += uint32(p[i+1])&amp;lt;&amp;lt;8 | uint32(p[i])&#xA;}&#xA;if cklen&amp;amp;1 == 1 {&#xA;s += uint32(p[cklen-1])&#xA;}&#xA;s = (s &amp;gt;&amp;gt; 16) + (s &amp;amp; 0xffff)&#xA;s = s + (s &amp;gt;&amp;gt; 16)&#xA;&#xA;// place checksum back in header; using ^= avoids the&#xA;// assumption the checksum bytes are zero&#xA;p[2] ^= uint8(^s &amp;amp; 0xff)&#xA;p[3] ^= uint8(^s &amp;gt;&amp;gt; 8)&#xA;&#xA;return p&#xA;}&#xA;&#xA;func parsePingReply(p []byte) (id, seq int) {&#xA;id = int(p[4])&amp;lt;&amp;lt;8 | int(p[5])&#xA;seq = int(p[6])&amp;lt;&amp;lt;8 | int(p[7])&#xA;return&#xA;}&#xA;&#xA;// Ping&#xA;func Ping(addr string, i int) bool {&#xA;&#xA;// *IPAddr&#xA;raddr, e := net.ResolveIPAddr(&amp;quot;ip4&amp;quot;, addr)&#xA;if e != nil {&#xA;return false&#xA;}&#xA;&#xA;// *IPConn&#xA;ipconn, ee := net.DialIP(&amp;quot;ip4:icmp&amp;quot;, nil, raddr)&#xA;if ee != nil {&#xA;return false&#xA;}&#xA;&#xA;// 保证连接正常关闭&#xA;defer ipconn.Close()&#xA;&#xA;// PID&#xA;sendid := os.Getpid() &amp;amp; 0xffff&#xA;sendseq := 1&#xA;pingpktlen := 64&#xA;&#xA;for {&#xA;&#xA;sendpkt := makePingRequest(sendid, sendseq, pingpktlen, []byte(&amp;quot;Go Ping&amp;quot;))&#xA;&#xA;// 发送请求&#xA;n, err := ipconn.WriteToIP(sendpkt, raddr)&#xA;if err != nil || n != pingpktlen {&#xA;break&#xA;}&#xA;&#xA;// 超时&#xA;ipconn.SetDeadline(time.Now().Add(5 * time.Second))&#xA;&#xA;// 返回数据&#xA;resp := make([]byte, 1024)&#xA;for {&#xA;&#xA;// 读取返回&#xA;_, _, err := ipconn.ReadFrom(resp)&#xA;if err != nil {&#xA;break&#xA;}&#xA;&#xA;// 判断状态&#xA;if resp[0] != ICMP_ECHO_REPLY {&#xA;continue&#xA;}&#xA;&#xA;// 判断状态&#xA;rcvid, rcvseq := parsePingReply(resp)&#xA;if rcvid != sendid || rcvseq != sendseq {&#xA;break&#xA;}&#xA;&#xA;// 成功返回&#xA;return true&#xA;&#xA;}&#xA;&#xA;// 执行次数内未成功返回&#xA;if i == sendseq {&#xA;break&#xA;}&#xA;&#xA;// 计数器&#xA;sendseq++&#xA;&#xA;}&#xA;&#xA;// 失败返回&#xA;return false&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
  </channel>
</rss>